1
00:00:00,000 --> 00:00:00,820

2
00:00:00,820 --> 00:00:02,910
IAN NI-LEWIS: Welcome,
audio diehards.

3
00:00:02,910 --> 00:00:06,770
We're so happy to
have you here.

4
00:00:06,770 --> 00:00:09,960
It's great to see that more
than 10 or 15 people would

5
00:00:09,960 --> 00:00:12,150
like to hear about high
performance audio on Android.

6
00:00:12,150 --> 00:00:13,400
We were running bets.

7
00:00:13,400 --> 00:00:15,600

8
00:00:15,600 --> 00:00:17,080
So I'm Ian Ni-Lewis.

9
00:00:17,080 --> 00:00:19,390
I'm the developer relations
contact for audio.

10
00:00:19,390 --> 00:00:23,790
If you send audio questions to
our developers support email,

11
00:00:23,790 --> 00:00:26,880
probably I will answer them.

12
00:00:26,880 --> 00:00:29,550
But today, it's my great
pleasure to introduce a couple

13
00:00:29,550 --> 00:00:32,800
friends of mine from the
engineering team, Glenn Kasten

14
00:00:32,800 --> 00:00:36,970
and Raph Levien, who have
actually done a huge amount of

15
00:00:36,970 --> 00:00:41,710
work in the last couple of years
to set the standard for

16
00:00:41,710 --> 00:00:44,110
Android audio and
make it better.

17
00:00:44,110 --> 00:00:47,910
And you're going to be hearing
today some happy stories and

18
00:00:47,910 --> 00:00:53,850
some sad stories just
to prep you on that.

19
00:00:53,850 --> 00:00:57,175
But believe me, these guys have
advanced to state of the

20
00:00:57,175 --> 00:01:02,695
art for Android audio more than
anyone else and also Raph

21
00:01:02,695 --> 00:01:04,769
did some, too.

22
00:01:04,769 --> 00:01:07,020
I know you were going
to call me on that.

23
00:01:07,020 --> 00:01:08,750
Anyway, I start stop talking.

24
00:01:08,750 --> 00:01:12,170
Let's go ahead and welcome Glenn
Kasten to begin High

25
00:01:12,170 --> 00:01:14,122
Performance Audio on Android.

26
00:01:14,122 --> 00:01:19,790
[APPLAUSE]

27
00:01:19,790 --> 00:01:20,970
GLENN KASTEN: Hi, everyone.

28
00:01:20,970 --> 00:01:21,940
I'm Glenn Kasten.

29
00:01:21,940 --> 00:01:25,850
I'm on the Android audio team,
and my job is to provide great

30
00:01:25,850 --> 00:01:28,320
Android audio performance.

31
00:01:28,320 --> 00:01:35,470
I work with our OEMs and silicon
chip vendors to help

32
00:01:35,470 --> 00:01:38,840
them build devices that have
really great audio.

33
00:01:38,840 --> 00:01:40,810
And my goal is to provide
you developers

34
00:01:40,810 --> 00:01:42,360
really top notch audio.

35
00:01:42,360 --> 00:01:44,040
That's what I'm working on.

36
00:01:44,040 --> 00:01:45,520
I know what you want to hear.

37
00:01:45,520 --> 00:01:49,510
So let me disappoint you first,
as Ian was hinting at.

38
00:01:49,510 --> 00:01:51,230
We're not quite there yet.

39
00:01:51,230 --> 00:01:56,830
But the good news is we are
definitely making progress.

40
00:01:56,830 --> 00:01:59,280
So today, we're going to tell
you the story of what we've

41
00:01:59,280 --> 00:02:02,600
been doing so far and how you
can take advantage of the work

42
00:02:02,600 --> 00:02:03,470
we've done so far.

43
00:02:03,470 --> 00:02:05,230
We're also going to tell you
about what's coming up in the

44
00:02:05,230 --> 00:02:07,700
future in terms of our
performance goals.

45
00:02:07,700 --> 00:02:09,770
Now, performance could mean a
lot of different things to

46
00:02:09,770 --> 00:02:10,930
different people.

47
00:02:10,930 --> 00:02:13,900
But today, we're
going to focus.

48
00:02:13,900 --> 00:02:17,110
We're going to focus among all
these different things on just

49
00:02:17,110 --> 00:02:22,070
one area, which is
output latency.

50
00:02:22,070 --> 00:02:25,910
If you're interested in input
latency or other kinds of

51
00:02:25,910 --> 00:02:30,110
audio performance, definitely
check us out at office hours.

52
00:02:30,110 --> 00:02:32,340
Actually, check us out at office
hours anyway even if

53
00:02:32,340 --> 00:02:34,170
you're not interested
in something else.

54
00:02:34,170 --> 00:02:35,560
We want to talk to you about
the other things.

55
00:02:35,560 --> 00:02:38,360
But today, we're just going to
focus on output latency,

56
00:02:38,360 --> 00:02:40,580
because that's the area we've
made the most progress over

57
00:02:40,580 --> 00:02:42,930
the last two years.

58
00:02:42,930 --> 00:02:47,580
So with regards to latency, this
is a mock slide showing

59
00:02:47,580 --> 00:02:51,460
where we were, where we are now,
and where we want to be.

60
00:02:51,460 --> 00:02:54,720
But it doesn't really tell the
whole story of why did it take

61
00:02:54,720 --> 00:02:57,670
us on to get to this point,
what's the work that's been

62
00:02:57,670 --> 00:03:00,870
done, what's the work ahead,
what can you do as audio

63
00:03:00,870 --> 00:03:01,810
developers?

64
00:03:01,810 --> 00:03:03,780
So today, we're going
to really get into

65
00:03:03,780 --> 00:03:06,950
this in more detail.

66
00:03:06,950 --> 00:03:09,510
Explaining that is a really
big job, and so I brought

67
00:03:09,510 --> 00:03:13,060
along my buddy, Raph, who's
going to help me out.

68
00:03:13,060 --> 00:03:15,910
RAPH LEVIEN: Hi, my name is Raph
Levien, and I work on the

69
00:03:15,910 --> 00:03:17,470
Android Frameworks team.

70
00:03:17,470 --> 00:03:19,120
You may know me--

71
00:03:19,120 --> 00:03:21,320
Glenn, next slide--

72
00:03:21,320 --> 00:03:24,370
from such features
as Inconsolata,

73
00:03:24,370 --> 00:03:25,930
the programming font.

74
00:03:25,930 --> 00:03:27,690
Now, my day job--

75
00:03:27,690 --> 00:03:30,670
next slide-- my day job
is font and text

76
00:03:30,670 --> 00:03:31,570
rendering on Android.

77
00:03:31,570 --> 00:03:33,940
But in my spare time, I've
been building a software

78
00:03:33,940 --> 00:03:36,710
emulation of the Yamaha
DX7 synthesizer.

79
00:03:36,710 --> 00:03:40,100
I actually brought the original
with me today.

80
00:03:40,100 --> 00:03:44,780
But I've been building software
emulation, and I

81
00:03:44,780 --> 00:03:47,640
really wanted the emulation
to be as beautiful as the

82
00:03:47,640 --> 00:03:49,020
original synthesizer.

83
00:03:49,020 --> 00:03:51,070
And in fact, that's
how I met Glenn.

84
00:03:51,070 --> 00:03:52,720
I was trying to figure out
why I couldn't get better

85
00:03:52,720 --> 00:03:55,610
performance running my synth
engine on Android.

86
00:03:55,610 --> 00:03:59,620
And Glenn's name kept popping
up in email threads about

87
00:03:59,620 --> 00:04:00,940
audio latency.

88
00:04:00,940 --> 00:04:03,980
GLENN KASTEN: And I fixed
all of his problems.

89
00:04:03,980 --> 00:04:05,030
RAPH LEVIEN: Well, let's
just tell the story.

90
00:04:05,030 --> 00:04:08,190
It's a good story.

91
00:04:08,190 --> 00:04:10,580
GLENN KASTEN: When Raph first
contacted me, we were already

92
00:04:10,580 --> 00:04:12,320
looking into audio
performance.

93
00:04:12,320 --> 00:04:15,100
The Android Frameworks team,
the graphics team, and the

94
00:04:15,100 --> 00:04:17,680
apps team, they were all looking
into performance, too,

95
00:04:17,680 --> 00:04:21,130
mostly on the touch side and
on the graphic side.

96
00:04:21,130 --> 00:04:22,630
But the audio team was
definitely looking into

97
00:04:22,630 --> 00:04:23,600
performance, too.

98
00:04:23,600 --> 00:04:28,700
And overall, we were calling
this Project Butter.

99
00:04:28,700 --> 00:04:30,960
We were all thinking, how
can we make things

100
00:04:30,960 --> 00:04:34,030
more fast, more smooth?

101
00:04:34,030 --> 00:04:36,490
But when it came to audio,
there was really only one

102
00:04:36,490 --> 00:04:39,550
thing that everybody
knew for certain.

103
00:04:39,550 --> 00:04:43,120
The latency was just
too darn high--

104
00:04:43,120 --> 00:04:44,950
no question about that.

105
00:04:44,950 --> 00:04:46,840
RAPH LEVIEN: I think I was
in same situation as

106
00:04:46,840 --> 00:04:47,880
a lot of you guys.

107
00:04:47,880 --> 00:04:50,070
I was writing a musical
instrument that was supposed

108
00:04:50,070 --> 00:04:51,070
to be responsive.

109
00:04:51,070 --> 00:04:53,750
But I could hear a noticeable
delay between the time I hit a

110
00:04:53,750 --> 00:04:57,670
key and the time my
app responded.

111
00:04:57,670 --> 00:05:00,500
Latency is the delay as a signal
passes through the

112
00:05:00,500 --> 00:05:04,440
system, from your
app to sound.

113
00:05:04,440 --> 00:05:06,770
Some musicians, like organists,
are trained to deal

114
00:05:06,770 --> 00:05:08,980
with high latencies if
it's consistent.

115
00:05:08,980 --> 00:05:11,250
But most people are sensitive
to latencies greater than

116
00:05:11,250 --> 00:05:12,980
about 20 milliseconds.

117
00:05:12,980 --> 00:05:14,850
And some can't deal with
any latency at all.

118
00:05:14,850 --> 00:05:17,960
Any percussionists
or singers here?

119
00:05:17,960 --> 00:05:20,350
I wasn't asking for
zero latency.

120
00:05:20,350 --> 00:05:22,920
I would've been happy with 10,
maybe even 20 milliseconds.

121
00:05:22,920 --> 00:05:25,970
But I was hearing noticeable
delays-- over 100 milliseconds

122
00:05:25,970 --> 00:05:28,020
on some devices.

123
00:05:28,020 --> 00:05:30,480
This story is about how Glenn
helped me get my app's latency

124
00:05:30,480 --> 00:05:33,360
down to where it became a
truly playable synth.

125
00:05:33,360 --> 00:05:36,540
As you'll see, it took us some
work on both the Android side

126
00:05:36,540 --> 00:05:37,830
and the app side.

127
00:05:37,830 --> 00:05:40,000
So as we tell the story, we're
going to keep a running to do

128
00:05:40,000 --> 00:05:42,950
list of things we've done,
things we still need to do,

129
00:05:42,950 --> 00:05:45,400
and things you need to do in
your app to get low latency

130
00:05:45,400 --> 00:05:46,850
audio to work.

131
00:05:46,850 --> 00:05:48,400
GLENN KASTEN: Now, I know you're
all dragging out your

132
00:05:48,400 --> 00:05:50,370
notebooks now to start writing
down this to do list.

133
00:05:50,370 --> 00:05:51,270
But don't worry.

134
00:05:51,270 --> 00:05:53,450
We are going to show the to
do list at the end also.

135
00:05:53,450 --> 00:05:56,080

136
00:05:56,080 --> 00:05:58,350
The first thing, the most
important thing, and you're

137
00:05:58,350 --> 00:05:59,880
going to see this throughout
the whole talk.

138
00:05:59,880 --> 00:06:02,370
It's going to keep coming up
over and over and over again,

139
00:06:02,370 --> 00:06:05,050
is measure everything.

140
00:06:05,050 --> 00:06:06,830
We do it, and we hope
you will too.

141
00:06:06,830 --> 00:06:08,710
RAPH LEVIEN: Before you can
make changes to improve

142
00:06:08,710 --> 00:06:11,040
performance, you have to have
an objective measurement of

143
00:06:11,040 --> 00:06:11,780
how bad it is.

144
00:06:11,780 --> 00:06:13,850
Otherwise, you're
flying blind.

145
00:06:13,850 --> 00:06:16,550
GLENN KASTEN: My brother, Steven
was a musician, and he

146
00:06:16,550 --> 00:06:18,080
also built electronics.

147
00:06:18,080 --> 00:06:20,520
And I told them about
my project working

148
00:06:20,520 --> 00:06:22,410
here on audio latency.

149
00:06:22,410 --> 00:06:26,770
And he encouraged me to get an
oscilloscope, because, lets

150
00:06:26,770 --> 00:06:30,780
face it, real engineers
have scopes.

151
00:06:30,780 --> 00:06:34,700
So even though I worked at
Google, I do have a budget.

152
00:06:34,700 --> 00:06:37,650
So I got the cheapest
oscilloscope I could find.

153
00:06:37,650 --> 00:06:41,070
And it's definitely not anything
fancy, not good for

154
00:06:41,070 --> 00:06:42,270
high speed communications.

155
00:06:42,270 --> 00:06:45,610
But it was certainly perfectly
adequate for audio.

156
00:06:45,610 --> 00:06:47,340
RAPH LEVIEN: The scope makes
it possible to get precise

157
00:06:47,340 --> 00:06:49,210
measurements, but the really
tricky part is getting

158
00:06:49,210 --> 00:06:52,080
accurately and reproducable
measurements, especially if we

159
00:06:52,080 --> 00:06:54,640
want to hopefully someday make
this part of the Android

160
00:06:54,640 --> 00:06:56,490
compatibility testing suite.

161
00:06:56,490 --> 00:06:59,200
We also need to make sure we
isolate audio output latency

162
00:06:59,200 --> 00:07:01,610
from the other sources of delay
in a system, like the

163
00:07:01,610 --> 00:07:03,480
audio input or the
touch panel.

164
00:07:03,480 --> 00:07:05,030
Glenn came up with a cool
way to do that.

165
00:07:05,030 --> 00:07:07,600

166
00:07:07,600 --> 00:07:09,752
GLENN KASTEN: So besides the
scope, another great tool that

167
00:07:09,752 --> 00:07:13,280
I love is the LED, or lighting
emitting diode.

168
00:07:13,280 --> 00:07:15,670
I remember discovering the LED
when I was 12 years old, and

169
00:07:15,670 --> 00:07:17,350
I've been in love
ever since then.

170
00:07:17,350 --> 00:07:19,850
I think one of the greatest
things about a phone is the

171
00:07:19,850 --> 00:07:21,300
notification LED.

172
00:07:21,300 --> 00:07:26,440
It's so useful, so fast, and
yet it's really underused.

173
00:07:26,440 --> 00:07:30,220
I can measure audio latency with
an LED, a photo diode,

174
00:07:30,220 --> 00:07:31,410
and an oscilloscope.

175
00:07:31,410 --> 00:07:34,250
Basically, you just turn on the
LED at the same time as

176
00:07:34,250 --> 00:07:36,105
your application is outputting
audio data.

177
00:07:36,105 --> 00:07:38,680

178
00:07:38,680 --> 00:07:40,980
Then measure the difference in
time between when you can

179
00:07:40,980 --> 00:07:44,680
detect the light from the LED
and when you can detect the

180
00:07:44,680 --> 00:07:46,380
audio signal.

181
00:07:46,380 --> 00:07:48,560
That difference is latency.

182
00:07:48,560 --> 00:07:51,760
So my brother was into
electronics.

183
00:07:51,760 --> 00:07:53,310
I was, too, especially
when I was younger.

184
00:07:53,310 --> 00:07:56,410
So I brought back my electronics
kit, and I started

185
00:07:56,410 --> 00:07:57,470
with a bread board design.

186
00:07:57,470 --> 00:07:59,560
This is it.

187
00:07:59,560 --> 00:08:02,290
Later on, one of our hardware
engineers, Clinton, helped me

188
00:08:02,290 --> 00:08:05,510
out, and he made be a real live
printed circuit board,

189
00:08:05,510 --> 00:08:07,090
which you can see here.

190
00:08:07,090 --> 00:08:09,000
No, it does not actually have
a red border on it.

191
00:08:09,000 --> 00:08:11,770
That's just a highlight.

192
00:08:11,770 --> 00:08:13,710
And here's the result with
an oscilloscope.

193
00:08:13,710 --> 00:08:16,960
Basically, the yellow trace is
the light detector from the

194
00:08:16,960 --> 00:08:19,060
LED to the photo diode.

195
00:08:19,060 --> 00:08:21,920
And the blue trace
is the audio.

196
00:08:21,920 --> 00:08:24,750
I unfortunately can't really
get into exact numbers.

197
00:08:24,750 --> 00:08:25,500
They don't let me here.

198
00:08:25,500 --> 00:08:27,680
But let's just say that it
was a really big number--

199
00:08:27,680 --> 00:08:29,320
way too big.

200
00:08:29,320 --> 00:08:31,880
So let's talk about why.

201
00:08:31,880 --> 00:08:34,120
RAPH LEVIEN: Latency in the real
world is complex, but in

202
00:08:34,120 --> 00:08:36,280
software, it generally boils
down to one thing--

203
00:08:36,280 --> 00:08:37,530
chains of buffers.

204
00:08:37,530 --> 00:08:39,640

205
00:08:39,640 --> 00:08:42,070
GLENN KASTEN: Here's a typical
un-optimized audio pipeline,

206
00:08:42,070 --> 00:08:44,720
the kind that I found when I
first started looking at this

207
00:08:44,720 --> 00:08:46,810
problem a couple years ago.

208
00:08:46,810 --> 00:08:49,110
As you can see from this
diagram, we have four buffers

209
00:08:49,110 --> 00:08:52,010
of 1,024 frames or 23

210
00:08:52,010 --> 00:08:55,080
milliseconds each at 44 kilohertz.

211
00:08:55,080 --> 00:08:58,580
And that's just in the audio
hardware abstraction layer, or

212
00:08:58,580 --> 00:09:00,290
HAL, and the kernel driver.

213
00:09:00,290 --> 00:09:03,280
That doesn't even count the
buffers in the media server,

214
00:09:03,280 --> 00:09:07,800
in the DSP, in the mixer,
certainly not in the

215
00:09:07,800 --> 00:09:09,960
application.

216
00:09:09,960 --> 00:09:11,630
RAPH LEVIEN: In case that's
not clear, that's a huge

217
00:09:11,630 --> 00:09:12,400
amount of buffering.

218
00:09:12,400 --> 00:09:15,220
There's 92 milliseconds of
latency right there.

219
00:09:15,220 --> 00:09:16,990
If you're an audio developer,
you've got to be asking

220
00:09:16,990 --> 00:09:18,830
yourself, why are the
buffers so big?

221
00:09:18,830 --> 00:09:20,835
And why are there
so many of them?

222
00:09:20,835 --> 00:09:23,120
GLENN KASTEN: So there is a
technical explanation, which

223
00:09:23,120 --> 00:09:24,370
we're going to get into today.

224
00:09:24,370 --> 00:09:27,290
But I also think there's a
social explanation, and we'll

225
00:09:27,290 --> 00:09:30,000
hint at it throughout the
talk today, too, also.

226
00:09:30,000 --> 00:09:31,320
RAPH LEVIEN: Let's start
with the technical.

227
00:09:31,320 --> 00:09:33,150
It has to do with power
consumption.

228
00:09:33,150 --> 00:09:36,510
The larger the interval between
CPU core wake ups, the

229
00:09:36,510 --> 00:09:38,620
less power needed.

230
00:09:38,620 --> 00:09:39,960
GLENN KASTEN: As you
know, mobile

231
00:09:39,960 --> 00:09:41,390
phones run on batteries.

232
00:09:41,390 --> 00:09:42,930
Batteries have limited life.

233
00:09:42,930 --> 00:09:46,100
So the CPU switches on and off
very, very frequently between

234
00:09:46,100 --> 00:09:48,330
normal state and low
power state.

235
00:09:48,330 --> 00:09:51,570
The size of each audio buffer
basically puts a lower bound

236
00:09:51,570 --> 00:09:54,450
on the amount of time that the
CPU can be asleep before it

237
00:09:54,450 --> 00:09:57,940
has to wake up again and process
the next audio buffer.

238
00:09:57,940 --> 00:10:01,820
To a certain extent, that
defines both your power

239
00:10:01,820 --> 00:10:04,890
consumption and your
potential latency.

240
00:10:04,890 --> 00:10:07,500
And if you want to reduce power,
you have to add more

241
00:10:07,500 --> 00:10:11,310
buffering so the CPU doesn't
have to wake up as often.

242
00:10:11,310 --> 00:10:14,610
As for the social component, my
theory is that buffering is

243
00:10:14,610 --> 00:10:18,400
just a really quick and easy
way to fix audio glitches.

244
00:10:18,400 --> 00:10:21,680
If you hear a glitch, almost
always it seems that if you

245
00:10:21,680 --> 00:10:25,220
just make your buffers bigger,
it'll make it go away.

246
00:10:25,220 --> 00:10:29,920
And unless you actively police
buffer sizes, they're going to

247
00:10:29,920 --> 00:10:31,860
continue to increase
over time.

248
00:10:31,860 --> 00:10:33,930
RAPH LEVIEN: And other than a
devoted band of developers,

249
00:10:33,930 --> 00:10:36,310
like you and me, it didn't
seem like anyone in the

250
00:10:36,310 --> 00:10:39,010
Android world has had a
compelling incentive to reduce

251
00:10:39,010 --> 00:10:40,250
buffer sizes.

252
00:10:40,250 --> 00:10:42,420
I think a lot of us suspected
that there wasn't actually any

253
00:10:42,420 --> 00:10:44,590
particularly good reason
for latency to be

254
00:10:44,590 --> 00:10:45,450
as high as it was.

255
00:10:45,450 --> 00:10:48,530
Maybe the buffers were just
bigger than they had to be.

256
00:10:48,530 --> 00:10:50,070
GLENN KASTEN: Sounds
simple, huh?

257
00:10:50,070 --> 00:10:52,230
Well, this turned out
to be a pretty easy

258
00:10:52,230 --> 00:10:55,100
hypothesis to disprove.

259
00:10:55,100 --> 00:10:56,450
I tried an experiment.

260
00:10:56,450 --> 00:10:58,820
Remember, we started with
four buffers of 23

261
00:10:58,820 --> 00:10:59,880
milliseconds each.

262
00:10:59,880 --> 00:11:02,080
So I just said, OK, let's
make them smaller.

263
00:11:02,080 --> 00:11:03,180
Let's have fewer of them.

264
00:11:03,180 --> 00:11:07,660
Instead of four of 23, I went
down to two of 12 or 13, then

265
00:11:07,660 --> 00:11:08,360
two of six.

266
00:11:08,360 --> 00:11:10,670
And eventually, on one device, I
was even able to get down to

267
00:11:10,670 --> 00:11:12,500
two buffers of three
milliseconds.

268
00:11:12,500 --> 00:11:14,450
I didn't try to change the
system architecture or

269
00:11:14,450 --> 00:11:16,460
anything else, just
the buffers.

270
00:11:16,460 --> 00:11:17,770
And amazingly, it worked.

271
00:11:17,770 --> 00:11:22,160

272
00:11:22,160 --> 00:11:23,670
Audio still played.

273
00:11:23,670 --> 00:11:25,650
The latency went down
dramatically.

274
00:11:25,650 --> 00:11:27,830
I was done.

275
00:11:27,830 --> 00:11:29,170
RAPH LEVIEN: You were done?

276
00:11:29,170 --> 00:11:29,580
Are you sure?

277
00:11:29,580 --> 00:11:34,710
GLENN KASTEN: Well, you knew the
talk wouldn't be over now.

278
00:11:34,710 --> 00:11:36,430
It did work most of the time.

279
00:11:36,430 --> 00:11:38,600
But every once in awhile,
I heard a

280
00:11:38,600 --> 00:11:41,620
click, a pop, an underrun.

281
00:11:41,620 --> 00:11:44,550
And this really did make
me sick to my stomach.

282
00:11:44,550 --> 00:11:48,430
I know it's hard for me to
show it today, but I felt

283
00:11:48,430 --> 00:11:50,390
awful every time I heard
those clicks.

284
00:11:50,390 --> 00:11:52,590
And I knew this was not
going to be so easy.

285
00:11:52,590 --> 00:11:54,540
RAPH LEVIEN: And I've have
a lot of experience with

286
00:11:54,540 --> 00:11:55,570
underruns myself.

287
00:11:55,570 --> 00:11:57,370
I heard them on my synthesizer
when I had

288
00:11:57,370 --> 00:11:58,620
too many voices playing.

289
00:11:58,620 --> 00:12:01,020
I think it's worth talking a
little bit about the methods

290
00:12:01,020 --> 00:12:03,020
we used to detect them.

291
00:12:03,020 --> 00:12:03,720
GLENN KASTEN: Definitely.

292
00:12:03,720 --> 00:12:07,080
But first, let's listen to
some underruns together.

293
00:12:07,080 --> 00:12:07,510
Don't worry.

294
00:12:07,510 --> 00:12:11,240
It's only a few seconds, but we
want all of us to use the

295
00:12:11,240 --> 00:12:12,350
same terminology.

296
00:12:12,350 --> 00:12:14,000
In this clip, we're going
to first hear

297
00:12:14,000 --> 00:12:15,970
a few shorter clicks.

298
00:12:15,970 --> 00:12:18,380
Followed by some longer
dropouts.

299
00:12:18,380 --> 00:12:20,902
They're all underruns.

300
00:12:20,902 --> 00:12:38,710
[MUSIC PLAYING]

301
00:12:38,710 --> 00:12:41,330
GLENN KASTEN: Did everybody
hear those?

302
00:12:41,330 --> 00:12:43,470
We're a little worried, because
in a room this large,

303
00:12:43,470 --> 00:12:44,760
there's quite a bit of reverb.

304
00:12:44,760 --> 00:12:48,120
And what Raph and I have found
is that when you're listening

305
00:12:48,120 --> 00:12:51,730
with speakers, and especially
in a room with a lot of

306
00:12:51,730 --> 00:12:54,050
reverb, that it's harder to
hear those underruns.

307
00:12:54,050 --> 00:12:57,080
So that's one reason why we
personally prefer to listen

308
00:12:57,080 --> 00:12:58,790
for audio problems
with headphones.

309
00:12:58,790 --> 00:13:01,290
Or as you'll soon see, we
actually like to look for them

310
00:13:01,290 --> 00:13:02,540
visually, too.

311
00:13:02,540 --> 00:13:06,540

312
00:13:06,540 --> 00:13:08,390
So we heard the underruns.

313
00:13:08,390 --> 00:13:09,580
Let's look at them visually.

314
00:13:09,580 --> 00:13:11,130
I mentioned we were going to.

315
00:13:11,130 --> 00:13:14,460
Here is a long 15 millisecond
underrun in the audio editor

316
00:13:14,460 --> 00:13:16,760
tool called Audacity.

317
00:13:16,760 --> 00:13:17,400
RAPH LEVIEN: Those long
underruns are

318
00:13:17,400 --> 00:13:19,030
pretty easy to spot.

319
00:13:19,030 --> 00:13:20,770
GLENN KASTEN: Yeah, but
unfortunately, I wasn't just

320
00:13:20,770 --> 00:13:21,960
hearing those long ones.

321
00:13:21,960 --> 00:13:23,360
I was also hearing
short clicks.

322
00:13:23,360 --> 00:13:25,150
And those were really hard
to find with Audacity.

323
00:13:25,150 --> 00:13:28,580

324
00:13:28,580 --> 00:13:29,360
Here's one here.

325
00:13:29,360 --> 00:13:32,620
This is only 64 frames, I
believe, which is 1 and 1/2

326
00:13:32,620 --> 00:13:37,230
milliseconds, I think at either
44 or 48 kilohertz.

327
00:13:37,230 --> 00:13:39,820
And it took me a long time
to find this one.

328
00:13:39,820 --> 00:13:41,250
I just didn't have
the patience to

329
00:13:41,250 --> 00:13:42,560
keep looking for these.

330
00:13:42,560 --> 00:13:44,570
RAPH LEVIEN: Yeah, they're
tricky to spot in time domain.

331
00:13:44,570 --> 00:13:47,650
But in the frequency domain,
underruns pop out.

332
00:13:47,650 --> 00:13:50,050
Here's that same area after
a Fourier transform.

333
00:13:50,050 --> 00:13:51,820
See those spikes on the right?

334
00:13:51,820 --> 00:13:54,690
Those regularly spaced
spikes mean trouble.

335
00:13:54,690 --> 00:13:57,990
You use Frequency Domain View,
and then you can binary search

336
00:13:57,990 --> 00:14:00,445
to help zoom in on the
shortest underruns.

337
00:14:00,445 --> 00:14:01,400
GLENN KASTEN: So let's
get back to my

338
00:14:01,400 --> 00:14:03,230
problem, my latency problem.

339
00:14:03,230 --> 00:14:05,880
I notice that when I reduced
buffer sizes, the latency went

340
00:14:05,880 --> 00:14:08,200
down, but I also was hearing
these clicks.

341
00:14:08,200 --> 00:14:09,040
RAPH LEVIEN: So we were wrong.

342
00:14:09,040 --> 00:14:12,090
The buffers were just about as
big as they had to be to keep

343
00:14:12,090 --> 00:14:14,220
the audio from glitching.

344
00:14:14,220 --> 00:14:15,600
They weren't just about
saving power.

345
00:14:15,600 --> 00:14:17,020
They were also keeping
it clean.

346
00:14:17,020 --> 00:14:17,880
GLENN KASTEN:

347
00:14:17,880 --> 00:14:20,420
GLENN KASTEN: Now we needed to
figure out why, why those

348
00:14:20,420 --> 00:14:21,550
glitches were happening.

349
00:14:21,550 --> 00:14:24,380
And while I was working on the
system problem, it turned out

350
00:14:24,380 --> 00:14:26,410
Raph had also collected some
data of his own, which we're

351
00:14:26,410 --> 00:14:28,140
going to look at right now.

352
00:14:28,140 --> 00:14:28,830
RAPH LEVIEN: That's right.

353
00:14:28,830 --> 00:14:30,430
Isn't this beautiful?

354
00:14:30,430 --> 00:14:32,560
Maybe I should take a couple
of minutes and explain what

355
00:14:32,560 --> 00:14:34,340
this plot is showing.

356
00:14:34,340 --> 00:14:37,750
What I was measuring is the
start time and the end time of

357
00:14:37,750 --> 00:14:39,420
every open SL callback.

358
00:14:39,420 --> 00:14:42,800
This is by far the most useful
information you can log.

359
00:14:42,800 --> 00:14:45,260
At first, I was doing this to
profile how long my own code

360
00:14:45,260 --> 00:14:45,750
took to run.

361
00:14:45,750 --> 00:14:47,760
But I ended up learning
a lot about how the

362
00:14:47,760 --> 00:14:49,360
system worked as well.

363
00:14:49,360 --> 00:14:52,970
So let's start with a little
bit of background.

364
00:14:52,970 --> 00:14:56,110
GLENN KASTEN: So we used Open
SLES from Cronos Group.

365
00:14:56,110 --> 00:15:00,440
And in our implementation, the
audio runs on a separate

366
00:15:00,440 --> 00:15:02,390
thread inside of your
application process.

367
00:15:02,390 --> 00:15:04,910
And the thread runs in a tight
little loop that looks a lot

368
00:15:04,910 --> 00:15:07,300
like a helix, like a spring.

369
00:15:07,300 --> 00:15:10,875
Each time through the loop, our
Open SLES implementation

370
00:15:10,875 --> 00:15:14,050
will call your buffer completion
callback handler to

371
00:15:14,050 --> 00:15:15,920
generate the next buffer.

372
00:15:15,920 --> 00:15:18,070
RAPH LEVIEN: The time between
two successive callbacks is

373
00:15:18,070 --> 00:15:19,320
the cycle time.

374
00:15:19,320 --> 00:15:20,890
GLENN KASTEN: And ideally,
the cycle time should be

375
00:15:20,890 --> 00:15:21,710
consistent.

376
00:15:21,710 --> 00:15:25,460
In part, it should be equal
to the size of one buffer.

377
00:15:25,460 --> 00:15:27,390
RAPH LEVIEN: So in an ideal
world, if we plotted the

378
00:15:27,390 --> 00:15:30,070
callback time against the
expected callback time, we'd

379
00:15:30,070 --> 00:15:31,880
see a perfectly straight line.

380
00:15:31,880 --> 00:15:33,140
Of course, nothing is perfect.

381
00:15:33,140 --> 00:15:35,510
If we plot the time that
callbacks actually arrive

382
00:15:35,510 --> 00:15:37,970
against the expected time of
arrival, we're going to see

383
00:15:37,970 --> 00:15:39,640
some deviations.

384
00:15:39,640 --> 00:15:42,360
Each little squiggle in this
graph represents a deviation

385
00:15:42,360 --> 00:15:44,300
from the ideal callback
timing.

386
00:15:44,300 --> 00:15:46,400
But to tell the truth, I have
a hard time using this graph

387
00:15:46,400 --> 00:15:48,400
to tell exactly how bad
the deviation is.

388
00:15:48,400 --> 00:15:51,360
Instead, I like to view the
data a little differently.

389
00:15:51,360 --> 00:15:54,490
Instead of looking at callback
times, I just look at how

390
00:15:54,490 --> 00:15:57,510
early or late each
callback arrived.

391
00:15:57,510 --> 00:16:00,610
Here, the y-axis is a
measurement of deviation from

392
00:16:00,610 --> 00:16:04,250
ideal timing amplified, so
we can see it better.

393
00:16:04,250 --> 00:16:05,560
You can think this as
a measurement of

394
00:16:05,560 --> 00:16:06,720
the system's jitter.

395
00:16:06,720 --> 00:16:08,700
I've also changed the
x-axis a bit.

396
00:16:08,700 --> 00:16:10,990
Instead of being measured in
time, it's simply a count of

397
00:16:10,990 --> 00:16:12,290
how many callbacks
have arrived.

398
00:16:12,290 --> 00:16:15,010
That way, I can compare the
jitter of two different

399
00:16:15,010 --> 00:16:16,180
systems, even if they
have different

400
00:16:16,180 --> 00:16:18,390
callback cycle times.

401
00:16:18,390 --> 00:16:20,040
GLENN KASTEN: So now that we
know how we're measuring and

402
00:16:20,040 --> 00:16:24,600
displaying this jitter, let's
look at some real world data.

403
00:16:24,600 --> 00:16:26,360
RAPH LEVIEN: So this is taken
from a build of Ice Cream

404
00:16:26,360 --> 00:16:29,446
Sandwich that's close to
the one Glenn used.

405
00:16:29,446 --> 00:16:31,220
GLENN KASTEN: It looks
interesting.

406
00:16:31,220 --> 00:16:33,800
But why does it slope down
and to the right?

407
00:16:33,800 --> 00:16:37,780
RAPH LEVIEN: That downward trend
is actually a difference

408
00:16:37,780 --> 00:16:40,770
in timing between the audio
clock and the system clock.

409
00:16:40,770 --> 00:16:43,490
So let's look at the
corrected version.

410
00:16:43,490 --> 00:16:46,500
Now remember an ideal system
would show all zeros on the

411
00:16:46,500 --> 00:16:49,210
y-axis, meaning that every
buffer completion callback had

412
00:16:49,210 --> 00:16:50,640
arrived exactly on time.

413
00:16:50,640 --> 00:16:52,600
Of course, no system
is perfect.

414
00:16:52,600 --> 00:16:55,590
So what you'd expect to see in a
good, real world system is a

415
00:16:55,590 --> 00:16:59,150
tight cluster of values right
around the zero mark.

416
00:16:59,150 --> 00:17:03,270
GLENN KASTEN: It looks kind of
like that, mostly, at least

417
00:17:03,270 --> 00:17:05,960
the green part.

418
00:17:05,960 --> 00:17:08,210
RAPH LEVIEN: Yeah, but you also
see a lot of callbacks

419
00:17:08,210 --> 00:17:10,040
arriving five or 10
milliseconds late.

420
00:17:10,040 --> 00:17:13,730
That's manageable, even
if it's not ideal.

421
00:17:13,730 --> 00:17:15,980
GLENN KASTEN: But I don't like
those red ones there,

422
00:17:15,980 --> 00:17:17,410
especially at the beginning--

423
00:17:17,410 --> 00:17:18,220
those outliers.

424
00:17:18,220 --> 00:17:23,010
They look like 20, 30,
35 milliseconds late.

425
00:17:23,010 --> 00:17:23,560
RAPH LEVIEN: Dang.

426
00:17:23,560 --> 00:17:27,099
That's with those giant buffers
were for, not just to

427
00:17:27,099 --> 00:17:30,080
save power, but to cover for the
fact that the audio system

428
00:17:30,080 --> 00:17:33,100
was delivering some of these
callbacks really late.

429
00:17:33,100 --> 00:17:35,590
GLENN KASTEN: Now, this really
bothered me, because Android

430
00:17:35,590 --> 00:17:36,800
is not a real time system.

431
00:17:36,800 --> 00:17:40,750
But we had configured the thread
priorities for audio to

432
00:17:40,750 --> 00:17:44,310
be nice little minus 19 for the
system mixer and then nice

433
00:17:44,310 --> 00:17:47,910
little minus 16 for application
threads.

434
00:17:47,910 --> 00:17:50,550
And the schedule really should
not have been doing this.

435
00:17:50,550 --> 00:17:53,770
It just didn't make sense.

436
00:17:53,770 --> 00:17:56,350
Just to give you background on
nice values, basically, if

437
00:17:56,350 --> 00:18:00,295
this pie is all the available
CPU time, than numerically low

438
00:18:00,295 --> 00:18:03,690
or nice values, like minus 19
and minus 16 should get more

439
00:18:03,690 --> 00:18:04,970
of the CPU pie.

440
00:18:04,970 --> 00:18:08,270
And they should be scheduled
on a regular cadence, not

441
00:18:08,270 --> 00:18:11,910
waiting 10s of milliseconds
and certainly not 35.

442
00:18:11,910 --> 00:18:13,610
RAPH LEVIEN: So those jitter
outliers who saw in the

443
00:18:13,610 --> 00:18:15,720
previous slide, those are going
to cause underruns.

444
00:18:15,720 --> 00:18:17,950
What was happening in the
system to cause them?

445
00:18:17,950 --> 00:18:20,010
GLENN KASTEN: That's exactly
what I wanted to know.

446
00:18:20,010 --> 00:18:21,470
So I dug a lot deeper.

447
00:18:21,470 --> 00:18:24,040
Now, I'm not a Linux Kernel
expert, but I do have a

448
00:18:24,040 --> 00:18:25,940
background in real time
operating systems.

449
00:18:25,940 --> 00:18:27,850
I used to write real
time Kernels.

450
00:18:27,850 --> 00:18:30,920
And so I feel very comfortable
jumping in and doing some

451
00:18:30,920 --> 00:18:32,950
system measurements at
the current level.

452
00:18:32,950 --> 00:18:35,820
At the time, we didn't have the
sys trace tool, which you

453
00:18:35,820 --> 00:18:36,910
may have heard of.

454
00:18:36,910 --> 00:18:40,300
And I didn't know about the
existing Linux tools for

455
00:18:40,300 --> 00:18:41,770
tracing, like f trace.

456
00:18:41,770 --> 00:18:43,770
So instead, I just built
my own custom

457
00:18:43,770 --> 00:18:45,940
context switch tracer.

458
00:18:45,940 --> 00:18:47,080
This is what it looked like.

459
00:18:47,080 --> 00:18:49,570
Basically, every time there was
a context switch, it would

460
00:18:49,570 --> 00:18:52,270
log information about
this context

461
00:18:52,270 --> 00:18:53,270
switch into a ring buffer.

462
00:18:53,270 --> 00:18:56,140
The information was basically
the next thread about to run

463
00:18:56,140 --> 00:18:58,900
and whatever was the current
system monotonic time.

464
00:18:58,900 --> 00:19:01,600

465
00:19:01,600 --> 00:19:03,460
Then what I would do is
I would play audio.

466
00:19:03,460 --> 00:19:06,250
And at the same time, I would
run my context switch tracer.

467
00:19:06,250 --> 00:19:10,060
And whenever I heard a glitch,
I would look and see what was

468
00:19:10,060 --> 00:19:12,960
happening in the system at
the time of that glitch.

469
00:19:12,960 --> 00:19:15,540
And it took me a long,
long time.

470
00:19:15,540 --> 00:19:17,870
But eventually, I found
what looked to me to

471
00:19:17,870 --> 00:19:21,180
be the smoking gun.

472
00:19:21,180 --> 00:19:23,870

473
00:19:23,870 --> 00:19:26,250
RAPH LEVIEN: This an excerpt of
Glenn's context switch log.

474
00:19:26,250 --> 00:19:28,880
The first 12 lines are exactly
what we want to see.

475
00:19:28,880 --> 00:19:31,200
The playback thread and the
audio track thread wake up, do

476
00:19:31,200 --> 00:19:33,950
their thing, and then go back to
sleep on a regular cadence.

477
00:19:33,950 --> 00:19:36,110
Those last four lines
look wrong.

478
00:19:36,110 --> 00:19:37,400
GLENN KASTEN: And by the
way, this is real data.

479
00:19:37,400 --> 00:19:40,040
All the data you're seeing
here today is real.

480
00:19:40,040 --> 00:19:42,310
This was the smoking gun.

481
00:19:42,310 --> 00:19:45,840
So let's look at that same data
as a sequence diagram.

482
00:19:45,840 --> 00:19:47,780
RAPH LEVIEN: You can see the
pattern here-- first, playback

483
00:19:47,780 --> 00:19:49,690
runs, then audio track
runs, and then

484
00:19:49,690 --> 00:19:51,380
lather, rinse, and repeat.

485
00:19:51,380 --> 00:19:53,490
But what happens near the
end of the trace?

486
00:19:53,490 --> 00:19:55,490
Right when the playback thread
was supposed to wake up,

487
00:19:55,490 --> 00:19:57,480
another task gets scheduled
instead.

488
00:19:57,480 --> 00:20:00,070
This is in spite of the fact
that the audio has a higher

489
00:20:00,070 --> 00:20:01,600
priority-- nice minus 19.

490
00:20:01,600 --> 00:20:02,770
How could that have happened?

491
00:20:02,770 --> 00:20:04,590
GLENN KASTEN: Well, it all comes
down to a Linux Kernel

492
00:20:04,590 --> 00:20:06,510
module, which is called
the completely fair

493
00:20:06,510 --> 00:20:09,230
scheduler, or CFS.

494
00:20:09,230 --> 00:20:11,010
Earlier, I showed this
slide showing nice

495
00:20:11,010 --> 00:20:12,960
values in the CPU pie.

496
00:20:12,960 --> 00:20:15,590
If you look really closely,
there's a very important

497
00:20:15,590 --> 00:20:16,450
caveat there.

498
00:20:16,450 --> 00:20:19,000
It says huge oversimplification.

499
00:20:19,000 --> 00:20:21,460
Nice values are not
a quota system.

500
00:20:21,460 --> 00:20:25,720
RAPH LEVIEN: The CFS scheduler
allocates CPU time fairly and

501
00:20:25,720 --> 00:20:28,430
proportionally to the nice
level in the long term.

502
00:20:28,430 --> 00:20:32,700
But it does not guarantee
wake up time.

503
00:20:32,700 --> 00:20:35,310
In these two timing diagrams,
the dark bars ar e audio

504
00:20:35,310 --> 00:20:37,630
threads, and the light bars
are other threads.

505
00:20:37,630 --> 00:20:40,610
To CFS, the top and bottom
diagrams are completely

506
00:20:40,610 --> 00:20:42,320
equivalent, but to an
audio programmer,

507
00:20:42,320 --> 00:20:43,950
they're completely different.

508
00:20:43,950 --> 00:20:45,200
We want the pattern on top.

509
00:20:45,200 --> 00:20:49,300

510
00:20:49,300 --> 00:20:52,190
GLENN KASTEN: So I tried
working around CFS.

511
00:20:52,190 --> 00:20:54,920
CFS has a lot of tuning
parameters.

512
00:20:54,920 --> 00:20:58,230
The most important one is the
scheduling interval or

513
00:20:58,230 --> 00:20:59,160
scheduling quantum.

514
00:20:59,160 --> 00:21:02,480
There are other parameters,
such as how often it will

515
00:21:02,480 --> 00:21:03,810
check for fairness.

516
00:21:03,810 --> 00:21:06,720
And when I turned those down to
really small numbers, I was

517
00:21:06,720 --> 00:21:09,630
able to get rid of most of
the audio underruns.

518
00:21:09,630 --> 00:21:11,980
But it turned out that all that
messing around with CFS

519
00:21:11,980 --> 00:21:14,060
parameter used a
lot more power.

520
00:21:14,060 --> 00:21:17,370
And even worse, it caused the
overall system throughput for

521
00:21:17,370 --> 00:21:19,930
non-audio threads to
go down because of

522
00:21:19,930 --> 00:21:21,710
excessive context switching.

523
00:21:21,710 --> 00:21:25,440
And worst of all, it didn't even
solve my audio underrun

524
00:21:25,440 --> 00:21:26,600
problem completely.

525
00:21:26,600 --> 00:21:29,430
It just reduced the frequency.

526
00:21:29,430 --> 00:21:31,070
RAPH LEVIEN: The most effective
tweaks just reduce

527
00:21:31,070 --> 00:21:32,980
the time slice that each
thread gets before the

528
00:21:32,980 --> 00:21:34,320
scheduler reevaluates.

529
00:21:34,320 --> 00:21:36,970
It doesn't change the core
algorithm, which is to try to

530
00:21:36,970 --> 00:21:38,570
be fair to every thread.

531
00:21:38,570 --> 00:21:40,400
But in our case, we don't
want to be fair.

532
00:21:40,400 --> 00:21:43,170
We want audio to go to the front
of the line every time.

533
00:21:43,170 --> 00:21:45,750
Reducing the time slice just
causes more content switching,

534
00:21:45,750 --> 00:21:47,290
which uses more power.

535
00:21:47,290 --> 00:21:49,070
GLENN KASTEN: So from my real
time operating system

536
00:21:49,070 --> 00:21:51,820
background working on kernels,
I knew about fixed priority

537
00:21:51,820 --> 00:21:52,410
scheduling--

538
00:21:52,410 --> 00:21:53,810
it's a very old concept--

539
00:21:53,810 --> 00:21:56,150
and I desperately wanted
to use it.

540
00:21:56,150 --> 00:21:59,060
The basic idea is that you
always run the highest

541
00:21:59,060 --> 00:22:01,930
priority ready to run task,
no matter what.

542
00:22:01,930 --> 00:22:05,070
And if you assign your
priorities correctly and

543
00:22:05,070 --> 00:22:08,920
appropriately, your system will
work, no matter what.

544
00:22:08,920 --> 00:22:10,680
RAPH LEVIEN: In Linux, this
means using a scheduling

545
00:22:10,680 --> 00:22:11,910
policy called SCHED FIFO.

546
00:22:11,910 --> 00:22:14,910
A lot of audio developers know
about SCHED FIFO, and we know

547
00:22:14,910 --> 00:22:17,280
that there are plenty of Linux
desktop programs that use it,

548
00:22:17,280 --> 00:22:19,200
and Android apps that try.

549
00:22:19,200 --> 00:22:20,500
But it doesn't work
in Android.

550
00:22:20,500 --> 00:22:22,330
On Ice Cream Sandwich,
it did nothing.

551
00:22:22,330 --> 00:22:24,960
And in Jelly Bean, been asking
for SCHED FIFO causes thread

552
00:22:24,960 --> 00:22:26,636
creation to fail.

553
00:22:26,636 --> 00:22:28,270
GLENN KASTEN: That's because
we disabled it

554
00:22:28,270 --> 00:22:29,450
for user mode threads.

555
00:22:29,450 --> 00:22:31,200
RAPH LEVIEN: Why did
you do that?

556
00:22:31,200 --> 00:22:32,642
GLENN KASTEN: Not me.

557
00:22:32,642 --> 00:22:35,840
Our assistant team was afraid of
denial of service, because

558
00:22:35,840 --> 00:22:39,020
basically, one errant SCHED FIFO
thread could hog the CPU

559
00:22:39,020 --> 00:22:40,720
and take down the
whole system.

560
00:22:40,720 --> 00:22:44,260
And yet we still handled
our callbacks on time.

561
00:22:44,260 --> 00:22:47,580
So I went back to our system
team, and I tried to make

562
00:22:47,580 --> 00:22:48,940
another case for SCHED FIFO.

563
00:22:48,940 --> 00:22:53,740

564
00:22:53,740 --> 00:22:56,710
I showed them slides with
numbers and statistics and

565
00:22:56,710 --> 00:22:57,700
power measurements.

566
00:22:57,700 --> 00:23:00,690
And this time, they sent me a
buddy, a Kernel expert named

567
00:23:00,690 --> 00:23:04,040
Dima, who you may
run into today.

568
00:23:04,040 --> 00:23:04,830
He's here.

569
00:23:04,830 --> 00:23:07,260
Dima helped me navigate the
issue and figure out how to

570
00:23:07,260 --> 00:23:09,430
mitigate the denial
of service risk.

571
00:23:09,430 --> 00:23:11,620
The answer turned out to be
based on a Kernel feature that

572
00:23:11,620 --> 00:23:13,660
actually Google started working
on several years ago

573
00:23:13,660 --> 00:23:17,450
in 2006 called Control
Groups, or C Groups.

574
00:23:17,450 --> 00:23:19,180
RAPH LEVIEN: Cgroups is
a system for resource

575
00:23:19,180 --> 00:23:19,620
accounting.

576
00:23:19,620 --> 00:23:21,920
You can use it for all kinds
of things, like setting CPU

577
00:23:21,920 --> 00:23:23,980
and memory quotas for different
processes or

578
00:23:23,980 --> 00:23:26,890
charging for cloud servers
by the CPU hour.

579
00:23:26,890 --> 00:23:29,260
In the case of Android, it lets
us prevent audio threads

580
00:23:29,260 --> 00:23:31,270
from ever exceeding
its CPU budget.

581
00:23:31,270 --> 00:23:35,120
And that mitigates the denial
of service attack.

582
00:23:35,120 --> 00:23:37,540
GLENN KASTEN: So in the end, the
system team did agree we

583
00:23:37,540 --> 00:23:40,900
could run audio threads at a
fixed priority if we used

584
00:23:40,900 --> 00:23:43,540
Cgroups to stay within the
budget they gave us, which was

585
00:23:43,540 --> 00:23:47,390
a whopping 5% of the CPU.

586
00:23:47,390 --> 00:23:49,980
Later on, we got that budget
increased, but actually

587
00:23:49,980 --> 00:23:52,720
starting with only 5% turned
out to be a really good

588
00:23:52,720 --> 00:23:54,920
constraint for us.

589
00:23:54,920 --> 00:23:58,970
It forced us to reduce the CPU
footprint of the audio system.

590
00:23:58,970 --> 00:24:00,420
RAPH LEVIEN: Keep that number
in mind for later.

591
00:24:00,420 --> 00:24:02,590
For now, it's important to
understand that SCHED FIFO

592
00:24:02,590 --> 00:24:05,120
priority only applies to threads
that are created by

593
00:24:05,120 --> 00:24:05,885
the audio system.

594
00:24:05,885 --> 00:24:08,150
You can't do it for
your own threads.

595
00:24:08,150 --> 00:24:10,200
So that means if you want the
lowest latency, you need to

596
00:24:10,200 --> 00:24:13,490
run your audio code on
an audio thread.

597
00:24:13,490 --> 00:24:15,920
In practice, that means you need
to do your processing in

598
00:24:15,920 --> 00:24:17,450
a buffer callback.

599
00:24:17,450 --> 00:24:19,590
That means writing your
sound engine in C++

600
00:24:19,590 --> 00:24:21,900
and using Open SLES.

601
00:24:21,900 --> 00:24:24,320
And of course, not doing your
engine in Java means you don't

602
00:24:24,320 --> 00:24:26,880
have to worry about pauses from
the Garbage Collector.

603
00:24:26,880 --> 00:24:28,650
GLENN KASTEN: But you are still
subject to the audio

604
00:24:28,650 --> 00:24:30,130
Cgroup budget.

605
00:24:30,130 --> 00:24:32,360
We'll discuss budgets
later on.

606
00:24:32,360 --> 00:24:34,590
But first, Raph, show us
some more numbers.

607
00:24:34,590 --> 00:24:35,180
RAPH LEVIEN: Sure.

608
00:24:35,180 --> 00:24:38,500
Let's see how well that change
to SCHED FIFO worked.

609
00:24:38,500 --> 00:24:39,830
This is a little misleading.

610
00:24:39,830 --> 00:24:44,300
But the build I measured
contains some other fixes

611
00:24:44,300 --> 00:24:45,180
besides SCHED FIFO.

612
00:24:45,180 --> 00:24:47,510
But it's essentially accurate.

613
00:24:47,510 --> 00:24:50,000
You can see that where Ice Cream
Sandwich jitter was all

614
00:24:50,000 --> 00:24:52,510
over the place, on Jelly Bean,
it's clumped in a tight band

615
00:24:52,510 --> 00:24:53,440
right around zero.

616
00:24:53,440 --> 00:24:55,340
The problem is solved.

617
00:24:55,340 --> 00:24:57,450
GLENN KASTEN: Woo-hoo!

618
00:24:57,450 --> 00:24:59,200
Well, not so fast.

619
00:24:59,200 --> 00:25:01,960
Remember that in order to get
that reduction in jitter, we

620
00:25:01,960 --> 00:25:05,100
had agreed to a really tight
budget for audio, at the time

621
00:25:05,100 --> 00:25:07,970
only 5% of the CPU.

622
00:25:07,970 --> 00:25:11,090
Unfortunately, when I profiled
the audio subsystem, on some

623
00:25:11,090 --> 00:25:14,750
devices, it took longer than
5% just to run our mixer or

624
00:25:14,750 --> 00:25:17,460
our sample reconverter
and audio effects,

625
00:25:17,460 --> 00:25:19,470
like reverb and EQ.

626
00:25:19,470 --> 00:25:22,810
And it looked like I had a
massive optimization task in

627
00:25:22,810 --> 00:25:26,970
front of me, because we had that
5% for his application.

628
00:25:26,970 --> 00:25:29,020
RAPH LEVIEN: And to be fair,
that subsystem is doing a lot

629
00:25:29,020 --> 00:25:30,790
of work, especially if effects
are turned on.

630
00:25:30,790 --> 00:25:33,040
What was frustrating to
me is that it was work

631
00:25:33,040 --> 00:25:34,290
that I didn't want.

632
00:25:34,290 --> 00:25:36,820
I'm not dependent on any
one sample rate.

633
00:25:36,820 --> 00:25:38,640
I can do my own mixing.

634
00:25:38,640 --> 00:25:41,270
And I spent weeks with a signal
analyzer determining

635
00:25:41,270 --> 00:25:45,995
the exact physical properties of
that synthesizer's digital

636
00:25:45,995 --> 00:25:49,150
to analog converter hardware to
build a precise emulation.

637
00:25:49,150 --> 00:25:51,070
I didn't want to add any
one size fits all

638
00:25:51,070 --> 00:25:53,840
effects on top of that.

639
00:25:53,840 --> 00:25:56,140
GLENN KASTEN: My big aha moment
was when I realized

640
00:25:56,140 --> 00:25:59,950
that pretty much every audio
developer feels the same way,

641
00:25:59,950 --> 00:26:01,910
every developer who's interested
in low latency

642
00:26:01,910 --> 00:26:03,810
audio, anyway.

643
00:26:03,810 --> 00:26:07,700
So instead of trying to optimize
our system audio

644
00:26:07,700 --> 00:26:09,670
path, I just bypassed it.

645
00:26:09,670 --> 00:26:11,350
And I call this the fast path.

646
00:26:11,350 --> 00:26:12,902
Here's how it works.

647
00:26:12,902 --> 00:26:15,620
The top section basically
is running

648
00:26:15,620 --> 00:26:17,760
under the old CFS scheduler.

649
00:26:17,760 --> 00:26:21,520
That includes our normal mixer,
normal track switch,

650
00:26:21,520 --> 00:26:24,230
support resampling, they support
mixing, they support

651
00:26:24,230 --> 00:26:26,220
effects, things like that.

652
00:26:26,220 --> 00:26:27,830
The bottom is the fast path.

653
00:26:27,830 --> 00:26:31,470
And here, the low latency
applications send their audio

654
00:26:31,470 --> 00:26:36,470
directly into the fast mixer,
which then drive the hardware

655
00:26:36,470 --> 00:26:37,870
abstraction layer.

656
00:26:37,870 --> 00:26:41,940
And they all run under the
SCHED FIFO policy.

657
00:26:41,940 --> 00:26:43,100
RAPH LEVIEN: And they're
limited to the

658
00:26:43,100 --> 00:26:45,300
audio budget of 5%.

659
00:26:45,300 --> 00:26:47,460
GLENN KASTEN: Yeah, 5%.

660
00:26:47,460 --> 00:26:49,630
We're actually able to negotiate
that up a little bit

661
00:26:49,630 --> 00:26:52,820
later, but there still
is a budget.

662
00:26:52,820 --> 00:26:55,150
Now remember, earlier we were
talking about power.

663
00:26:55,150 --> 00:26:59,580
And one of the reasons why
buffers were so big was to

664
00:26:59,580 --> 00:27:02,490
reduce the CPU wake
up frequency.

665
00:27:02,490 --> 00:27:06,520
So when we used the low latency
path, it does increase

666
00:27:06,520 --> 00:27:07,700
power consumption.

667
00:27:07,700 --> 00:27:10,590
Fortunately, one of our audio
engineers, our audio tech

668
00:27:10,590 --> 00:27:14,880
lead, Eric, added another
feature called the Deep Buffer

669
00:27:14,880 --> 00:27:17,980
Path, which is used, for
example, music playback when

670
00:27:17,980 --> 00:27:19,640
your phone is in your pocket.

671
00:27:19,640 --> 00:27:23,070
And that is recommended when
you're trying to conserve

672
00:27:23,070 --> 00:27:25,750
power instead of latency.

673
00:27:25,750 --> 00:27:27,680
RAPH LEVIEN: So at this point
in time, I'd been following

674
00:27:27,680 --> 00:27:30,220
Glenn's work pretty closely, I
was very excited to try out

675
00:27:30,220 --> 00:27:31,260
this new fast path.

676
00:27:31,260 --> 00:27:34,050
I had just gotten a shiny new
Nexus 4, so I flashed a build

677
00:27:34,050 --> 00:27:36,550
onto my device, loaded
up my synthesizer,

678
00:27:36,550 --> 00:27:39,650
and nothing, no change.

679
00:27:39,650 --> 00:27:40,970
GLENN KASTEN: No change?

680
00:27:40,970 --> 00:27:42,520
RAPH LEVIEN: Well,
almost no change.

681
00:27:42,520 --> 00:27:45,310
There was some reduction in
latency, but nowhere nearly as

682
00:27:45,310 --> 00:27:46,520
much as I would have liked.

683
00:27:46,520 --> 00:27:49,200
Keep in mind, I'd already made
all of the obvious changes.

684
00:27:49,200 --> 00:27:51,650
I had rewritten my synthesis
engine in C++.

685
00:27:51,650 --> 00:27:54,800
I was running in the open SL
callback, so my code would run

686
00:27:54,800 --> 00:27:56,820
at that same high priority
scheduling.

687
00:27:56,820 --> 00:27:59,410
The obvious conclusion was
that my app was to blame.

688
00:27:59,410 --> 00:28:01,050
So I started profiling.

689
00:28:01,050 --> 00:28:02,680
What I found surprised
me a little bit.

690
00:28:02,680 --> 00:28:05,240
When I looked at my jitter
measurements in the new build,

691
00:28:05,240 --> 00:28:06,930
they were terrible.

692
00:28:06,930 --> 00:28:09,590
I knew Glenn had measured much
better jitter than this in his

693
00:28:09,590 --> 00:28:11,620
build, so I asked him
what was going on.

694
00:28:11,620 --> 00:28:14,080
GLENN KASTEN: I was really
stumped too until I asked Raph

695
00:28:14,080 --> 00:28:16,690
was sample rate he was using,
and he said 44.1, which is

696
00:28:16,690 --> 00:28:20,300
what was used on the Nexus
7 and the Galaxy Nexus.

697
00:28:20,300 --> 00:28:24,670
But it turns out the Nexus 4
runs natively at 48 kilohertz.

698
00:28:24,670 --> 00:28:26,750
RAPH LEVIEN: So my buffers
had to go through

699
00:28:26,750 --> 00:28:27,840
the sample rate converter.

700
00:28:27,840 --> 00:28:32,150
And the sample rate converter
is not on the fast path.

701
00:28:32,150 --> 00:28:35,200
Here's another plot that
shows a related issue.

702
00:28:35,200 --> 00:28:36,750
This isn't as bad as
the first one.

703
00:28:36,750 --> 00:28:38,580
There's only about a five
millisecond variation

704
00:28:38,580 --> 00:28:39,490
in start time here.

705
00:28:39,490 --> 00:28:40,930
But there's something
weird about it.

706
00:28:40,930 --> 00:28:42,980
The stripes in the data make me
think I'm looking at some

707
00:28:42,980 --> 00:28:45,290
kind of periodic process,
not just random noise.

708
00:28:45,290 --> 00:28:48,460
Let's zoom in and see if
we can find a pattern.

709
00:28:48,460 --> 00:28:50,395
GLENN KASTEN: Yeah, that looks
like a pattern to me.

710
00:28:50,395 --> 00:28:52,050
RAPH LEVIEN: It's
pretty regular.

711
00:28:52,050 --> 00:28:55,190
Looks like every 16 buffers,
I get my callback late.

712
00:28:55,190 --> 00:28:57,390
It turns out this was because
of another assumption I had

713
00:28:57,390 --> 00:29:00,160
made that didn't hold
true on the Nexus 4.

714
00:29:00,160 --> 00:29:02,550
I had set my buffer size
to 256, which was

715
00:29:02,550 --> 00:29:03,720
a convenient size.

716
00:29:03,720 --> 00:29:06,150
GLENN KASTEN: What Raph didn't
know at the time was that on

717
00:29:06,150 --> 00:29:11,030
the Nexus 4, our native buffer
size was 240 frames, not 256.

718
00:29:11,030 --> 00:29:14,730
And the greatest common divisor
of those two is--

719
00:29:14,730 --> 00:29:17,380
RAPH LEVIEN: 16.

720
00:29:17,380 --> 00:29:20,090
So that's the next item on your
to do list-- adapt your

721
00:29:20,090 --> 00:29:22,390
buffer size and sample
rate to match what

722
00:29:22,390 --> 00:29:23,530
the system is using.

723
00:29:23,530 --> 00:29:25,100
But how do you know what
buffer size and

724
00:29:25,100 --> 00:29:28,520
sample rate to use?

725
00:29:28,520 --> 00:29:30,280
This is something--
next slide--

726
00:29:30,280 --> 00:29:32,900
this is something that not
only is there variation

727
00:29:32,900 --> 00:29:35,040
between devices, but
it can change even

728
00:29:35,040 --> 00:29:36,980
across Android versions.

729
00:29:36,980 --> 00:29:39,780
In the early days, I struggled
with this a lot.

730
00:29:39,780 --> 00:29:42,670
GLENN KASTEN: I asked Raph what
does he want in the next

731
00:29:42,670 --> 00:29:45,310
version of the Android
audio platform to

732
00:29:45,310 --> 00:29:46,230
better support apps.

733
00:29:46,230 --> 00:29:49,120
And the top of this list was an
API to return this kind of

734
00:29:49,120 --> 00:29:49,760
information--

735
00:29:49,760 --> 00:29:52,880
native buffer size, native
sample rate.

736
00:29:52,880 --> 00:29:55,380
And that shift in
API level 17--

737
00:29:55,380 --> 00:29:57,740
we'll give you a link
to how to do that at

738
00:29:57,740 --> 00:29:59,440
the end of this talk.

739
00:29:59,440 --> 00:30:01,440
RAPH LEVIEN: Here's a snippet
from my app showing how I use

740
00:30:01,440 --> 00:30:03,835
a new sample rate and buffer
size properties to set up my

741
00:30:03,835 --> 00:30:04,835
synth engine.

742
00:30:04,835 --> 00:30:07,350
After I hooked it up, I found
that my synth went from eight

743
00:30:07,350 --> 00:30:08,980
voices to 20.

744
00:30:08,980 --> 00:30:11,870
Finally, I was beating the
30-year-old synthesizer I was

745
00:30:11,870 --> 00:30:14,190
trying to emulate.

746
00:30:14,190 --> 00:30:17,210
Now, let's take a look at an
audible glitch that was really

747
00:30:17,210 --> 00:30:18,470
difficult to track down.

748
00:30:18,470 --> 00:30:19,970
GLENN KASTEN: You're going to
want to pay special attention

749
00:30:19,970 --> 00:30:22,490
to this, because even though
we are going to be using

750
00:30:22,490 --> 00:30:25,460
Raph's code as an example here
today, we've seen similar

751
00:30:25,460 --> 00:30:30,080
issues to this throughout the
audio platform and in other

752
00:30:30,080 --> 00:30:31,470
applications.

753
00:30:31,470 --> 00:30:34,050
And it's really hard
to track down.

754
00:30:34,050 --> 00:30:36,190
RAPH LEVIEN: Here's a plot
of the bug in action.

755
00:30:36,190 --> 00:30:38,380
What you're seeing is the start
and end times of each

756
00:30:38,380 --> 00:30:39,300
buffer callback.

757
00:30:39,300 --> 00:30:41,280
Start time is blue, the
end time is red.

758
00:30:41,280 --> 00:30:44,420
Most of the time the start and
end times are so close that

759
00:30:44,420 --> 00:30:46,020
you almost can't tell
them apart.

760
00:30:46,020 --> 00:30:47,320
What's happening at the
beginning here?

761
00:30:47,320 --> 00:30:49,430
Let's zoom in and
check it out.

762
00:30:49,430 --> 00:30:50,360
Here's a closer look.

763
00:30:50,360 --> 00:30:52,810
The callback started
right on time.

764
00:30:52,810 --> 00:30:55,140
But the end time is
way out there.

765
00:30:55,140 --> 00:30:58,120
It looks like the callback
took about 16

766
00:30:58,120 --> 00:31:00,030
milliseconds to process.

767
00:31:00,030 --> 00:31:02,360
That was enough to cause a
dropout and skip a couple of

768
00:31:02,360 --> 00:31:04,540
buffers, which is what all of
the subsequent callbacks that

769
00:31:04,540 --> 00:31:07,520
recorded is showing up
10 milliseconds late.

770
00:31:07,520 --> 00:31:08,440
GLENN KASTEN: This time
I didn't have an

771
00:31:08,440 --> 00:31:09,600
easy answer for Raph.

772
00:31:09,600 --> 00:31:12,770
But we did have a new tool for
investigating performance

773
00:31:12,770 --> 00:31:14,210
problems, sys trace.

774
00:31:14,210 --> 00:31:15,880
And I know that that
would be good for

775
00:31:15,880 --> 00:31:19,500
investigating this problem.

776
00:31:19,500 --> 00:31:22,430
Sys trace basically collects the
same kind of data that I'd

777
00:31:22,430 --> 00:31:25,000
been collecting with
my manual home brew

778
00:31:25,000 --> 00:31:26,310
context switch recorder.

779
00:31:26,310 --> 00:31:29,050
But it's much easier to use and
has a really attractive

780
00:31:29,050 --> 00:31:30,300
user interface.

781
00:31:30,300 --> 00:31:32,650

782
00:31:32,650 --> 00:31:35,330
We're going to show you a sys
trace first of some good audio

783
00:31:35,330 --> 00:31:37,980
playback and then
a bad sys trace.

784
00:31:37,980 --> 00:31:39,660
First, here's a sys
trace of audio

785
00:31:39,660 --> 00:31:41,430
playback working correctly.

786
00:31:41,430 --> 00:31:43,960
You're going to see every five
milliseconds the fast mixer

787
00:31:43,960 --> 00:31:47,980
thread is the one in red.

788
00:31:47,980 --> 00:31:50,320
It writes out a buffer of audio
to the hardware, then it

789
00:31:50,320 --> 00:31:52,480
wakes up the audio track
thread, which

790
00:31:52,480 --> 00:31:53,360
is part of the client.

791
00:31:53,360 --> 00:31:56,770
And that's the one in green,
which is actually part of your

792
00:31:56,770 --> 00:31:58,060
application.

793
00:31:58,060 --> 00:31:59,800
And that's the thread that's
generating the

794
00:31:59,800 --> 00:32:01,070
next buffer of audio.

795
00:32:01,070 --> 00:32:04,110
Then that computes beautiful
FM sounds for a couple

796
00:32:04,110 --> 00:32:06,810
milliseconds and queues
its buffer, which

797
00:32:06,810 --> 00:32:07,720
goes to the fast mixer.

798
00:32:07,720 --> 00:32:11,050
And then it goes back to sleep
for the next callback.

799
00:32:11,050 --> 00:32:12,810
RAPH LEVIEN: So around
here, we see

800
00:32:12,810 --> 00:32:13,655
something else happening.

801
00:32:13,655 --> 00:32:16,090
The UI thread of the
synthesizer, which is purple,

802
00:32:16,090 --> 00:32:17,750
wakes up and starts computing.

803
00:32:17,750 --> 00:32:19,830
But both the fast mixer and the
audio track threads are

804
00:32:19,830 --> 00:32:20,650
higher priorities.

805
00:32:20,650 --> 00:32:24,080
So when it's time for them
to wake up, the scheduler

806
00:32:24,080 --> 00:32:26,740
suspends the UI thread and lets
the high priority audio

807
00:32:26,740 --> 00:32:27,610
threads run.

808
00:32:27,610 --> 00:32:28,540
So that's good.

809
00:32:28,540 --> 00:32:31,060
No audible glitch here.

810
00:32:31,060 --> 00:32:32,740
GLENN KASTEN: But something
still looks a

811
00:32:32,740 --> 00:32:33,850
little funny here.

812
00:32:33,850 --> 00:32:38,660
The audio track thread looks
like it's been split in two.

813
00:32:38,660 --> 00:32:41,250
Zooming in, we see our UI thread
being scheduled, even

814
00:32:41,250 --> 00:32:43,560
though the audio thread should
be higher priority.

815
00:32:43,560 --> 00:32:45,060
What's going on?

816
00:32:45,060 --> 00:32:46,720
RAPH LEVIEN: Turns out that
when that thread went to

817
00:32:46,720 --> 00:32:49,780
sleep, it was holding a mutex
belonging to the allocator.

818
00:32:49,780 --> 00:32:52,470
Then when the audio callback
went to allocate some memory,

819
00:32:52,470 --> 00:32:54,820
it tried to take the
mutex and blocked.

820
00:32:54,820 --> 00:32:57,030
The only other thread to
run is the UI thread.

821
00:32:57,030 --> 00:32:58,520
So the scheduler wakes it up.

822
00:32:58,520 --> 00:32:59,480
Then it releases the mutex.

823
00:32:59,480 --> 00:33:02,260
And boom-- the audio thread
is runnable again.

824
00:33:02,260 --> 00:33:05,090
It's higher priority, so the
scheduler bumps the UI thread

825
00:33:05,090 --> 00:33:07,330
and lets the audio thread
run to completion.

826
00:33:07,330 --> 00:33:09,120
And we get our buffer
to the mixer with

827
00:33:09,120 --> 00:33:10,530
plenty of time to spare.

828
00:33:10,530 --> 00:33:13,160
This time we were lucky.

829
00:33:13,160 --> 00:33:13,920
GLENN KASTEN: This time.

830
00:33:13,920 --> 00:33:15,480
This wasn't our audible
glitch.

831
00:33:15,480 --> 00:33:16,960
But let's keep looking.

832
00:33:16,960 --> 00:33:19,740
So to help us out, I added a new
sys trace counter for us

833
00:33:19,740 --> 00:33:22,310
for audio called f ready, which
basically is the number

834
00:33:22,310 --> 00:33:24,450
of frames that the application
is providing

835
00:33:24,450 --> 00:33:25,740
to the audio mixer.

836
00:33:25,740 --> 00:33:29,380
You want that to always be
high, high enough for the

837
00:33:29,380 --> 00:33:31,780
mixture to be able to read
the next data from the

838
00:33:31,780 --> 00:33:32,500
application.

839
00:33:32,500 --> 00:33:34,910
And as you can see, most of the
time it's 480, which is

840
00:33:34,910 --> 00:33:37,110
two buffers worth.

841
00:33:37,110 --> 00:33:40,430
But around 1.1 seconds into the
sys trace, we can see it

842
00:33:40,430 --> 00:33:41,760
dropping down to zero.

843
00:33:41,760 --> 00:33:43,620
That's definitely going
to cause a glitch--

844
00:33:43,620 --> 00:33:44,700
no question.

845
00:33:44,700 --> 00:33:47,740
Sys traces is a great tool
for finding these kind of

846
00:33:47,740 --> 00:33:48,670
performance problems.

847
00:33:48,670 --> 00:33:53,790
It's much easier to see them
than to listen for them.

848
00:33:53,790 --> 00:33:55,810
So we have a glitch.

849
00:33:55,810 --> 00:33:57,200
Let's zoom in and see
if we can figure out

850
00:33:57,200 --> 00:33:59,580
exactly what's happening.

851
00:33:59,580 --> 00:34:01,690
At the arrow here, our
user interface

852
00:34:01,690 --> 00:34:03,600
thread, UI, stop running.

853
00:34:03,600 --> 00:34:06,440
And it turns out it's holding
a mutex for a memory

854
00:34:06,440 --> 00:34:07,530
allocation.

855
00:34:07,530 --> 00:34:09,420
Then a whole bunch of
other stuff runs.

856
00:34:09,420 --> 00:34:12,489
And it looks like
UEventObserver--

857
00:34:12,489 --> 00:34:14,370
then the usual.

858
00:34:14,370 --> 00:34:17,100
Fast mixer wakes up.

859
00:34:17,100 --> 00:34:19,219
That wakes up audio track.

860
00:34:19,219 --> 00:34:21,510
But at the arrow, the
audio track tries to

861
00:34:21,510 --> 00:34:22,940
allocate some memory.

862
00:34:22,940 --> 00:34:24,510
And that's going to block.

863
00:34:24,510 --> 00:34:26,300
The UI thread was holding
the mutex

864
00:34:26,300 --> 00:34:28,330
for the memory allocator.

865
00:34:28,330 --> 00:34:30,280
RAPH LEVIEN: Remember the last
time this happened, the UI

866
00:34:30,280 --> 00:34:31,929
thread was the only thing
ready to run.

867
00:34:31,929 --> 00:34:34,440
That's why we were so lucky
there was nothing else for the

868
00:34:34,440 --> 00:34:35,330
kernel to schedule.

869
00:34:35,330 --> 00:34:38,320
So the UI thread did its 30
microseconds worth of work and

870
00:34:38,320 --> 00:34:39,229
unblocked this.

871
00:34:39,229 --> 00:34:41,960
This time, we're not nearly as
lucky, because there's tons of

872
00:34:41,960 --> 00:34:44,010
other threads that want to run,
and the scheduler isn't

873
00:34:44,010 --> 00:34:46,679
smart enough to realize that it
needs to run the UI thread

874
00:34:46,679 --> 00:34:49,510
in order to unblock
the audio thread.

875
00:34:49,510 --> 00:34:52,530
The fast mixer keeps waking up,
but every time it does,

876
00:34:52,530 --> 00:34:53,219
there's no audio.

877
00:34:53,219 --> 00:34:54,040
We were blocked.

878
00:34:54,040 --> 00:34:57,440
So f radio runs out, and
we hear a glitch.

879
00:34:57,440 --> 00:35:00,440
It isn't until 1141 milliseconds
in this trace

880
00:35:00,440 --> 00:35:03,150
that the UI thread finally gets
scheduled again, then

881
00:35:03,150 --> 00:35:06,130
releases a mutex and the
callback can run.

882
00:35:06,130 --> 00:35:08,710
GLENN KASTEN: So this is known
as classic priority inversion.

883
00:35:08,710 --> 00:35:10,610
Basically, it means that a high
priority thread is being

884
00:35:10,610 --> 00:35:13,370
blocked by a lower priority
thread that's holding a

885
00:35:13,370 --> 00:35:16,240
resource, such as a mutex.

886
00:35:16,240 --> 00:35:19,170
And some operating systems have
special logic, especially

887
00:35:19,170 --> 00:35:21,520
in their mutexes, to
handle this case.

888
00:35:21,520 --> 00:35:23,980
But Android is not using
that feature.

889
00:35:23,980 --> 00:35:24,800
RAPH LEVIEN: Here's
the funny thing.

890
00:35:24,800 --> 00:35:26,460
I know about priority
inversions.

891
00:35:26,460 --> 00:35:27,790
I wrote my code very
carefully.

892
00:35:27,790 --> 00:35:30,510
I didn't take any mutexes, or
allocate any memory-- anything

893
00:35:30,510 --> 00:35:31,410
they could block.

894
00:35:31,410 --> 00:35:33,830
Yet the sys trace clearly showed
that the thread was

895
00:35:33,830 --> 00:35:35,430
blocking on the mutex.

896
00:35:35,430 --> 00:35:38,800
Tracing further, I found that
the sprintf call I was using

897
00:35:38,800 --> 00:35:41,340
to generate a log line
was blocking.

898
00:35:41,340 --> 00:35:42,900
GLENN KASTEN: Sprintf
of all things.

899
00:35:42,900 --> 00:35:46,430

900
00:35:46,430 --> 00:35:49,150
So turns out I ran into a
similar issue when I was

901
00:35:49,150 --> 00:35:51,440
working on the audio
fast path.

902
00:35:51,440 --> 00:35:55,030
I had a thread that was calling
into another server by

903
00:35:55,030 --> 00:35:58,310
IPC, inter-process
communication, via binder.

904
00:35:58,310 --> 00:36:01,990
And I knew about classic mutex
priority inversion.

905
00:36:01,990 --> 00:36:03,030
It's a well known issue.

906
00:36:03,030 --> 00:36:06,266
But I didn't think about
the risks of IPC.

907
00:36:06,266 --> 00:36:07,590
RAPH LEVIEN: There are
a bunch of ways to

908
00:36:07,590 --> 00:36:08,590
deal with this problem.

909
00:36:08,590 --> 00:36:10,330
But for this kind of thing,
the simplest is to use

910
00:36:10,330 --> 00:36:11,780
non-blocking techniques.

911
00:36:11,780 --> 00:36:14,110
Don't ever take a mutex on
the audio callback either

912
00:36:14,110 --> 00:36:17,290
explicitly or implicitly through
things like memory

913
00:36:17,290 --> 00:36:19,030
allocation.

914
00:36:19,030 --> 00:36:22,720
GLENN KASTEN: One really simple
among the non-blocking

915
00:36:22,720 --> 00:36:27,040
techniques is, way of avoiding
blocking, is single reader,

916
00:36:27,040 --> 00:36:28,630
single writer ring buffers.

917
00:36:28,630 --> 00:36:29,840
It's really easy to write.

918
00:36:29,840 --> 00:36:32,380
It's simple to understand, and
it works really well for

919
00:36:32,380 --> 00:36:34,290
shuttling either small
or large amounts of

920
00:36:34,290 --> 00:36:35,710
data between threads.

921
00:36:35,710 --> 00:36:38,540
It's commonly used in audio
applications for this reason.

922
00:36:38,540 --> 00:36:40,105
RAPH LEVIEN: Here's how
I used it in my app.

923
00:36:40,105 --> 00:36:43,010
A Java app puts its MIDI bytes
into the ring buffer.

924
00:36:43,010 --> 00:36:45,610
Then the C++ takes
the bytes out.

925
00:36:45,610 --> 00:36:48,100
Checking how many bytes are
available and reading them can

926
00:36:48,100 --> 00:36:49,890
both be done without blocking.

927
00:36:49,890 --> 00:36:52,210
If you weren't in a soft real
time context, you'd probably

928
00:36:52,210 --> 00:36:54,100
use a mutex for this instead.

929
00:36:54,100 --> 00:36:56,590
Do keep in mind, though, that
you still need to use memory

930
00:36:56,590 --> 00:36:59,460
barriers because ARM has a
weekly ordered memory model.

931
00:36:59,460 --> 00:37:02,060
X86 has a total store order,
so if you've implemented a

932
00:37:02,060 --> 00:37:03,530
ring buffer there, you
may not be aware

933
00:37:03,530 --> 00:37:05,440
you need these barriers.

934
00:37:05,440 --> 00:37:06,670
If none of this makes sense
to you, just use

935
00:37:06,670 --> 00:37:08,660
existing correct code.

936
00:37:08,660 --> 00:37:11,150
GLENN KASTEN: And definitely
don't call sprintf.

937
00:37:11,150 --> 00:37:13,330
So let's see what your new graph
looks like now that you

938
00:37:13,330 --> 00:37:14,945
fixed your priority inversion.

939
00:37:14,945 --> 00:37:15,210
RAPH LEVIEN: You bet.

940
00:37:15,210 --> 00:37:16,260
Here it is.

941
00:37:16,260 --> 00:37:18,670
And here it is contracted
for drift.

942
00:37:18,670 --> 00:37:19,640
Now, it's looking clean.

943
00:37:19,640 --> 00:37:21,080
The outliers are gone.

944
00:37:21,080 --> 00:37:23,260
All of the code is strictly
non-blocking.

945
00:37:23,260 --> 00:37:25,210
You do see some weird little
ups and down because of the

946
00:37:25,210 --> 00:37:27,380
power management system changing
the clock frequency,

947
00:37:27,380 --> 00:37:29,310
but that's OK.

948
00:37:29,310 --> 00:37:30,870
Even at the lowest clock
frequency, everything is

949
00:37:30,870 --> 00:37:32,600
happening under two
milliseconds, which is

950
00:37:32,600 --> 00:37:33,870
properly quick.

951
00:37:33,870 --> 00:37:35,850
This might not seem like it
looks better than the previous

952
00:37:35,850 --> 00:37:38,110
plot, but take a look
at the scale.

953
00:37:38,110 --> 00:37:40,700
GLENN KASTEN: That's
a one and a two.

954
00:37:40,700 --> 00:37:42,380
The start times are all
clustered together

955
00:37:42,380 --> 00:37:43,560
the way we like them.

956
00:37:43,560 --> 00:37:46,100
But the end times are still
a little bit weird.

957
00:37:46,100 --> 00:37:48,130
It looks like there's
two bands.

958
00:37:48,130 --> 00:37:48,790
What's going on there?

959
00:37:48,790 --> 00:37:50,510
RAPH LEVIEN: My synth was
doing its computation in

960
00:37:50,510 --> 00:37:53,230
blocks of 64 samples because
it's convenient.

961
00:37:53,230 --> 00:37:55,290
Lots of other libraries
do that too.

962
00:37:55,290 --> 00:37:58,450
Remember, the Nexus 4 buffer
is 240 samples long.

963
00:37:58,450 --> 00:38:02,185
So sometimes we'd compute
256, other times, 192.

964
00:38:02,185 --> 00:38:04,000
That variation explains
the two bands.

965
00:38:04,000 --> 00:38:06,210
This is a nice optimization,
and it took my synth from

966
00:38:06,210 --> 00:38:09,510
about 20 to 30 voices
of polyphony.

967
00:38:09,510 --> 00:38:12,240
After this, I took it the rest
of the way with some old

968
00:38:12,240 --> 00:38:15,110
fashioned cache optimization
and SIMD magic.

969
00:38:15,110 --> 00:38:17,510
So now it's up to 64 voices.

970
00:38:17,510 --> 00:38:20,140
Between Glenn's work on the
system and my optimizations in

971
00:38:20,140 --> 00:38:21,775
this synth engine, my
DX7 app is starting

972
00:38:21,775 --> 00:38:23,160
to look pretty good.

973
00:38:23,160 --> 00:38:27,700
GLENN KASTEN: This is where
things stand for some devices.

974
00:38:27,700 --> 00:38:28,340
That's right.

975
00:38:28,340 --> 00:38:31,080
You knew there had to be a
catch, because as soon as we

976
00:38:31,080 --> 00:38:34,430
started testing this design on
a wider variety of devices,

977
00:38:34,430 --> 00:38:36,615
things started to get
more complicated.

978
00:38:36,615 --> 00:38:38,220
RAPH LEVIEN: The core
of what Glenn did is

979
00:38:38,220 --> 00:38:39,310
valid on every device.

980
00:38:39,310 --> 00:38:42,340
But each device has its own set
of bugs-- power management

981
00:38:42,340 --> 00:38:45,210
issues, driver bugs, or
scheduling snafus.

982
00:38:45,210 --> 00:38:47,700
And each one of those has to
be solved individually.

983
00:38:47,700 --> 00:38:49,510
GLENN KASTEN: If you want to,
catch me during office hours.

984
00:38:49,510 --> 00:38:52,070
I'll tell you some
war stories.

985
00:38:52,070 --> 00:38:55,560
So that's the last thing on my
to do list is to work with our

986
00:38:55,560 --> 00:38:58,440
hardware partners to track down
these crazy kernel driver

987
00:38:58,440 --> 00:39:01,810
and hardware issues that can
affect audio performance.

988
00:39:01,810 --> 00:39:02,750
I'm committed to it.

989
00:39:02,750 --> 00:39:04,070
We're committed to it.

990
00:39:04,070 --> 00:39:05,470
But we're not there yet.

991
00:39:05,470 --> 00:39:07,410
RAPH LEVIEN: But we are moving
in the right direction.

992
00:39:07,410 --> 00:39:09,060
GLENN KASTEN: Yes we are.

993
00:39:09,060 --> 00:39:11,420
RAPH LEVIEN: If you have some
questions or would like to see

994
00:39:11,420 --> 00:39:14,550
more data, come see us in the
Android office hours area

995
00:39:14,550 --> 00:39:15,800
right after this presentation.

996
00:39:15,800 --> 00:39:18,690

997
00:39:18,690 --> 00:39:22,680
GLENN KASTEN: We put together a
website for all of you with

998
00:39:22,680 --> 00:39:25,480
a lot of good audio performance
resources.

999
00:39:25,480 --> 00:39:28,360
So this QR code has a short link
to it, and there's also

1000
00:39:28,360 --> 00:39:31,340
the long link there
if you prefer--

1001
00:39:31,340 --> 00:39:32,590
codegoogle.com/p
/high-performance-audio.

1002
00:39:32,590 --> 00:39:35,470

1003
00:39:35,470 --> 00:39:36,940
Lots and lots of resources
there.

1004
00:39:36,940 --> 00:39:39,860
And we do plan on continuing
to keep that website up to

1005
00:39:39,860 --> 00:39:43,120
date with more things as
we come across some.

1006
00:39:43,120 --> 00:39:45,144
So thank you all for coming.

1007
00:39:45,144 --> 00:39:50,760
[APPLAUSE]

1008
00:39:50,760 --> 00:39:54,010
GLENN KASTEN: And again, please
fill the review forms.

1009
00:39:54,010 --> 00:39:56,920
And let's talk at
office hours.

1010
00:39:56,920 --> 00:39:57,520
RAPH LEVIEN: See you there.

1011
00:39:57,520 --> 00:39:58,770
Thank you.

1012
00:39:58,770 --> 00:40:02,917

