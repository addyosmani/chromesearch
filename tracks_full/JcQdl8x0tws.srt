1
00:00:00,000 --> 00:00:30,360

2
00:00:30,360 --> 00:00:32,759
PETE LEPAGE: Welcome, everybody,
to another edition

3
00:00:32,759 --> 00:00:36,080
of our "Chrome Apps Office
Hours." We've got a really

4
00:00:36,080 --> 00:00:39,870
great show today with a special
guest joining us from

5
00:00:39,870 --> 00:00:40,890
Mountain View.

6
00:00:40,890 --> 00:00:43,980
John McCutchan is going to be
talking about using Native

7
00:00:43,980 --> 00:00:48,840
Client and Acceleration Modules
within Chrome Apps.

8
00:00:48,840 --> 00:00:51,560
So really allowing you to take
a whole bunch of the stuff

9
00:00:51,560 --> 00:00:54,510
that you're used to being able
to do with Native Client and

10
00:00:54,510 --> 00:00:56,860
put that into a Chrome app.

11
00:00:56,860 --> 00:00:58,810
So, with that, John, I'll
turn it over to you.

12
00:00:58,810 --> 00:01:01,800
I'll let you introduce yourself
and talk about Chrome

13
00:01:01,800 --> 00:01:03,736
Apps a little bit.

14
00:01:03,736 --> 00:01:04,769
JOHN MCCUTCHAN: Hey, everyone.

15
00:01:04,769 --> 00:01:08,350
I'm John McCutchan, and I work
on the Native Client team as a

16
00:01:08,350 --> 00:01:10,230
developer programs engineer.

17
00:01:10,230 --> 00:01:12,640
And today I'm going to talk
about how you can really

18
00:01:12,640 --> 00:01:16,490
accelerate the performance
inside your Chrome Apps.

19
00:01:16,490 --> 00:01:20,960
So what are Chrome
Packaged Apps?

20
00:01:20,960 --> 00:01:24,120
I've taken this text snippet
here straight off of the

21
00:01:24,120 --> 00:01:25,640
Chrome Apps developer website.

22
00:01:25,640 --> 00:01:28,280
And it says that "Chrome apps
deliver an experience as

23
00:01:28,280 --> 00:01:31,830
capable as a native app but
as safe as a web page.

24
00:01:31,830 --> 00:01:35,680
They're built with open web
technologies, like HTML5,

25
00:01:35,680 --> 00:01:37,910
JavaScript, and CSS.

26
00:01:37,910 --> 00:01:42,180
But they look and behave
like native apps.

27
00:01:42,180 --> 00:01:44,320
And they also have native-like
capabilities." And in the

28
00:01:44,320 --> 00:01:47,060
lower right hand corner of the
slide, you can see a screen

29
00:01:47,060 --> 00:01:50,860
shot of a Chrome Packaged App,
which is launching from the

30
00:01:50,860 --> 00:01:55,390
Start menu, and looks and feels
just like a native app.

31
00:01:55,390 --> 00:01:59,440
But the question remains is,
how do they perform?

32
00:01:59,440 --> 00:02:02,380
Do they offer native
performance, which you come to

33
00:02:02,380 --> 00:02:05,580
expect if something is
a native application?

34
00:02:05,580 --> 00:02:07,820
Let's quickly run through
and see how some

35
00:02:07,820 --> 00:02:09,374
common algorithms perform.

36
00:02:09,374 --> 00:02:11,970

37
00:02:11,970 --> 00:02:14,200
So right here we're looking
at a graph showing the

38
00:02:14,200 --> 00:02:19,250
performance of C++ Bullet
Physics engine, which is a 3D

39
00:02:19,250 --> 00:02:23,720
physics engine which has been
used in many AAA video games.

40
00:02:23,720 --> 00:02:26,850
Compared to the JavaScript
performance of the same

41
00:02:26,850 --> 00:02:29,180
library, that would--

42
00:02:29,180 --> 00:02:32,960
you can't really see the native
C++ performance on this

43
00:02:32,960 --> 00:02:35,380
graph because it's just
so much faster.

44
00:02:35,380 --> 00:02:37,930
But let me zoom in.

45
00:02:37,930 --> 00:02:42,390
So you can start to see a
clearer picture here.

46
00:02:42,390 --> 00:02:45,690
We're seeing something that
looks like maybe 10 or 100

47
00:02:45,690 --> 00:02:49,070
times slower performance from
the JavaScript side

48
00:02:49,070 --> 00:02:51,050
than the C++ side.

49
00:02:51,050 --> 00:02:54,500
And if we switch over and we
look at GZIP decompression

50
00:02:54,500 --> 00:02:56,190
timings, again, we see
the same story.

51
00:02:56,190 --> 00:02:58,850

52
00:02:58,850 --> 00:03:01,900
Native performance is remarkably
fast compared to

53
00:03:01,900 --> 00:03:05,120
the JavaScript equivalent.

54
00:03:05,120 --> 00:03:10,820
And again, we see that with the
GZIP compression timings.

55
00:03:10,820 --> 00:03:13,740
What's interesting here is that
it's remarkable to me

56
00:03:13,740 --> 00:03:15,850
that you can do this
in JavaScript.

57
00:03:15,850 --> 00:03:18,820
But you can still do it so
much faster outside of

58
00:03:18,820 --> 00:03:20,250
JavaScript.

59
00:03:20,250 --> 00:03:23,770
So how do these Chrome Packaged
Apps perform?

60
00:03:23,770 --> 00:03:26,740
Well, JavaScript applications
are, on average, in order of

61
00:03:26,740 --> 00:03:29,620
magnitude, slower than
native applications.

62
00:03:29,620 --> 00:03:33,860
So while Chrome Apps are going
to give us these native feel

63
00:03:33,860 --> 00:03:37,390
and functionality applications,
they just can't

64
00:03:37,390 --> 00:03:41,240
overcome the performance gap
between JavaScript and C++

65
00:03:41,240 --> 00:03:43,660
without some help.

66
00:03:43,660 --> 00:03:46,210
So what if we could have the
best of both worlds?

67
00:03:46,210 --> 00:03:48,630
A world where we have native
performance where we really

68
00:03:48,630 --> 00:03:52,440
need it, but we get to write
the majority of the

69
00:03:52,440 --> 00:03:53,930
application in JavaScript.

70
00:03:53,930 --> 00:03:55,830
That's exactly what Native
Client Acceleration

71
00:03:55,830 --> 00:03:57,540
Modules give you.

72
00:03:57,540 --> 00:03:59,410
You have 90% of your application
written in

73
00:03:59,410 --> 00:04:00,440
JavaScript.

74
00:04:00,440 --> 00:04:03,150
This allows your development
to be really flexible.

75
00:04:03,150 --> 00:04:05,250
You can do your UI
in JavaScript.

76
00:04:05,250 --> 00:04:06,690
Very fast iteration times.

77
00:04:06,690 --> 00:04:09,770
It's a great developer
experience.

78
00:04:09,770 --> 00:04:14,200
Well, the remaining 10%, the 10%
of your application where

79
00:04:14,200 --> 00:04:18,160
performance really matters, can
be written in C++, often

80
00:04:18,160 --> 00:04:20,540
using off-the-shelf libraries
that are already written for

81
00:04:20,540 --> 00:04:25,320
you that you just have to go
and expose to JavaScript.

82
00:04:25,320 --> 00:04:26,660
C++ gives you performance.

83
00:04:26,660 --> 00:04:28,790
You can reuse existing code.

84
00:04:28,790 --> 00:04:32,880
And these modules are reusable
across many applications.

85
00:04:32,880 --> 00:04:35,450
You can imagine how many
applications could benefit

86
00:04:35,450 --> 00:04:39,890
from fast decompression or
compression algorithms.

87
00:04:39,890 --> 00:04:42,500
So Native Client Acceleration
Modules combined with Chrome

88
00:04:42,500 --> 00:04:46,430
Apps gives you 90% of Chrome App
but the native performance

89
00:04:46,430 --> 00:04:49,710
where you really need it.

90
00:04:49,710 --> 00:04:52,220
So what are Native Client
Acceleration Modules?

91
00:04:52,220 --> 00:04:56,350
Simply put, they expose C++
libraries to the web.

92
00:04:56,350 --> 00:04:58,510
They're Native Client programs
that are designed to

93
00:04:58,510 --> 00:04:59,930
communicate with JavaScript.

94
00:04:59,930 --> 00:05:01,730
They have no user interface
at all.

95
00:05:01,730 --> 00:05:03,910
They are effectively
libraries.

96
00:05:03,910 --> 00:05:06,335
And they're a combination
of C++ and JavaScript.

97
00:05:06,335 --> 00:05:08,990

98
00:05:08,990 --> 00:05:12,410
So for those of you don't know,
what is Native Client?

99
00:05:12,410 --> 00:05:15,560
Well, it's a secure
C/C++ runtime and

100
00:05:15,560 --> 00:05:17,840
toolchain for the web.

101
00:05:17,840 --> 00:05:23,260
It runs existing C/C++
and C# code natively.

102
00:05:23,260 --> 00:05:24,430
It's completely secure.

103
00:05:24,430 --> 00:05:25,660
It's sandboxed.

104
00:05:25,660 --> 00:05:26,860
It's safe.

105
00:05:26,860 --> 00:05:29,750
And it's available within
Chrome today.

106
00:05:29,750 --> 00:05:33,350
What I'm hoping a lot of the
Chrome App developers don't

107
00:05:33,350 --> 00:05:36,320
already know is that you can
actually use Native Client in

108
00:05:36,320 --> 00:05:39,960
combination with your
Chrome Apps.

109
00:05:39,960 --> 00:05:42,920
And Native Client interacts with
Chrome through a Pepper

110
00:05:42,920 --> 00:05:46,930
API, which exposes all sorts of
functionality, like OpenGL,

111
00:05:46,930 --> 00:05:50,680
Gamepad support, Mouse Lock,
Full Screen, et cetera.

112
00:05:50,680 --> 00:05:54,070
PETE LEPAGE: For folks who don't
know, what is Pepper?

113
00:05:54,070 --> 00:05:57,920
JOHN MCCUTCHAN: Pepper is a
plug-in interface to Chrome.

114
00:05:57,920 --> 00:06:04,530
And it exposes functionality to
plug-ins that Chrome hosts.

115
00:06:04,530 --> 00:06:09,500
So Chrome hosts an OpenGL,
a Gamepad library, some

116
00:06:09,500 --> 00:06:12,070
functionality to go
full screen and

117
00:06:12,070 --> 00:06:13,360
come out of full screen.

118
00:06:13,360 --> 00:06:15,350
And plug-ins can access that.

119
00:06:15,350 --> 00:06:19,860
Native Client Modules are
effectively sitting on top of

120
00:06:19,860 --> 00:06:21,490
the Pepper plug-in interface.

121
00:06:21,490 --> 00:06:24,110
So that's how they implement
their functionality that

122
00:06:24,110 --> 00:06:26,290
depends on Chrome.

123
00:06:26,290 --> 00:06:26,920
PETE LEPAGE: OK, cool.

124
00:06:26,920 --> 00:06:29,830
So you've got Native Client
that interacts with the

125
00:06:29,830 --> 00:06:33,740
Pepper, so that way it's an easy
way for developers to get

126
00:06:33,740 --> 00:06:34,850
access to these things?

127
00:06:34,850 --> 00:06:36,730
JOHN MCCUTCHAN: Yes, yes.

128
00:06:36,730 --> 00:06:38,095
It's very secure, very safe.

129
00:06:38,095 --> 00:06:40,810

130
00:06:40,810 --> 00:06:43,460
So if you wanted to develop a
Native Client application,

131
00:06:43,460 --> 00:06:45,330
what's the workflow
look like, then?

132
00:06:45,330 --> 00:06:46,990
You take your C++ code.

133
00:06:46,990 --> 00:06:49,210
You run it through the Native
Client compiler,

134
00:06:49,210 --> 00:06:51,100
which is just GCC.

135
00:06:51,100 --> 00:06:54,040
And the output of that is a
Native Client EXE and a

136
00:06:54,040 --> 00:06:55,270
manifest file.

137
00:06:55,270 --> 00:06:58,260
The manifest file describes some
dependencies that your

138
00:06:58,260 --> 00:07:02,160
application has and any
other requirements.

139
00:07:02,160 --> 00:07:04,650
And then you just insert
an embed tag into your

140
00:07:04,650 --> 00:07:06,690
HTML, and that's it.

141
00:07:06,690 --> 00:07:12,870
You go from a fully functional
C++ program that is running

142
00:07:12,870 --> 00:07:16,140
securely at native performance
inside of Chrome.

143
00:07:16,140 --> 00:07:19,920
It accesses things like OpenGL
through the Pepper API.

144
00:07:19,920 --> 00:07:24,130
So you can see a screen shot
here of AirMech, which is a

145
00:07:24,130 --> 00:07:25,380
fully C++ game.

146
00:07:25,380 --> 00:07:28,790

147
00:07:28,790 --> 00:07:30,490
So what are Native Client
Acceleration Modules?

148
00:07:30,490 --> 00:07:32,830
Because what I'm not really
suggesting here is that you

149
00:07:32,830 --> 00:07:36,170
write an entire Chrome
app in C++.

150
00:07:36,170 --> 00:07:39,780
What I'm saying is that you
extract the useful performance

151
00:07:39,780 --> 00:07:45,570
pieces of C++ and expose that
to JavaScript so that your

152
00:07:45,570 --> 00:07:48,310
Chrome application can offload
some of the really

153
00:07:48,310 --> 00:07:52,410
performance-intensive
work to C++.

154
00:07:52,410 --> 00:07:55,360
So the high-level view
looks like this.

155
00:07:55,360 --> 00:07:57,600
On the left, we have the
Chrome application.

156
00:07:57,600 --> 00:08:01,180
Then we have a Native Client
Acceleration Module JavaScript

157
00:08:01,180 --> 00:08:05,270
layer, which exposes the API
to the Chrome application,

158
00:08:05,270 --> 00:08:07,840
some kind of message-passing
magic.

159
00:08:07,840 --> 00:08:13,140
And then on the C++ side, a
Native Client Module that

160
00:08:13,140 --> 00:08:16,080
knows how to communicate with
the JavaScript pair on the

161
00:08:16,080 --> 00:08:18,660
other side.

162
00:08:18,660 --> 00:08:20,040
PETE LEPAGE: Now, John, I assume
you're going to tell us

163
00:08:20,040 --> 00:08:23,800
where that magic comes from,
and that I don't have to go

164
00:08:23,800 --> 00:08:25,150
figure that out myself.

165
00:08:25,150 --> 00:08:27,540
JOHN MCCUTCHAN: Yes, yes.

166
00:08:27,540 --> 00:08:29,710
Later on in the talk, I'm going
to talk about a library

167
00:08:29,710 --> 00:08:31,680
that I've written that makes
this really easy.

168
00:08:31,680 --> 00:08:34,220
So you just have to handle
the messages.

169
00:08:34,220 --> 00:08:37,130
And all the plumbing is
taken care of for you.

170
00:08:37,130 --> 00:08:38,380
So I want to switch gears.

171
00:08:38,380 --> 00:08:40,059
PETE LEPAGE: We can just get
everything back and forth.

172
00:08:40,059 --> 00:08:41,090
Sorry.

173
00:08:41,090 --> 00:08:41,500
JOHN MCCUTCHAN: No, no.

174
00:08:41,500 --> 00:08:44,200
Please feel free to
interrupt me.

175
00:08:44,200 --> 00:08:46,410
So I want to switch gears and
show a demo off here.

176
00:08:46,410 --> 00:08:49,260
What I'm going to show is
Bullet Physics, which is

177
00:08:49,260 --> 00:08:52,440
running in C++, combined
with a front end as

178
00:08:52,440 --> 00:08:54,220
it's written in three.js.

179
00:08:54,220 --> 00:08:56,240
All of this is sitting inside
of a Chrome app.

180
00:08:56,240 --> 00:08:58,920

181
00:08:58,920 --> 00:09:00,320
So here I am.

182
00:09:00,320 --> 00:09:03,100
Everything being drawn here
has been expressed in

183
00:09:03,100 --> 00:09:06,470
JavaScript or HTML.

184
00:09:06,470 --> 00:09:10,150
And if I start up the
simulation, you can see here

185
00:09:10,150 --> 00:09:12,160
that I've got a Jenga pile.

186
00:09:12,160 --> 00:09:16,140
Let me switch to
maybe 10 rows.

187
00:09:16,140 --> 00:09:18,710
I can pick up an object
and start playing with

188
00:09:18,710 --> 00:09:19,960
it and move it around.

189
00:09:19,960 --> 00:09:23,220

190
00:09:23,220 --> 00:09:24,210
Let me move the screen.

191
00:09:24,210 --> 00:09:26,850
You can see that there's a
simulation time counter.

192
00:09:26,850 --> 00:09:31,170
And this is just reporting how
long it takes the C++ code to

193
00:09:31,170 --> 00:09:33,400
update the physics simulation.

194
00:09:33,400 --> 00:09:36,960
And right now we're looking at
about 100, 150 microseconds.

195
00:09:36,960 --> 00:09:41,460
If I switch over to 400 cubes,
that's going to go up.

196
00:09:41,460 --> 00:09:43,660
It's approaching three
to four milliseconds.

197
00:09:43,660 --> 00:09:47,600
Now keep in mind that the same
program executing in

198
00:09:47,600 --> 00:09:49,800
JavaScript is an order
of magnitude slower.

199
00:09:49,800 --> 00:09:52,350

200
00:09:52,350 --> 00:09:56,100
So we've been able to couple
high-performance C++ physics

201
00:09:56,100 --> 00:09:58,790
simulations with an interactive
JavaScript

202
00:09:58,790 --> 00:10:01,760
application sitting inside
of a Chrome app.

203
00:10:01,760 --> 00:10:05,300
Interactive to the point where
I can grab objects, zoom in

204
00:10:05,300 --> 00:10:07,070
and zoom out, pick them
up, move them

205
00:10:07,070 --> 00:10:09,170
around, play with them.

206
00:10:09,170 --> 00:10:11,760
It's all running at 60 hertz,
something that's just not

207
00:10:11,760 --> 00:10:14,540
possible in an application
entirely written in

208
00:10:14,540 --> 00:10:15,790
JavaScript.

209
00:10:15,790 --> 00:10:18,690

210
00:10:18,690 --> 00:10:21,870
I have a blog post on my
website, which we'll link to

211
00:10:21,870 --> 00:10:24,730
after the show, which actually
describes a file format where

212
00:10:24,730 --> 00:10:27,960
you can write your own scenes
and then load them into the

213
00:10:27,960 --> 00:10:29,380
application.

214
00:10:29,380 --> 00:10:31,215
So it's kind of a fun little
physics playground.

215
00:10:31,215 --> 00:10:41,560

216
00:10:41,560 --> 00:10:45,850
So let's play a game.

217
00:10:45,850 --> 00:10:47,940
What part of that was written
in JavaScript?

218
00:10:47,940 --> 00:10:50,630
And what part of that
was written in C++?

219
00:10:50,630 --> 00:10:53,950
So the main loop, JavaScript.

220
00:10:53,950 --> 00:10:56,050
Rendering, JavaScript.

221
00:10:56,050 --> 00:11:01,150
Object selection, determining
the rigid body that's under my

222
00:11:01,150 --> 00:11:03,980
mouse cursor, JavaScript.

223
00:11:03,980 --> 00:11:06,820
Physics simulation, C++.

224
00:11:06,820 --> 00:11:08,390
And scene loading is
a combination of

225
00:11:08,390 --> 00:11:09,940
JavaScript and C++.

226
00:11:09,940 --> 00:11:12,710
The JavaScript side is
responsible for parsing the

227
00:11:12,710 --> 00:11:16,400
input file and structuring it
in such a way that the C++

228
00:11:16,400 --> 00:11:20,540
program expects,
but that's it.

229
00:11:20,540 --> 00:11:21,470
So it's kind of interesting.

230
00:11:21,470 --> 00:11:24,730
We get this hyper fast
physics simulation.

231
00:11:24,730 --> 00:11:27,520
But most of our application
was written in JavaScript.

232
00:11:27,520 --> 00:11:31,550
So it's very fun to
play around with.

233
00:11:31,550 --> 00:11:34,500
So how does this demo work
at a really high level?

234
00:11:34,500 --> 00:11:39,650
Well, in the blue boxes we have
messages that are passed.

235
00:11:39,650 --> 00:11:42,000
And the arrows are expressing
which direction they're going

236
00:11:42,000 --> 00:11:46,390
in, with the C++ module
being on the right.

237
00:11:46,390 --> 00:11:51,703
So at the initialization phase,
a load scene message is

238
00:11:51,703 --> 00:11:54,370
sent to C++, which describes
the scene, describes the

239
00:11:54,370 --> 00:11:57,480
initial state of the rigid
bodies, and their shapes, and

240
00:11:57,480 --> 00:11:57,980
things like that.

241
00:11:57,980 --> 00:12:00,910
And that gets sent over to the
C++ module, which then

242
00:12:00,910 --> 00:12:05,950
actually loads the scene into
the Bullet Physics simulation.

243
00:12:05,950 --> 00:12:09,210
Then at a regular interval, the
JavaScript code sends a

244
00:12:09,210 --> 00:12:12,560
message over to C++ that says,
run the physics simulation,

245
00:12:12,560 --> 00:12:16,260
update where the objects are,
and report back to me when

246
00:12:16,260 --> 00:12:17,020
you're done.

247
00:12:17,020 --> 00:12:18,830
So these are running in
parallel, actually.

248
00:12:18,830 --> 00:12:21,870
While the physics simulation is
executing, Chrome and your

249
00:12:21,870 --> 00:12:24,780
JavaScript application are
off doing something else.

250
00:12:24,780 --> 00:12:28,610
It's running a separate thread,
taking advantage of

251
00:12:28,610 --> 00:12:31,800
the many cores that
we all have.

252
00:12:31,800 --> 00:12:33,830
PETE LEPAGE: That's a real big
advantage, too, because you're

253
00:12:33,830 --> 00:12:37,460
not necessarily going to block
the UI thread in order to do

254
00:12:37,460 --> 00:12:39,890
any of that processing, which
sometimes happens with

255
00:12:39,890 --> 00:12:43,020
applications when you're doing
complex JavaScript.

256
00:12:43,020 --> 00:12:45,130
JOHN MCCUTCHAN: Yeah, I mean
that's why we have web

257
00:12:45,130 --> 00:12:45,800
workers, right?

258
00:12:45,800 --> 00:12:49,110
Web workers allow you to offload
this heavy work in a

259
00:12:49,110 --> 00:12:51,760
way that doesn't block
the UI thread.

260
00:12:51,760 --> 00:12:54,600
Native Client Acceleration
models work in the same way.

261
00:12:54,600 --> 00:12:57,720
You could think of them
as almost like a web

262
00:12:57,720 --> 00:12:58,630
worker, in a way.

263
00:12:58,630 --> 00:13:01,420
But it just happens to be
running C++ code and not

264
00:13:01,420 --> 00:13:02,510
JavaScript.

265
00:13:02,510 --> 00:13:04,550
But just like with
web workers.

266
00:13:04,550 --> 00:13:07,040
You communicate through
message passing.

267
00:13:07,040 --> 00:13:09,580
You communicate with a Native
Client Acceleration model

268
00:13:09,580 --> 00:13:12,520
through message passing.

269
00:13:12,520 --> 00:13:16,320
So after this step simulation
event is delivered, the

270
00:13:16,320 --> 00:13:19,490
physics simulation thread wakes
up, runs its processing,

271
00:13:19,490 --> 00:13:23,930
and then spits back out a
Float32Array containing the

272
00:13:23,930 --> 00:13:26,150
positions and orientations
of all the rigid

273
00:13:26,150 --> 00:13:28,590
bodies in the scene.

274
00:13:28,590 --> 00:13:31,640
The JavaScript code takes that
array and parses it and

275
00:13:31,640 --> 00:13:34,480
updates the rendering position
of all objects.

276
00:13:34,480 --> 00:13:41,130
And this just loops, as any
interactive application does.

277
00:13:41,130 --> 00:13:42,870
So what if you wanted to build
your own Native Client

278
00:13:42,870 --> 00:13:44,760
Acceleration Module?

279
00:13:44,760 --> 00:13:46,910
I'm going to leave some of the
details out of this, but this

280
00:13:46,910 --> 00:13:50,630
is going to paint the high level
picture and give you a

281
00:13:50,630 --> 00:13:53,190
lot of pointers to where
to look if you want to

282
00:13:53,190 --> 00:13:54,910
really get into it.

283
00:13:54,910 --> 00:13:57,100
So building a Native Client
Acceleration Module consists

284
00:13:57,100 --> 00:13:58,590
of three main components.

285
00:13:58,590 --> 00:14:02,020
The first is you have to write
your C++ glue layer that takes

286
00:14:02,020 --> 00:14:05,810
the messages and passes them
to the C++ code that you

287
00:14:05,810 --> 00:14:08,890
already have written or you've
downloaded off the web.

288
00:14:08,890 --> 00:14:12,880
You have to write a twin of that
on the JavaScript side,

289
00:14:12,880 --> 00:14:16,810
which receives messages from C++
and also packages messages

290
00:14:16,810 --> 00:14:19,600
up to send to C++.

291
00:14:19,600 --> 00:14:21,950
And then you have to determine
what messages you want to send

292
00:14:21,950 --> 00:14:25,220
between the two worlds and what
data should be included

293
00:14:25,220 --> 00:14:26,470
in each one.

294
00:14:26,470 --> 00:14:28,590

295
00:14:28,590 --> 00:14:31,380
So to make this really easy,
I've created a pair of

296
00:14:31,380 --> 00:14:33,620
libraries called Native Client

297
00:14:33,620 --> 00:14:36,280
Acceleration Module Base library.

298
00:14:36,280 --> 00:14:38,860
It's a C++ library and a
JavaScript library that makes

299
00:14:38,860 --> 00:14:41,700
creating acceleration modules
incredibly easy.

300
00:14:41,700 --> 00:14:42,860
You just have to write the code

301
00:14:42,860 --> 00:14:44,330
that responds to messages.

302
00:14:44,330 --> 00:14:47,270
You don't have to worry about
how do messages get across?

303
00:14:47,270 --> 00:14:49,980
How do I queue them up?

304
00:14:49,980 --> 00:14:52,440
All you have to do is just
implement a call back that

305
00:14:52,440 --> 00:14:54,130
says, hey, I got this
type of message.

306
00:14:54,130 --> 00:14:55,510
What should I do?

307
00:14:55,510 --> 00:14:58,090
You implement that little bit
of logic, and the rest is

308
00:14:58,090 --> 00:15:00,160
taken care for you in the
most performant way.

309
00:15:00,160 --> 00:15:04,420

310
00:15:04,420 --> 00:15:07,060
So let's talk about the
structure of the messages.

311
00:15:07,060 --> 00:15:09,340
So messages are split
into a header and

312
00:15:09,340 --> 00:15:10,680
then optional frames.

313
00:15:10,680 --> 00:15:15,060
The header is just a JSON
object, which has a command

314
00:15:15,060 --> 00:15:19,490
name, a request ID, which is
just the unique ID of this

315
00:15:19,490 --> 00:15:23,300
specific request, and then a
frames count, which is either

316
00:15:23,300 --> 00:15:27,700
0 if there's no auxiliary
frames, or some positive

317
00:15:27,700 --> 00:15:30,230
integer expressing the frames.

318
00:15:30,230 --> 00:15:32,400
You can see the structure
of the message on

319
00:15:32,400 --> 00:15:33,860
the right hand side.

320
00:15:33,860 --> 00:15:36,980
The JSON message header
is always present.

321
00:15:36,980 --> 00:15:38,120
And that's in red.

322
00:15:38,120 --> 00:15:40,560
The frames in blue
are optional.

323
00:15:40,560 --> 00:15:43,410
And these frames are interpreted
entirely by your

324
00:15:43,410 --> 00:15:44,430
message handler.

325
00:15:44,430 --> 00:15:49,840
They're just a bag of either
strings or raw

326
00:15:49,840 --> 00:15:53,460
bytes in a byte array.

327
00:15:53,460 --> 00:15:55,670
The Native Client Source Model
base library doesn't know

328
00:15:55,670 --> 00:15:56,820
what's in these at all.

329
00:15:56,820 --> 00:15:59,110
It just knows how to collect
them and aggregate them into

330
00:15:59,110 --> 00:16:00,360
the larger meta message.

331
00:16:00,360 --> 00:16:04,090

332
00:16:04,090 --> 00:16:07,840
So coming back to the Bullet
Physics demo, this is the

333
00:16:07,840 --> 00:16:09,350
messages that we've defined.

334
00:16:09,350 --> 00:16:13,330
So JavaScript can send a load
scene message to C++.

335
00:16:13,330 --> 00:16:16,450
It can send a step scene
message to C++.

336
00:16:16,450 --> 00:16:20,690
And it can also send a pick
up or drop object message.

337
00:16:20,690 --> 00:16:23,740
You saw that I was picking the
objects, and I said that the

338
00:16:23,740 --> 00:16:25,760
selection was being done
in JavaScript,

339
00:16:25,760 --> 00:16:28,150
which is entirely true.

340
00:16:28,150 --> 00:16:31,130
The JavaScript code figures out
what's under your mouse

341
00:16:31,130 --> 00:16:34,510
cursor and then sends that index
over to the C++ world

342
00:16:34,510 --> 00:16:38,110
and says, physics simulation,
grab that object, and pretend

343
00:16:38,110 --> 00:16:40,010
that I'm holding it.

344
00:16:40,010 --> 00:16:44,360
Inside the step scene message
is the position of my mouse

345
00:16:44,360 --> 00:16:45,900
cursor at the time.

346
00:16:45,900 --> 00:16:49,130
So that's how I'm able to
interactively play with the

347
00:16:49,130 --> 00:16:53,660
physics object while the
scene is simulating.

348
00:16:53,660 --> 00:16:56,270
Finally, there's one message
that comes from C++ to

349
00:16:56,270 --> 00:16:57,170
JavaScript.

350
00:16:57,170 --> 00:17:00,490
And that's the scene update
message, which includes the

351
00:17:00,490 --> 00:17:02,170
updated position and
orientation of

352
00:17:02,170 --> 00:17:03,420
all the rigid bodies.

353
00:17:03,420 --> 00:17:06,650

354
00:17:06,650 --> 00:17:10,369
On the C++ side, a Native Client
Acceleration Module

355
00:17:10,369 --> 00:17:11,740
based library requires that you

356
00:17:11,740 --> 00:17:13,359
implement just three functions.

357
00:17:13,359 --> 00:17:17,079
One is an initialization
routine, which just includes

358
00:17:17,079 --> 00:17:18,410
all your module start
up stuff.

359
00:17:18,410 --> 00:17:20,690
This is just going to be called
automatically when your

360
00:17:20,690 --> 00:17:23,510
Acceleration Module is
first initialized.

361
00:17:23,510 --> 00:17:26,589
There is a heartbeat method
which you can implement, which

362
00:17:26,589 --> 00:17:28,470
just gets called at 60 hertz.

363
00:17:28,470 --> 00:17:31,150
So if you have to do anything
regularly inside of your

364
00:17:31,150 --> 00:17:34,850
acceleration module, this is
where you put that logic.

365
00:17:34,850 --> 00:17:37,750
And then finally, the handle
message callback, which is

366
00:17:37,750 --> 00:17:41,430
called whenever a message is
delivered from JavaScript.

367
00:17:41,430 --> 00:17:46,160
And this is where you put your
application-specific logic,

368
00:17:46,160 --> 00:17:48,320
which is like, hey, I just
got a step scene message.

369
00:17:48,320 --> 00:17:51,370
Let me go and trigger the
physics simulation thread and

370
00:17:51,370 --> 00:17:53,320
let it run.

371
00:17:53,320 --> 00:17:56,170
You don't have to worry about
packaging up messages or

372
00:17:56,170 --> 00:17:57,280
parsing them in any way.

373
00:17:57,280 --> 00:17:58,530
You just have to implement
the logic.

374
00:17:58,530 --> 00:18:01,020

375
00:18:01,020 --> 00:18:04,040
On the JavaScript side,
it's really natural.

376
00:18:04,040 --> 00:18:06,230
If you want to respond to
something like, hey, the scene

377
00:18:06,230 --> 00:18:08,780
was updated, you just go
Add Event Listener.

378
00:18:08,780 --> 00:18:11,730
Or when you're done, you could
go Remove Event Listener.

379
00:18:11,730 --> 00:18:14,100
So from the JavaScript
programmer's prospective, this

380
00:18:14,100 --> 00:18:14,885
feels very natural.

381
00:18:14,885 --> 00:18:18,290
An Acceleration Module is just
some element that you can add

382
00:18:18,290 --> 00:18:19,440
an event listener to.

383
00:18:19,440 --> 00:18:21,330
And the events are the
messages coming

384
00:18:21,330 --> 00:18:23,750
from the C++ module.

385
00:18:23,750 --> 00:18:26,090
And if you want to send a
message to C++, there's a

386
00:18:26,090 --> 00:18:29,400
single method, Send Message,
which just takes the command

387
00:18:29,400 --> 00:18:32,450
name and some frames.

388
00:18:32,450 --> 00:18:33,490
It's very straightforward.

389
00:18:33,490 --> 00:18:37,320
I'm calling out in grey to scene
NaClAM.js At the end of

390
00:18:37,320 --> 00:18:40,310
the talk, there will be a link
to the GitHub repository,

391
00:18:40,310 --> 00:18:42,930
which includes this library.

392
00:18:42,930 --> 00:18:44,890
And you can dig in from there.

393
00:18:44,890 --> 00:18:47,680

394
00:18:47,680 --> 00:18:52,050
So wrapping up, NaCl
acceleration models bring

395
00:18:52,050 --> 00:18:54,660
native performance to web
applications and Chrome

396
00:18:54,660 --> 00:18:56,260
applications.

397
00:18:56,260 --> 00:18:59,840
It's really straightforward to
use if you're a web developer.

398
00:18:59,840 --> 00:19:03,480
And, like I said, you get 90%
of your application as a

399
00:19:03,480 --> 00:19:07,190
Chrome app written in JavaScript
and HTML5.

400
00:19:07,190 --> 00:19:09,970
And that last 10% where the
performance really matters,

401
00:19:09,970 --> 00:19:12,310
you get from C++.

402
00:19:12,310 --> 00:19:15,680
And you get native performance,
in order of

403
00:19:15,680 --> 00:19:19,180
magnitude faster than what's
possible through JavaScript.

404
00:19:19,180 --> 00:19:21,840
So hopefully you're really
interested in this.

405
00:19:21,840 --> 00:19:22,800
You want to get involved.

406
00:19:22,800 --> 00:19:25,440
So the first step to building
a Native Client Acceleration

407
00:19:25,440 --> 00:19:29,080
Module is to go and grab the
Native Client SDK from

408
00:19:29,080 --> 00:19:31,100
gonacl.com.

409
00:19:31,100 --> 00:19:33,500
You can try out the Bullet
Physics demo by going to the

410
00:19:33,500 --> 00:19:34,770
link on the slide.

411
00:19:34,770 --> 00:19:37,850
And you can join the Native
Client discussion thread by

412
00:19:37,850 --> 00:19:40,020
going to the final link
on the slide.

413
00:19:40,020 --> 00:19:43,610

414
00:19:43,610 --> 00:19:46,370
After you've gotten the SDK
running, you can go and grab

415
00:19:46,370 --> 00:19:49,170
the NaClAMBase framework
from the GitHub

416
00:19:49,170 --> 00:19:50,890
repository on the slide.

417
00:19:50,890 --> 00:19:53,230
And this includes the complete
source code to the Bullet

418
00:19:53,230 --> 00:19:55,300
Physics demo that
I demonstrated.

419
00:19:55,300 --> 00:19:57,940
So you can build that yourself
and play around with it and

420
00:19:57,940 --> 00:19:58,970
add new features.

421
00:19:58,970 --> 00:20:00,720
It's a great place to start.

422
00:20:00,720 --> 00:20:03,360

423
00:20:03,360 --> 00:20:07,070
So included inside the base
repository are three example

424
00:20:07,070 --> 00:20:08,550
Native Client Acceleration
Modules--

425
00:20:08,550 --> 00:20:11,530
the Bullet Physics one; an image
processing one, which

426
00:20:11,530 --> 00:20:16,570
takes a set of pixels from a
canvas object, does something

427
00:20:16,570 --> 00:20:18,780
with it, and then sends it back
over to JavaScript and it

428
00:20:18,780 --> 00:20:21,560
gets displayed again; and
then a Zlib compress

429
00:20:21,560 --> 00:20:23,770
and decompress module.

430
00:20:23,770 --> 00:20:27,730
These are just example modules
that you may use as a jumping

431
00:20:27,730 --> 00:20:30,430
off point or just as a template
to create your own

432
00:20:30,430 --> 00:20:33,730
and expose new libraries that
I haven't exposed yet.

433
00:20:33,730 --> 00:20:36,570

434
00:20:36,570 --> 00:20:38,820
So Chrome Apps plus Native
Client Acceleration Modules

435
00:20:38,820 --> 00:20:42,620
give you native performance
where it counts, which is

436
00:20:42,620 --> 00:20:45,040
really exciting, because Chrome
Apps already offer

437
00:20:45,040 --> 00:20:49,050
native feeling and native
functionality with them.

438
00:20:49,050 --> 00:20:51,760
But it's just missing that
final piece, which is

439
00:20:51,760 --> 00:20:53,140
performance.

440
00:20:53,140 --> 00:20:55,120
Luckily, though, most
applications only need

441
00:20:55,120 --> 00:20:57,510
performance in a very small
chunk of their code.

442
00:20:57,510 --> 00:20:58,900
And this is where Native
Client Acceleration

443
00:20:58,900 --> 00:21:00,970
Modules come in.

444
00:21:00,970 --> 00:21:03,890
Again, 90% of your application
is written

445
00:21:03,890 --> 00:21:05,710
increase in Chrome Apps.

446
00:21:05,710 --> 00:21:07,270
The last little bit
is written in C++.

447
00:21:07,270 --> 00:21:10,570

448
00:21:10,570 --> 00:21:11,820
So time for questions.

449
00:21:11,820 --> 00:21:13,390
But make sure you follow
me on Twitter.

450
00:21:13,390 --> 00:21:15,520
You can check out my blog
or read my code.

451
00:21:15,520 --> 00:21:18,000
And if there's a Native Client
Acceleration Module that you

452
00:21:18,000 --> 00:21:21,210
really want exposed, and maybe
you're not the greatest C++

453
00:21:21,210 --> 00:21:23,400
programmer, hit me up on G+.

454
00:21:23,400 --> 00:21:27,800
And if it's a good idea, I'll
be happy to do it for you.

455
00:21:27,800 --> 00:21:28,220
PETE LEPAGE: Cool.

456
00:21:28,220 --> 00:21:29,140
Well, thanks, John.

457
00:21:29,140 --> 00:21:31,240
That's some pretty neat stuff.

458
00:21:31,240 --> 00:21:34,790
And I think not only is it good
for things where you're

459
00:21:34,790 --> 00:21:36,830
just really trying to
improve performance.

460
00:21:36,830 --> 00:21:40,170
But it's really good for when
you've got to do stuff that's

461
00:21:40,170 --> 00:21:43,910
maybe complex or you've already
got libraries written

462
00:21:43,910 --> 00:21:47,150
in other languages, where you
just want to be able to reuse

463
00:21:47,150 --> 00:21:49,210
that across applications.

464
00:21:49,210 --> 00:21:52,180
One company I was talking to
a couple of weeks ago was

465
00:21:52,180 --> 00:21:54,770
saying, look, we have this
really great sync library that

466
00:21:54,770 --> 00:21:58,530
we use in our native
apps for mobile.

467
00:21:58,530 --> 00:22:01,720
And we really want to be able to
use that sync library to be

468
00:22:01,720 --> 00:22:06,050
able to sync data between the
client and the application.

469
00:22:06,050 --> 00:22:10,550
This is a perfect solution for
them to be able to do that.

470
00:22:10,550 --> 00:22:10,900
JOHN MCCUTCHAN: Yeah.

471
00:22:10,900 --> 00:22:11,560
Absolutely.

472
00:22:11,560 --> 00:22:14,490
I think you really hit the nail
on the head when you said

473
00:22:14,490 --> 00:22:16,900
you have this existing
code base.

474
00:22:16,900 --> 00:22:19,630
A lot of applications that are
interested in coming to the

475
00:22:19,630 --> 00:22:23,290
web, they already have a large
part of their application

476
00:22:23,290 --> 00:22:25,750
written in C++ or some
other language.

477
00:22:25,750 --> 00:22:28,640
And so the only thing that you
have to add on here is this

478
00:22:28,640 --> 00:22:30,934
message-passing logic.

479
00:22:30,934 --> 00:22:32,260
PETE LEPAGE: Yep.

480
00:22:32,260 --> 00:22:32,900
Cool.

481
00:22:32,900 --> 00:22:34,940
Well, why don't we take some of
the questions that people

482
00:22:34,940 --> 00:22:37,670
have posted to our Google
Moderator, and I'll have a

483
00:22:37,670 --> 00:22:39,790
look at some of the YouTube
questions as well.

484
00:22:39,790 --> 00:22:45,080
But Max West wants to know, "can
NaCl Acceleration Modules

485
00:22:45,080 --> 00:22:48,820
be used to encrypt streaming
files, like media, audio,

486
00:22:48,820 --> 00:22:50,220
video, and that kind
of thing?"

487
00:22:50,220 --> 00:22:51,470
JOHN MCCUTCHAN: Absolutely.

488
00:22:51,470 --> 00:22:53,500

489
00:22:53,500 --> 00:22:55,830
And there's another talk which
we'll link to afterwards which

490
00:22:55,830 --> 00:23:00,320
includes a measurement of the
latency in the throughput of

491
00:23:00,320 --> 00:23:01,330
transmitting data.

492
00:23:01,330 --> 00:23:05,220
And the throughput right now
is about 400 megabytes per

493
00:23:05,220 --> 00:23:07,130
second on my machine.

494
00:23:07,130 --> 00:23:09,480
So that's round trip.

495
00:23:09,480 --> 00:23:12,790
So that's from JavaScript into
Native Client Acceleration

496
00:23:12,790 --> 00:23:15,700
Module and then back into
JavaScript at 400 megabytes

497
00:23:15,700 --> 00:23:17,400
per second.

498
00:23:17,400 --> 00:23:20,090
PETE LEPAGE: That's
pretty serious.

499
00:23:20,090 --> 00:23:22,250
I'm trying to think what
you'd need for video.

500
00:23:22,250 --> 00:23:25,730
But I'd be willing to bet that's
probably pretty close,

501
00:23:25,730 --> 00:23:26,800
if not good enough.

502
00:23:26,800 --> 00:23:30,570
JOHN MCCUTCHAN: Back of the
envelope, I think you can do a

503
00:23:30,570 --> 00:23:38,300
1024 uncompressed image with 32
bits per pixel at 60 hertz.

504
00:23:38,300 --> 00:23:41,020
And that's about 260 megs.

505
00:23:41,020 --> 00:23:43,660
So you still some
room left over.

506
00:23:43,660 --> 00:23:45,450
And of course, when you're
dealing with video, it's

507
00:23:45,450 --> 00:23:47,460
already compressed.

508
00:23:47,460 --> 00:23:47,830
PETE LEPAGE: Right.

509
00:23:47,830 --> 00:23:49,550
Yeah, that's true.

510
00:23:49,550 --> 00:23:50,370
All right.

511
00:23:50,370 --> 00:23:53,970
Next, Rob from Missoula wants
to know, "is it possible to

512
00:23:53,970 --> 00:23:57,910
compile existing libraries
written in C# or Java to be

513
00:23:57,910 --> 00:24:02,390
used in NaCl in a Chrome app?"
And I know you touched on C#

514
00:24:02,390 --> 00:24:03,790
and said that the
answer was yes.

515
00:24:03,790 --> 00:24:05,310
But what about Java?

516
00:24:05,310 --> 00:24:07,880
JOHN MCCUTCHAN: I don't know
if that's possible today.

517
00:24:07,880 --> 00:24:13,360
But C# absolutely does work.

518
00:24:13,360 --> 00:24:15,770
PETE LEPAGE: So you said to
compile the stuff, people need

519
00:24:15,770 --> 00:24:17,330
to grab their GCC compiler.

520
00:24:17,330 --> 00:24:21,180
Where can they find
the great--

521
00:24:21,180 --> 00:24:22,450
I just want to go
through this.

522
00:24:22,450 --> 00:24:26,220
Are the docs up on the Chrome
Developer website?

523
00:24:26,220 --> 00:24:27,870
JOHN MCCUTCHAN: So for Native
Client, you want to go to

524
00:24:27,870 --> 00:24:29,050
gonacl.com.

525
00:24:29,050 --> 00:24:31,110
And that's going to explain
everything you need to know

526
00:24:31,110 --> 00:24:33,350
about developing with
Native Client.

527
00:24:33,350 --> 00:24:35,960
And right now, for Native Client
Acceleration Modules,

528
00:24:35,960 --> 00:24:39,670
the best place is to hit up the
GitHub repository, which

529
00:24:39,670 --> 00:24:42,400
has a lot of example code.

530
00:24:42,400 --> 00:24:45,730
We're going to be working to add
some stuff to the Chrome

531
00:24:45,730 --> 00:24:47,490
Apps documentation.

532
00:24:47,490 --> 00:24:48,700
PETE LEPAGE: And that's
on the GitHub

533
00:24:48,700 --> 00:24:50,300
repository that you posted?

534
00:24:50,300 --> 00:24:53,100
Or is that in the Google Chrome
GitHub repository?

535
00:24:53,100 --> 00:24:55,450
JOHN MCCUTCHAN: That's in my
own GitHub repository.

536
00:24:55,450 --> 00:24:58,390
And we'll post a link after
the show as well.

537
00:24:58,390 --> 00:24:58,960
PETE LEPAGE: OK.

538
00:24:58,960 --> 00:25:03,000
We'll get a post up on our
Chrome Developers page that

539
00:25:03,000 --> 00:25:06,010
you can go and have a look at.

540
00:25:06,010 --> 00:25:09,000
GT from India wants to know
whether the media source

541
00:25:09,000 --> 00:25:12,200
extension APIs are going to be
supported with Chrome for

542
00:25:12,200 --> 00:25:14,360
Android beta or the latest?

543
00:25:14,360 --> 00:25:17,500
We're not really focusing on
some of the Chrome for Android

544
00:25:17,500 --> 00:25:19,550
stuff today.

545
00:25:19,550 --> 00:25:23,470
But that's something that I
believe we want to support.

546
00:25:23,470 --> 00:25:26,710
But I don't want to give you a
complete answer right now, GT,

547
00:25:26,710 --> 00:25:30,260
because I'm not actually 100%
sure on the answer there.

548
00:25:30,260 --> 00:25:33,320
And then, John, last one for
you, and then we'll sign off.

549
00:25:33,320 --> 00:25:37,580
But "when will we be able to
have multiple OpenGL contacts

550
00:25:37,580 --> 00:25:41,260
in NaCl and use them off
the main thread?"

551
00:25:41,260 --> 00:25:42,910
JOHN MCCUTCHAN: So calling
off of the main

552
00:25:42,910 --> 00:25:44,160
thread is coming soon.

553
00:25:44,160 --> 00:25:46,430

554
00:25:46,430 --> 00:25:50,360
I'm not entirely sure on
the specific Chrome

555
00:25:50,360 --> 00:25:52,580
and NaCl SDK release.

556
00:25:52,580 --> 00:25:56,320
But it's coming really soon with
the ability to make all

557
00:25:56,320 --> 00:25:59,310
sorts of Pepper calls off
of the main thread.

558
00:25:59,310 --> 00:26:03,450
With respect to multiple OpenGL
contacts, I am not sure

559
00:26:03,450 --> 00:26:06,570
when that is coming,

560
00:26:06,570 --> 00:26:06,870
PETE LEPAGE: All right.

561
00:26:06,870 --> 00:26:08,410
Well, cool.

562
00:26:08,410 --> 00:26:09,530
Thanks for those answers.

563
00:26:09,530 --> 00:26:10,690
And thanks for a really
interesting

564
00:26:10,690 --> 00:26:12,510
presentation today.

565
00:26:12,510 --> 00:26:16,740
I didn't realize how this could
solve a lot of problems

566
00:26:16,740 --> 00:26:20,970
for people who already have
existing code bases, or maybe

567
00:26:20,970 --> 00:26:24,050
who are looking for places where
they just want to get

568
00:26:24,050 --> 00:26:26,920
that a little bit of extra
performance that they can't

569
00:26:26,920 --> 00:26:32,290
get because JavaScript V8 is
fast but maybe isn't quite

570
00:26:32,290 --> 00:26:34,840
where they need it to be in
order to do some rather

571
00:26:34,840 --> 00:26:37,050
complex calculations.

572
00:26:37,050 --> 00:26:38,240
Thanks for joining us.

573
00:26:38,240 --> 00:26:40,730
And thanks to everybody for
watching this week.

574
00:26:40,730 --> 00:26:43,630
We'll be back next week.

575
00:26:43,630 --> 00:26:45,240
I'll be live from
Mountain View.

576
00:26:45,240 --> 00:26:47,900
And we'll have Paul
Kinlan joining me.

577
00:26:47,900 --> 00:26:50,970
We're going to do just a fun--

578
00:26:50,970 --> 00:26:53,080
we're not going to plan
a topic for next week.

579
00:26:53,080 --> 00:26:54,370
We want to take your
questions.

580
00:26:54,370 --> 00:26:58,970
We want to open it up
to you to just chat.

581
00:26:58,970 --> 00:27:00,320
We're going to show off
some really cool

582
00:27:00,320 --> 00:27:01,960
demos, some neat stuff.

583
00:27:01,960 --> 00:27:05,220
I think I've got one up my
sleeve that hopefully I'll be

584
00:27:05,220 --> 00:27:08,050
able to get some stuff done
before then so that you guys

585
00:27:08,050 --> 00:27:10,720
can go and check out some
really cool stuff.

586
00:27:10,720 --> 00:27:12,120
Thanks for joining us, John.

587
00:27:12,120 --> 00:27:13,100
Thank you very much.

588
00:27:13,100 --> 00:27:14,750
And Louis, thanks
for producing.

589
00:27:14,750 --> 00:27:15,180
JOHN MCCUTCHAN: Thanks,
everyone.

590
00:27:15,180 --> 00:27:17,020
PETE LEPAGE: And have a
great week, everybody.

591
00:27:17,020 --> 00:27:18,270
Thank you.

592
00:27:18,270 --> 00:27:39,633

