1
00:00:00,000 --> 00:00:00,906

2
00:00:00,906 --> 00:00:01,360
LOREENA LEE: All right.

3
00:00:01,360 --> 00:00:01,970
Hi, everyone.

4
00:00:01,970 --> 00:00:03,210
Good afternoon.

5
00:00:03,210 --> 00:00:04,170
My name is Loreena Lee.

6
00:00:04,170 --> 00:00:05,725
I'm an engineer on
the Gmail team.

7
00:00:05,725 --> 00:00:10,030
I've been working recently on
performance mostly and taking

8
00:00:10,030 --> 00:00:13,080
a good look at how much memory
Gmail's been using.

9
00:00:13,080 --> 00:00:13,510
JOHN MCCUTCHAN: Hi, everyone.

10
00:00:13,510 --> 00:00:14,430
I'm John McCutchan.

11
00:00:14,430 --> 00:00:15,660
I'm part of Chrome Dev Rel.

12
00:00:15,660 --> 00:00:19,830
And my focus is also on
performance and memory usage.

13
00:00:19,830 --> 00:00:21,430
LOREENA LEE: So today we're
going to cover everything from

14
00:00:21,430 --> 00:00:24,300
memory management basics
to garbage collection.

15
00:00:24,300 --> 00:00:26,290
And we're going to introduce
some tools and techniques to

16
00:00:26,290 --> 00:00:29,440
help you understand how much
memory your app is using.

17
00:00:29,440 --> 00:00:30,750
So why is this important?

18
00:00:30,750 --> 00:00:37,130

19
00:00:37,130 --> 00:00:39,080
A lot of times when people talk
about performance versus

20
00:00:39,080 --> 00:00:43,320
memory, performance wins
9 times out of 10.

21
00:00:43,320 --> 00:00:46,180
And this is the trade-off
that people usually say,

22
00:00:46,180 --> 00:00:47,070
performance versus memory?

23
00:00:47,070 --> 00:00:49,150
Let's go ahead and
use more memory.

24
00:00:49,150 --> 00:00:51,262
JOHN MCCUTCHAN: So the idea
being that the more memory you

25
00:00:51,262 --> 00:00:53,220
use the better the
performance is?

26
00:00:53,220 --> 00:00:53,750
LOREENA LEE: Right.

27
00:00:53,750 --> 00:00:56,220
So generally, if your caching
more, you're keeping more

28
00:00:56,220 --> 00:00:58,880
resident memory, you have less
fetches to disk, so your

29
00:00:58,880 --> 00:01:00,610
performance is usually
improved.

30
00:01:00,610 --> 00:01:02,630
And so people were starting
to say that Gmail was

31
00:01:02,630 --> 00:01:03,690
using a lot of memory.

32
00:01:03,690 --> 00:01:06,840
We started hearing a lot of
anecdotes of people having a

33
00:01:06,840 --> 00:01:09,150
Gmail tab that's using
a whole gig of mem.

34
00:01:09,150 --> 00:01:10,740
And that seems kind of a lot.

35
00:01:10,740 --> 00:01:12,690
But a lot about the same time
were like, well, who cares?

36
00:01:12,690 --> 00:01:13,690
You have a ton of memory.

37
00:01:13,690 --> 00:01:14,690
Memory's cheap.

38
00:01:14,690 --> 00:01:16,580
Why not just use it?

39
00:01:16,580 --> 00:01:19,940
But the time of our users
is very important.

40
00:01:19,940 --> 00:01:22,670
So if they're spending two to
three seconds waiting for

41
00:01:22,670 --> 00:01:25,050
their app to be responsive,
that's not good.

42
00:01:25,050 --> 00:01:27,770
We don't want to waste
their time.

43
00:01:27,770 --> 00:01:30,480
So we'll start using a little
bit more memory, start caching

44
00:01:30,480 --> 00:01:33,340
a little bit more, help them
to get things to be more

45
00:01:33,340 --> 00:01:34,560
responsive.

46
00:01:34,560 --> 00:01:37,640
But at the same time, what's
worse than having your users

47
00:01:37,640 --> 00:01:40,750
wait two to three seconds?

48
00:01:40,750 --> 00:01:42,140
Having your app crash.

49
00:01:42,140 --> 00:01:44,600
So this is the "He's
Dead, Jim" sad tab.

50
00:01:44,600 --> 00:01:46,240
And a lot of you have probably
seen this before.

51
00:01:46,240 --> 00:01:48,600
This is the Chrome sad tab.

52
00:01:48,600 --> 00:01:51,390
And the "He's dead, Jim" variety
almost always comes as

53
00:01:51,390 --> 00:01:53,660
an out of memory situation.

54
00:01:53,660 --> 00:01:55,630
So we were starting to hear more
and more stories about

55
00:01:55,630 --> 00:01:57,820
Gmail running out of memory and
people getting sad tabs

56
00:01:57,820 --> 00:01:59,250
because of Gmail.

57
00:01:59,250 --> 00:02:01,120
But we didn't really have
any data to know

58
00:02:01,120 --> 00:02:03,050
how common this was.

59
00:02:03,050 --> 00:02:05,420
Our colleagues were telling us,
oh, my Gmail ran out of

60
00:02:05,420 --> 00:02:07,860
memory again, caused my
browser to crash.

61
00:02:07,860 --> 00:02:11,130
But we didn't know if this is
something that was only

62
00:02:11,130 --> 00:02:12,780
happening to people we knew.

63
00:02:12,780 --> 00:02:16,020
Our power users were having
this situation, but our

64
00:02:16,020 --> 00:02:17,380
parents weren't really
complaining.

65
00:02:17,380 --> 00:02:20,380
But they only get a couple
mails a day or a

66
00:02:20,380 --> 00:02:21,570
week, in some cases.

67
00:02:21,570 --> 00:02:23,540
They probably spend a few
minutes on Gmail.

68
00:02:23,540 --> 00:02:27,170
Whereas people at Google tend
to spend all day, getting

69
00:02:27,170 --> 00:02:28,900
several hundred messages
a day.

70
00:02:28,900 --> 00:02:29,175
JOHN MCCUTCHAN: Yeah.

71
00:02:29,175 --> 00:02:32,565
A few emails a minute.

72
00:02:32,565 --> 00:02:34,570
LOREENA LEE: But we didn't
have any scientific data.

73
00:02:34,570 --> 00:02:35,690
We only had anecdotes.

74
00:02:35,690 --> 00:02:39,570
We had a bunch of tools that
didn't necessarily scale up to

75
00:02:39,570 --> 00:02:42,970
things like applications
as big as Gmail.

76
00:02:42,970 --> 00:02:45,200
We didn't really know how to
track what was leaking.

77
00:02:45,200 --> 00:02:48,880
We didn't know how to
find the problems.

78
00:02:48,880 --> 00:02:51,890
And so we kind of were starting
from nothing.

79
00:02:51,890 --> 00:02:53,720
So I'm talking a little bit
about Gmail right now.

80
00:02:53,720 --> 00:02:55,780
But really, this problem
is universal.

81
00:02:55,780 --> 00:02:57,680
Running out of memory
is something that

82
00:02:57,680 --> 00:02:59,290
everyone can encounter.

83
00:02:59,290 --> 00:03:00,510
And you should care.

84
00:03:00,510 --> 00:03:03,490
Because I don't know how much
you know about the Chrome

85
00:03:03,490 --> 00:03:08,000
process model, but this isn't
just Gmail's problem.

86
00:03:08,000 --> 00:03:10,440
So if you see here, I have
a ton of tabs open.

87
00:03:10,440 --> 00:03:13,140
And Chrome will normally try to
open all of these tabs in

88
00:03:13,140 --> 00:03:14,820
their own renderer process, but

89
00:03:14,820 --> 00:03:16,080
that's not always possible.

90
00:03:16,080 --> 00:03:18,280
So Chrome has a hard
limit on how many

91
00:03:18,280 --> 00:03:19,910
processes it will fork.

92
00:03:19,910 --> 00:03:22,280
And once you've exhausted that
limit, it will start putting

93
00:03:22,280 --> 00:03:24,780
multiple tabs in a process.

94
00:03:24,780 --> 00:03:28,010
JOHN MCCUTCHAN: So do you mean
if Gmail uses a lot of memory

95
00:03:28,010 --> 00:03:30,980
or some pages a lot of memory,
it might kill five pages?

96
00:03:30,980 --> 00:03:31,330
LOREENA LEE: Right.

97
00:03:31,330 --> 00:03:34,580
So if all of these pages are
in the same process, that's

98
00:03:34,580 --> 00:03:36,990
why a lot of times if you do
see this out of memory

99
00:03:36,990 --> 00:03:39,950
situation with the sad tab
you'll notice several of them

100
00:03:39,950 --> 00:03:40,980
at the same time.

101
00:03:40,980 --> 00:03:42,640
It's not just one tab
that's crashing.

102
00:03:42,640 --> 00:03:45,060
It's all of them that are
in that same process.

103
00:03:45,060 --> 00:03:46,960
So this is something that
everyone needs to care about,

104
00:03:46,960 --> 00:03:50,300
not just Gmail, not just your
app, but anyone who ends up in

105
00:03:50,300 --> 00:03:52,420
the same process as your
app will care as well.

106
00:03:52,420 --> 00:03:54,990
Just like anyone who ends up in
the same process as Gmail

107
00:03:54,990 --> 00:03:57,090
will probably be glad that we
are making some effort to

108
00:03:57,090 --> 00:03:58,872
reduce the amount of memory
that we're using.

109
00:03:58,872 --> 00:04:02,210

110
00:04:02,210 --> 00:04:02,690
JOHN MCCUTCHAN: All right.

111
00:04:02,690 --> 00:04:05,330
But before we can tackle
Gmail's problem, it's

112
00:04:05,330 --> 00:04:08,570
important that we go back to
basics and understand both the

113
00:04:08,570 --> 00:04:13,480
conceptual concepts for memory
management in JavaScript as

114
00:04:13,480 --> 00:04:17,500
well as the practical with
V8 in particular.

115
00:04:17,500 --> 00:04:20,230
So let's first talk about a high
level understanding of

116
00:04:20,230 --> 00:04:23,390
how memory is managed
inside JavaScript.

117
00:04:23,390 --> 00:04:27,270
So the questions I want you to
be able to answer after this

118
00:04:27,270 --> 00:04:29,900
set of slides is, what types
of values are there in

119
00:04:29,900 --> 00:04:30,870
JavaScript?

120
00:04:30,870 --> 00:04:32,910
How are they organized
in memory?

121
00:04:32,910 --> 00:04:33,970
What is garbage?

122
00:04:33,970 --> 00:04:34,870
And what is a leak?

123
00:04:34,870 --> 00:04:36,260
These are really basic
questions.

124
00:04:36,260 --> 00:04:39,060
And I'm sure a lot of you know
the answers to these already.

125
00:04:39,060 --> 00:04:41,190
But it's important that we have
really good definitions

126
00:04:41,190 --> 00:04:44,250
of what these are so that we
can understand both the

127
00:04:44,250 --> 00:04:47,300
problem and the tools.

128
00:04:47,300 --> 00:04:50,690
So JavaScript has very
few value types.

129
00:04:50,690 --> 00:04:54,090
There's booleans, there's
numbers, there's strings,

130
00:04:54,090 --> 00:04:56,710
there's objects, and then
there's external data.

131
00:04:56,710 --> 00:04:59,250
And so you'll know that there's
no arrays here.

132
00:04:59,250 --> 00:05:01,210
And that's actually because
JavaScript as a language

133
00:05:01,210 --> 00:05:02,200
doesn't have arrays.

134
00:05:02,200 --> 00:05:05,390
They're built on top of the
objects inside JavaScript.

135
00:05:05,390 --> 00:05:09,150
The keys are just the indexes
into the array.

136
00:05:09,150 --> 00:05:09,810
But this is it.

137
00:05:09,810 --> 00:05:13,080
This is all that
JavaScript has.

138
00:05:13,080 --> 00:05:17,440
And the way they're organized
in memory is in a graph.

139
00:05:17,440 --> 00:05:19,560
You'll see here this
blue node here.

140
00:05:19,560 --> 00:05:20,780
And this is a root node.

141
00:05:20,780 --> 00:05:23,680
This is outside of your
application's control, think

142
00:05:23,680 --> 00:05:25,630
document or window.

143
00:05:25,630 --> 00:05:27,370
This is created by
the browser.

144
00:05:27,370 --> 00:05:30,300
It's in there as long as your
page is loaded, and you really

145
00:05:30,300 --> 00:05:32,540
can't do anything with it
other than maybe add

146
00:05:32,540 --> 00:05:34,610
properties to it.

147
00:05:34,610 --> 00:05:36,480
From root nodes, there's
object nodes.

148
00:05:36,480 --> 00:05:38,070
And these are JavaScript
objects.

149
00:05:38,070 --> 00:05:40,820
And they're the only nodes which
can actually reference

150
00:05:40,820 --> 00:05:43,840
other values inside the graph.

151
00:05:43,840 --> 00:05:49,720
Terminating the graph are scaler
nodes, like a boolean

152
00:05:49,720 --> 00:05:51,060
or a number.

153
00:05:51,060 --> 00:05:54,800
These values cannot reference
other values inside the graph.

154
00:05:54,800 --> 00:05:55,330
So this is it.

155
00:05:55,330 --> 00:05:58,330
This is how memory is organized
inside JavaScript,

156
00:05:58,330 --> 00:06:01,410
and this is what you, as a
programmer, can observe.

157
00:06:01,410 --> 00:06:04,210
You have root notes, which are
outside of your control,

158
00:06:04,210 --> 00:06:06,820
objects, which you can extend
and reference other values,

159
00:06:06,820 --> 00:06:09,780
and then the scalar
nodes, which can't

160
00:06:09,780 --> 00:06:12,140
reference anything else.

161
00:06:12,140 --> 00:06:14,240
So another property that
values can have

162
00:06:14,240 --> 00:06:15,890
are retaining paths.

163
00:06:15,890 --> 00:06:19,140
And this is a path from the root
node to the value itself.

164
00:06:19,140 --> 00:06:23,740
And so, every value can have one
or more retaining paths.

165
00:06:23,740 --> 00:06:25,950
And if we look at the green
value on the graph, you can

166
00:06:25,950 --> 00:06:28,730
actually see that there's one
retaining path that starts at

167
00:06:28,730 --> 00:06:32,150
the root node and extends
along the red edge.

168
00:06:32,150 --> 00:06:35,000
And there's a second retaining
that starts at the root node

169
00:06:35,000 --> 00:06:37,190
and then extends along
these two red edges.

170
00:06:37,190 --> 00:06:39,770
Both of these are retaining
paths for the green node.

171
00:06:39,770 --> 00:06:41,720
It keeps the green
node in memory.

172
00:06:41,720 --> 00:06:44,130
Without a retaining path, the
value becomes garbage.

173
00:06:44,130 --> 00:06:48,640
And we'll get into
that in a moment.

174
00:06:48,640 --> 00:06:52,020
So again, this is a fairly
basic operation.

175
00:06:52,020 --> 00:06:54,230
But it's important to understand
exactly how you can

176
00:06:54,230 --> 00:06:56,180
remove a value from the graph.

177
00:06:56,180 --> 00:06:59,130
So if we want to remove the red
value from the graph, we

178
00:06:59,130 --> 00:07:02,970
could cut this edge right here,
from the root node to

179
00:07:02,970 --> 00:07:03,980
the first green node.

180
00:07:03,980 --> 00:07:06,280
And then the red value
is garbage.

181
00:07:06,280 --> 00:07:10,480
If we cut this edge,
it's also garbage.

182
00:07:10,480 --> 00:07:11,570
Or we cut this edge.

183
00:07:11,570 --> 00:07:13,890
Any of those three edges
cut would make

184
00:07:13,890 --> 00:07:16,650
the red node garbage.

185
00:07:16,650 --> 00:07:18,450
So what exactly is garbage?

186
00:07:18,450 --> 00:07:20,580
Well, it's all values which
cannot be reached

187
00:07:20,580 --> 00:07:21,690
from the root node.

188
00:07:21,690 --> 00:07:23,710
Or said another way, it's
all values that

189
00:07:23,710 --> 00:07:24,930
lack a retaining path.

190
00:07:24,930 --> 00:07:27,110
If something doesn't have a
retaining path, then it

191
00:07:27,110 --> 00:07:31,170
becomes garbage, like
these nodes here.

192
00:07:31,170 --> 00:07:34,740
You'll see that there is no
path from the root node to

193
00:07:34,740 --> 00:07:36,610
these values, so these values
are actually garbage.

194
00:07:36,610 --> 00:07:38,190
At some point, they
were on the graph,

195
00:07:38,190 --> 00:07:39,010
and now they're not.

196
00:07:39,010 --> 00:07:42,640
And at the next garbage
collection process, they'll be

197
00:07:42,640 --> 00:07:45,960
cleaned up, which actually
brings us to garbage

198
00:07:45,960 --> 00:07:46,490
collection.

199
00:07:46,490 --> 00:07:50,430
So the first step in a garbage
collection pass is to find all

200
00:07:50,430 --> 00:07:51,790
the live values.

201
00:07:51,790 --> 00:07:55,030
And then the second is to return
the memory used by the

202
00:07:55,030 --> 00:07:57,750
dead values back to the system
so that they can be recycled

203
00:07:57,750 --> 00:08:00,450
later on, as we see here.

204
00:08:00,450 --> 00:08:03,250

205
00:08:03,250 --> 00:08:06,580
So another property that every
value inside JavaScript has is

206
00:08:06,580 --> 00:08:07,850
its retained size.

207
00:08:07,850 --> 00:08:10,530
So the retained size, you can
conceptually think about this

208
00:08:10,530 --> 00:08:13,810
as the amount of memory that
would be freed if the value

209
00:08:13,810 --> 00:08:14,810
became garbage.

210
00:08:14,810 --> 00:08:17,760
And so that's the size of
the value and all of its

211
00:08:17,760 --> 00:08:19,860
descendants which lack
retaining paths.

212
00:08:19,860 --> 00:08:23,200
So if we look at the yellow
node on the graph, its

213
00:08:23,200 --> 00:08:26,460
retained size is its size plus
the size of the green node.

214
00:08:26,460 --> 00:08:29,360
And if we pull back, the
retained sides of this new

215
00:08:29,360 --> 00:08:32,860
yellow node is both of the green
node size plus itself.

216
00:08:32,860 --> 00:08:35,190
And if we go all the way back to
the root node, the retained

217
00:08:35,190 --> 00:08:37,180
size is all memory being
used by JavaScript.

218
00:08:37,180 --> 00:08:40,440

219
00:08:40,440 --> 00:08:42,809
So now let's talk
about a leak.

220
00:08:42,809 --> 00:08:46,470
A leak is when you, the
programmer, have mistakenly

221
00:08:46,470 --> 00:08:49,100
left a retaining path some
value inside the graph.

222
00:08:49,100 --> 00:08:52,610
You think that the value has no
path, starting from a root

223
00:08:52,610 --> 00:08:55,450
node, getting to it, and that
it'll be collected at the next

224
00:08:55,450 --> 00:08:57,240
garbage collection cycle.

225
00:08:57,240 --> 00:09:00,130
But you've accidentally
left a retaining path.

226
00:09:00,130 --> 00:09:03,900
So it's a program error, as
all memory leaks are.

227
00:09:03,900 --> 00:09:06,820
If we look at this really simple
example that's kind of

228
00:09:06,820 --> 00:09:09,990
Gmail themed, we have an email
object and we have the message

229
00:09:09,990 --> 00:09:11,300
field inside of it.

230
00:09:11,300 --> 00:09:14,820
And we assign that to be
a div node in the dom.

231
00:09:14,820 --> 00:09:17,960
We then want to display these
email messages, so we add that

232
00:09:17,960 --> 00:09:22,100
div node into a display
list as well.

233
00:09:22,100 --> 00:09:24,570
So this is what the object
graph looks like after

234
00:09:24,570 --> 00:09:25,940
running this code.

235
00:09:25,940 --> 00:09:28,560
Somewhere, starting at the root
node, there's paths to

236
00:09:28,560 --> 00:09:30,170
both email and display.

237
00:09:30,170 --> 00:09:33,240
And then off of email, there's
a path to message.

238
00:09:33,240 --> 00:09:36,060
And there's a special
kind of edge from

239
00:09:36,060 --> 00:09:37,490
message to the Div Node.

240
00:09:37,490 --> 00:09:40,380
And this is pinning a native
object, an external object

241
00:09:40,380 --> 00:09:44,470
that's not directly related
to JavaScript.

242
00:09:44,470 --> 00:09:45,430
But this is the way it looks.

243
00:09:45,430 --> 00:09:46,700
You follow the other path.

244
00:09:46,700 --> 00:09:49,150
You go from display, and then
you have this list of div

245
00:09:49,150 --> 00:09:52,030
elements, terminating with the
div node that we just created

246
00:09:52,030 --> 00:09:53,660
on the previous slide.

247
00:09:53,660 --> 00:09:55,190
LOREENA LEE: So everything
here, the green nodes are

248
00:09:55,190 --> 00:09:58,196
JavaScript objects, and the
yellow are actual dom nodes?

249
00:09:58,196 --> 00:09:58,532
JOHN MCCUTCHAN: Yes.

250
00:09:58,532 --> 00:09:58,870
Yeah.

251
00:09:58,870 --> 00:10:02,150
They're external to
the JavaScript.

252
00:10:02,150 --> 00:10:04,320
So at some point later on,
we're done looking at

253
00:10:04,320 --> 00:10:06,440
messages, and we want to just
clean out the display list.

254
00:10:06,440 --> 00:10:08,940
So the programmer writes
removeAllChildren, Children

255
00:10:08,940 --> 00:10:11,200
and you think, OK, all those
div nodes are gone.

256
00:10:11,200 --> 00:10:15,560
But whoops, we've actually
cached a reference from the

257
00:10:15,560 --> 00:10:17,910
message object to
the div node.

258
00:10:17,910 --> 00:10:21,280
So until the email itself is
removed from the system, which

259
00:10:21,280 --> 00:10:24,500
could take forever and might not
ever happen, this div node

260
00:10:24,500 --> 00:10:26,880
will be pinned in memory,
and we've leaked it.

261
00:10:26,880 --> 00:10:29,520

262
00:10:29,520 --> 00:10:33,760
So in general, the really basics
of memory management in

263
00:10:33,760 --> 00:10:35,560
JavaScript are that
the values are all

264
00:10:35,560 --> 00:10:37,360
organized inside this graph.

265
00:10:37,360 --> 00:10:39,750
And they have retaining paths.

266
00:10:39,750 --> 00:10:41,750
And any value that
lacks a retaining

267
00:10:41,750 --> 00:10:44,160
path has become garbage.

268
00:10:44,160 --> 00:10:45,420
And then there's
retained sizes.

269
00:10:45,420 --> 00:10:46,910
And that's the amount of memory
that you're going to

270
00:10:46,910 --> 00:10:52,340
free up when the value itself
becomes garbage.

271
00:10:52,340 --> 00:10:56,530
So let's go from the general to
the specific and talk about

272
00:10:56,530 --> 00:10:59,580
the way V8 manages
memory and what

273
00:10:59,580 --> 00:11:02,680
happens during a GC Pause.

274
00:11:02,680 --> 00:11:04,940
The first question you want to
ask yourself is, what's the

275
00:11:04,940 --> 00:11:07,920
cost in allocating memory
in JavaScript?

276
00:11:07,920 --> 00:11:09,530
And it's not the call to new.

277
00:11:09,530 --> 00:11:11,890
Typically, the call to new
is incredibly fast.

278
00:11:11,890 --> 00:11:14,820

279
00:11:14,820 --> 00:11:17,985
It's very, very quick, until
you've exhausted a memory

280
00:11:17,985 --> 00:11:19,950
pool, and we'll get to
this in a moment of

281
00:11:19,950 --> 00:11:21,100
what's actually happening.

282
00:11:21,100 --> 00:11:23,580
But at that point, the runtime
is forced to do a garbage

283
00:11:23,580 --> 00:11:23,940
collection.

284
00:11:23,940 --> 00:11:26,560
And this is where all
the time is spent.

285
00:11:26,560 --> 00:11:28,450
And it can actually
take milliseconds.

286
00:11:28,450 --> 00:11:32,170
So if you're writing a game, you
have 16 milliseconds to do

287
00:11:32,170 --> 00:11:33,920
everything inside
of your frame.

288
00:11:33,920 --> 00:11:36,680
And a garbage collection pause
might pause your application

289
00:11:36,680 --> 00:11:40,830
for 5, maybe 10 milliseconds,
which for Gmail might be OK,

290
00:11:40,830 --> 00:11:44,950
but for some applications
it's really too long.

291
00:11:44,950 --> 00:11:47,930
So it's important to be aware
at the pattern at which your

292
00:11:47,930 --> 00:11:52,170
application is allocating
objects and understand how it

293
00:11:52,170 --> 00:11:54,070
interacts with the garbage
collector.

294
00:11:54,070 --> 00:11:57,890
And this is what we're going
to talk about right now.

295
00:11:57,890 --> 00:12:00,040
V8 manages memory in
two generations.

296
00:12:00,040 --> 00:12:02,920
There's the young generation and
then the old generation.

297
00:12:02,920 --> 00:12:07,430
And by young and old, I mean
how long has the JavaScript

298
00:12:07,430 --> 00:12:09,460
value existed for.

299
00:12:09,460 --> 00:12:14,000
And over time, young values get
promoted to old values.

300
00:12:14,000 --> 00:12:16,540
So after a few garbage
collections, if the value

301
00:12:16,540 --> 00:12:20,110
survives, meaning that there's a
retaining path and it's kept

302
00:12:20,110 --> 00:12:23,150
in memory, eventually the value
gets promoted into the

303
00:12:23,150 --> 00:12:25,930
old generation.

304
00:12:25,930 --> 00:12:29,630
So what are the properties of
the young generation in V8?

305
00:12:29,630 --> 00:12:33,620
Well, it offers really fast
allocation, fast collection,

306
00:12:33,620 --> 00:12:35,220
and it's frequently collected.

307
00:12:35,220 --> 00:12:38,410
In fact, when you're using the
Timeline tool and you see the

308
00:12:38,410 --> 00:12:41,065
GC Event on it, this is a young
generation collection.

309
00:12:41,065 --> 00:12:48,360

310
00:12:48,360 --> 00:12:51,770
In contrast, the old generation
offers fast

311
00:12:51,770 --> 00:12:55,650
allocation, but the collection
is much slower.

312
00:12:55,650 --> 00:12:58,010
The good thing is that it's very
infrequently collected.

313
00:12:58,010 --> 00:13:00,810
And some of the old generation's
collection occurs

314
00:13:00,810 --> 00:13:03,720
in parallel with your
page's execution.

315
00:13:03,720 --> 00:13:06,170
Whereas a young generation
collection, is really just

316
00:13:06,170 --> 00:13:09,320
everything is stopped, the
collection occurs, and then

317
00:13:09,320 --> 00:13:10,330
your page resumes.

318
00:13:10,330 --> 00:13:15,880
Old generation mixes a little
bit of collection with your

319
00:13:15,880 --> 00:13:18,250
page's execution.

320
00:13:18,250 --> 00:13:21,460
So I want to focus mostly on
young generation, because this

321
00:13:21,460 --> 00:13:24,990
is where you're going to feel
the pain inside your

322
00:13:24,990 --> 00:13:25,760
application.

323
00:13:25,760 --> 00:13:27,500
And it's going to happen
fairly regularly.

324
00:13:27,500 --> 00:13:30,610

325
00:13:30,610 --> 00:13:33,770
It's important to understand
why collecting the young

326
00:13:33,770 --> 00:13:35,670
generation is faster.

327
00:13:35,670 --> 00:13:39,660
And intuitively, you have to
understand that the cost of

328
00:13:39,660 --> 00:13:42,450
the GC Pause is actually
proportional to the number of

329
00:13:42,450 --> 00:13:43,790
live objects.

330
00:13:43,790 --> 00:13:46,740
And because the objects are
split into the young and the

331
00:13:46,740 --> 00:13:48,750
old generation, the
young generation,

332
00:13:48,750 --> 00:13:51,050
actually not much survives.

333
00:13:51,050 --> 00:13:53,540
After a garbage collection,
most of the values in the

334
00:13:53,540 --> 00:13:56,020
young generation
don't make it.

335
00:13:56,020 --> 00:13:58,760
They have no retaining path,
because they were used just

336
00:13:58,760 --> 00:14:00,160
briefly, and they're gone,
and they're not

337
00:14:00,160 --> 00:14:01,600
really in the graph.

338
00:14:01,600 --> 00:14:05,330
Whereas by their nature, objects
in the old generation

339
00:14:05,330 --> 00:14:07,020
have survived quite
a long time.

340
00:14:07,020 --> 00:14:10,090
So you can't expect that when a
collection is triggered for

341
00:14:10,090 --> 00:14:11,650
the old generation
that many of them

342
00:14:11,650 --> 00:14:13,770
are going to disappear.

343
00:14:13,770 --> 00:14:16,710
So knowing that the cost of the
garbage collection pause

344
00:14:16,710 --> 00:14:19,170
really comes down to the number
of live objects, it

345
00:14:19,170 --> 00:14:21,500
becomes quite clear why
collecting the young

346
00:14:21,500 --> 00:14:24,870
generations so much faster.

347
00:14:24,870 --> 00:14:27,420
So let's look at the young
generation in action.

348
00:14:27,420 --> 00:14:29,630
The young generation
is split into two

349
00:14:29,630 --> 00:14:32,170
semispaces, equally sized.

350
00:14:32,170 --> 00:14:34,970
There's the To Space
and the From Space.

351
00:14:34,970 --> 00:14:38,010
The To Space is where values
that you allocate when your

352
00:14:38,010 --> 00:14:42,240
page executes, like, new Foo,
it's coming out of To Space.

353
00:14:42,240 --> 00:14:46,280
The From Space actually just
sits there not being used

354
00:14:46,280 --> 00:14:47,060
until later on.

355
00:14:47,060 --> 00:14:48,740
And we'll see what
happens with it.

356
00:14:48,740 --> 00:14:52,220

357
00:14:52,220 --> 00:14:55,450
So assuming that To Space
started off empty and your

358
00:14:55,450 --> 00:14:57,480
page starts allocated
some objects.

359
00:14:57,480 --> 00:15:02,170
It does new A and then new B,
new C, and new D. Everything

360
00:15:02,170 --> 00:15:04,000
up until this point has been
really fast, and there's been

361
00:15:04,000 --> 00:15:08,600
no interruption in your
page's execution.

362
00:15:08,600 --> 00:15:11,670
But then, your page calls
new E. And actually,

363
00:15:11,670 --> 00:15:12,620
it's just too big.

364
00:15:12,620 --> 00:15:15,200
It doesn't fit into
the To Space.

365
00:15:15,200 --> 00:15:18,700
We've hit that threshold where
we've moved incrementally

366
00:15:18,700 --> 00:15:20,770
closer to this GC Pause,
and now we've

367
00:15:20,770 --> 00:15:22,430
actually triggered it.

368
00:15:22,430 --> 00:15:25,870
So what happens is new
E doesn't happen.

369
00:15:25,870 --> 00:15:27,410
It's kind of paused.

370
00:15:27,410 --> 00:15:29,970
So we're still in this state
where we just have A, B, C,

371
00:15:29,970 --> 00:15:32,065
and D inside of our To Space.

372
00:15:32,065 --> 00:15:34,880
The page is paused, everything
halts, and the

373
00:15:34,880 --> 00:15:36,130
collection is triggered.

374
00:15:36,130 --> 00:15:38,350

375
00:15:38,350 --> 00:15:41,110
The first step in a young
generation collection is that

376
00:15:41,110 --> 00:15:43,270
the From and the To Space
and just swapped.

377
00:15:43,270 --> 00:15:46,470
The labels to them are
flipped internally.

378
00:15:46,470 --> 00:15:49,020
And then the live values
are found.

379
00:15:49,020 --> 00:15:51,950
And I'm not really going into
details about exactly how the

380
00:15:51,950 --> 00:15:54,790
live values are found, but
this is the next step.

381
00:15:54,790 --> 00:15:57,780
Everything that still has a
retaining path, still on the

382
00:15:57,780 --> 00:16:03,510
graph is discovered and
marked for copy.

383
00:16:03,510 --> 00:16:05,790
So you can see here that
A and C are marked.

384
00:16:05,790 --> 00:16:09,550
And B and D have not been
marked, so they're garbage.

385
00:16:09,550 --> 00:16:12,040
They're not going anywhere.

386
00:16:12,040 --> 00:16:13,860
And then this is where most
of the time goes.

387
00:16:13,860 --> 00:16:18,280
It's when the live values are
copied from the From Space to

388
00:16:18,280 --> 00:16:20,950
the To Space.

389
00:16:20,950 --> 00:16:21,740
So here we are.

390
00:16:21,740 --> 00:16:22,390
We've done the copy.

391
00:16:22,390 --> 00:16:23,620
We've done the collection.

392
00:16:23,620 --> 00:16:26,030
We've just copied the live
objects from one

393
00:16:26,030 --> 00:16:29,400
semispace to the next.

394
00:16:29,400 --> 00:16:32,130
And the From Space is just
recycled at this point.

395
00:16:32,130 --> 00:16:33,780
There's no other work
done to it.

396
00:16:33,780 --> 00:16:36,440
It's just ready for use next
time there's a collection that

397
00:16:36,440 --> 00:16:38,430
needs to happen.

398
00:16:38,430 --> 00:16:40,880
At this point, your page
is resumed, and

399
00:16:40,880 --> 00:16:42,460
the E object is allocated.

400
00:16:42,460 --> 00:16:45,810

401
00:16:45,810 --> 00:16:48,760
What you have to understand is
that each allocation moves you

402
00:16:48,760 --> 00:16:50,330
closer to a collection.

403
00:16:50,330 --> 00:16:52,730
And so, when Loreena was talking
earlier about this

404
00:16:52,730 --> 00:16:56,220
trade-off between more memory
and performance, you start to

405
00:16:56,220 --> 00:16:58,610
see why that doesn't hold
up inside JavaScript.

406
00:16:58,610 --> 00:17:00,910
Because the more memory you use,
the faster you're going

407
00:17:00,910 --> 00:17:03,020
to get to this pause, and that's
actually where you're

408
00:17:03,020 --> 00:17:04,180
going to lose performance.

409
00:17:04,180 --> 00:17:04,609
LOREENA LEE: Right.

410
00:17:04,609 --> 00:17:06,310
And not only that, but the more
memory you're using, the

411
00:17:06,310 --> 00:17:07,444
longer the pause will take.

412
00:17:07,444 --> 00:17:07,800
JOHN MCCUTCHAN: Yes.

413
00:17:07,800 --> 00:17:09,200
LOREENA LEE: The larger the
heap, the longer the

414
00:17:09,200 --> 00:17:10,520
collection will take.

415
00:17:10,520 --> 00:17:10,770
JOHN MCCUTCHAN: Yep.

416
00:17:10,770 --> 00:17:11,170
Exactly.

417
00:17:11,170 --> 00:17:13,579
And so, when the collection
occurs, your

418
00:17:13,579 --> 00:17:14,409
application is paused.

419
00:17:14,409 --> 00:17:16,130
You get higher latency.

420
00:17:16,130 --> 00:17:18,250
Let's say the user clicks,
and then right then

421
00:17:18,250 --> 00:17:19,500
a collection occurs.

422
00:17:19,500 --> 00:17:21,829
Well, the click isn't going to
register for a while, because

423
00:17:21,829 --> 00:17:23,640
we've got to go and do
a big collection.

424
00:17:23,640 --> 00:17:26,720
So this leads to dropped
frames and poor user

425
00:17:26,720 --> 00:17:29,300
interaction, in general,
and unhappy users.

426
00:17:29,300 --> 00:17:32,340
And unhappy users don't come
back to your site.

427
00:17:32,340 --> 00:17:35,665
They'll go somewhere else
with better performance.

428
00:17:35,665 --> 00:17:36,280
LOREENA LEE: All right.

429
00:17:36,280 --> 00:17:39,020
So now we've heard a little bit
about what happens when

430
00:17:39,020 --> 00:17:41,080
you have a GC Pause and
how it all works.

431
00:17:41,080 --> 00:17:44,540
But let's see how we can now
take what we learned and apply

432
00:17:44,540 --> 00:17:48,030
some tools and techniques to
figure out how we can fix it.

433
00:17:48,030 --> 00:17:49,900
So I mentioned that we were
starting out from nothing in

434
00:17:49,900 --> 00:17:52,980
Gmail, and we really had no
idea how problematic the

435
00:17:52,980 --> 00:17:54,160
memory situation as.

436
00:17:54,160 --> 00:17:56,990
We heard our colleagues telling
us on a daily basis

437
00:17:56,990 --> 00:17:58,520
that they were having
lots of issues.

438
00:17:58,520 --> 00:17:59,840
But we didn't know exactly.

439
00:17:59,840 --> 00:18:02,650
So we wanted to start and take
some field measurements.

440
00:18:02,650 --> 00:18:05,120
We wanted to know how bad
it was for all of you.

441
00:18:05,120 --> 00:18:07,580
So we used the
performance.memory API.

442
00:18:07,580 --> 00:18:11,090
And what we do is we take
measurements every 30 minutes.

443
00:18:11,090 --> 00:18:13,610
We store them in our logs, we
aggregate them, and we can

444
00:18:13,610 --> 00:18:14,150
graph them.

445
00:18:14,150 --> 00:18:17,200
We can kind of see what's the
difference between our power

446
00:18:17,200 --> 00:18:20,670
users, the 99th percentile,
versus our median and the

447
00:18:20,670 --> 00:18:25,140
people who just spend a few
minutes a day here and there.

448
00:18:25,140 --> 00:18:27,580
So what the performance.memory
API does is it

449
00:18:27,580 --> 00:18:28,680
returns three values.

450
00:18:28,680 --> 00:18:31,320
It tells you the jsHeapSizeLimit
which is the

451
00:18:31,320 --> 00:18:34,290
total amount of memory available
for JavaScript.

452
00:18:34,290 --> 00:18:37,030
So this is the upper limit.

453
00:18:37,030 --> 00:18:39,420
And then it tells you the
totalJSHeapSize, which is the

454
00:18:39,420 --> 00:18:42,220
amount of memory that has been
allocated so far, including

455
00:18:42,220 --> 00:18:42,850
the free space.

456
00:18:42,850 --> 00:18:45,580
So this is including memory that
has already been GCed.

457
00:18:45,580 --> 00:18:49,710
JOHN MCCUTCHAN: So could you
predict an "I'm dead, Jim"

458
00:18:49,710 --> 00:18:52,790
situation by seeing when
totalJSHeapSize hits the

459
00:18:52,790 --> 00:18:53,560
jsHeapSizeLimit?

460
00:18:53,560 --> 00:18:53,820
LOREENA LEE: Right.

461
00:18:53,820 --> 00:18:54,080
Right.

462
00:18:54,080 --> 00:18:56,560
As that totalJSHeapSize gets
closer and closer, you know

463
00:18:56,560 --> 00:18:59,130
that at some point you're going
to trigger this out of

464
00:18:59,130 --> 00:18:59,706
memory situation.

465
00:18:59,706 --> 00:19:02,120
JOHN MCCUTCHAN: OK.

466
00:19:02,120 --> 00:19:03,830
LOREENA LEE: And then the third
value that returns is

467
00:19:03,830 --> 00:19:04,865
the usedJSHeapSize.

468
00:19:04,865 --> 00:19:06,530
And that tells you the amount
of memory that's

469
00:19:06,530 --> 00:19:07,510
currently in use.

470
00:19:07,510 --> 00:19:09,810
So this is the amount of memory
that's being used by

471
00:19:09,810 --> 00:19:11,240
live objects in the graph.

472
00:19:11,240 --> 00:19:15,610

473
00:19:15,610 --> 00:19:16,760
We were taking these
measurements from a

474
00:19:16,760 --> 00:19:19,010
select set of users.

475
00:19:19,010 --> 00:19:21,990
Gmail has a lot of users, so
we were able to get quite a

476
00:19:21,990 --> 00:19:24,070
bit of data from these users.

477
00:19:24,070 --> 00:19:26,180
And what we did was
we took one user.

478
00:19:26,180 --> 00:19:27,600
We just sort of followed
that user.

479
00:19:27,600 --> 00:19:30,720
We took a user who we knew was
using a lot of memory, who was

480
00:19:30,720 --> 00:19:32,610
nearing this upper limit,
and we followed

481
00:19:32,610 --> 00:19:33,810
them for three days.

482
00:19:33,810 --> 00:19:36,320
So we wanted to see what the
correlation was between the

483
00:19:36,320 --> 00:19:38,980
memory data we were collecting
as well as the latency data we

484
00:19:38,980 --> 00:19:39,650
were collecting.

485
00:19:39,650 --> 00:19:42,310
And what we found a little bit
against what our common belief

486
00:19:42,310 --> 00:19:44,906
of the performance versus
memory trade-off was.

487
00:19:44,906 --> 00:19:49,620
What we found was that as the
user's heap memory footprint

488
00:19:49,620 --> 00:19:52,230
grew, their client
side latencies

489
00:19:52,230 --> 00:19:54,170
were increasing also.

490
00:19:54,170 --> 00:19:55,770
So over to the right
of each of these

491
00:19:55,770 --> 00:19:57,440
graphs is by day three.

492
00:19:57,440 --> 00:20:01,350
By day three, their heap size
was getting very large.

493
00:20:01,350 --> 00:20:02,980
It was well over a gig.

494
00:20:02,980 --> 00:20:05,890
And their latencies, the
variance between of the

495
00:20:05,890 --> 00:20:08,320
latencies as well as the actual
values of the latency

496
00:20:08,320 --> 00:20:09,900
were much much, much higher.

497
00:20:09,900 --> 00:20:12,120
And so, given what you've
just heard about garbage

498
00:20:12,120 --> 00:20:15,300
collection, you can see that
once the heap was large, these

499
00:20:15,300 --> 00:20:18,650
GC pauses were taking more
and more amount of time.

500
00:20:18,650 --> 00:20:21,130
And so that's what you see is
happening in these latencies.

501
00:20:21,130 --> 00:20:23,910
So some of those outliers were
probably several second long

502
00:20:23,910 --> 00:20:25,240
garbage collection pauses.

503
00:20:25,240 --> 00:20:27,690
And those are things that we
want to definitely avoid.

504
00:20:27,690 --> 00:20:28,180
JOHN MCCUTCHAN: Yeah.

505
00:20:28,180 --> 00:20:30,760
LOREENA LEE: So after seeing
this data, we were more

506
00:20:30,760 --> 00:20:34,910
motivated than ever to get
things under control.

507
00:20:34,910 --> 00:20:36,385
So we turned to the Chrome
Developer Tools.

508
00:20:36,385 --> 00:20:39,070
And If you haven't used
the tools before--

509
00:20:39,070 --> 00:20:41,100
I hope everyone in this room has
at least fiddled with them

510
00:20:41,100 --> 00:20:43,120
a little bit-- they're really,
really powerful.

511
00:20:43,120 --> 00:20:44,670
And they're getting better
and better every day.

512
00:20:44,670 --> 00:20:46,810
When we were first starting
out, some of these tools

513
00:20:46,810 --> 00:20:49,310
didn't really scale to
applications of Gmail size.

514
00:20:49,310 --> 00:20:51,960
But since then, we've forged
a relationship with the

515
00:20:51,960 --> 00:20:53,440
DevTools, and things
have gotten

516
00:20:53,440 --> 00:20:55,710
much, much, much better.

517
00:20:55,710 --> 00:20:58,130
Now we actually find that almost
anything we need to

518
00:20:58,130 --> 00:21:00,830
answer to we can find
in the DevTools.

519
00:21:00,830 --> 00:21:04,520
So to get to the DevTools, this
is what we affectionately

520
00:21:04,520 --> 00:21:06,840
call the hot dog menu, the
three bars you see in the

521
00:21:06,840 --> 00:21:09,530
upper right-hand corner of your
Chrome browser window.

522
00:21:09,530 --> 00:21:12,020
The hotdog menu, Tools,
and Developer Tools.

523
00:21:12,020 --> 00:21:13,740
JOHN MCCUTCHAN: It's not
the hamburger menu?

524
00:21:13,740 --> 00:21:15,135
LOREENA LEE: There's
hot debate.

525
00:21:15,135 --> 00:21:17,560
JOHN MCCUTCHAN: Yeah.

526
00:21:17,560 --> 00:21:19,000
LOREENA LEE: So once you open
up these tools, you'll see a

527
00:21:19,000 --> 00:21:21,030
powerful set of tools.

528
00:21:21,030 --> 00:21:23,110
Inside here, we have
a CPU profiler.

529
00:21:23,110 --> 00:21:24,250
We have a heap profiler.

530
00:21:24,250 --> 00:21:27,640
We have Timeline tools that can
tell you about your events

531
00:21:27,640 --> 00:21:29,690
that are happening in your
page, such as the garbage

532
00:21:29,690 --> 00:21:30,710
collection events.

533
00:21:30,710 --> 00:21:33,780
Also, things like paint
time, rendering time.

534
00:21:33,780 --> 00:21:36,060
All of these things you can
see in the DevTools.

535
00:21:36,060 --> 00:21:37,910
There's an interactive
JavaScript console.

536
00:21:37,910 --> 00:21:40,430
It can interact with
your application.

537
00:21:40,430 --> 00:21:41,670
So they're really powerful.

538
00:21:41,670 --> 00:21:43,920
But right now we're going to
talk about the part of the

539
00:21:43,920 --> 00:21:48,890
DevTools that we use to diagnose
these memory issues.

540
00:21:48,890 --> 00:21:51,620
The first thing I like to do is
go to the Memory Timeline.

541
00:21:51,620 --> 00:21:54,200
And this is in the Timeline
panel of your DevTools.

542
00:21:54,200 --> 00:21:57,460
And what you can do here is you
can see at the top there's

543
00:21:57,460 --> 00:21:59,480
actually multiple tabs here.

544
00:21:59,480 --> 00:22:02,110
There's an Events Timeline that
can show you the garbage

545
00:22:02,110 --> 00:22:04,490
collection pauses, like the
screenshot you saw earlier.

546
00:22:04,490 --> 00:22:06,800
And then here, we're
the Memory Panel

547
00:22:06,800 --> 00:22:08,750
and the Memory Timeline.

548
00:22:08,750 --> 00:22:11,040
At the top there, you
see the blue.

549
00:22:11,040 --> 00:22:12,810
And that's overall memory.

550
00:22:12,810 --> 00:22:16,250
And then down below, you have
the ability to see three

551
00:22:16,250 --> 00:22:17,180
different counts.

552
00:22:17,180 --> 00:22:19,660
And right now I only have the
dom node count enabled.

553
00:22:19,660 --> 00:22:22,790
But you can see the document
count, the dom node count, and

554
00:22:22,790 --> 00:22:23,595
the event listener account.

555
00:22:23,595 --> 00:22:27,090
And so these will tell you over
the timeline you recorded

556
00:22:27,090 --> 00:22:32,300
how many of each of these things
is currently live.

557
00:22:32,300 --> 00:22:35,290
So what you do is you take an
action or a sequence of

558
00:22:35,290 --> 00:22:37,960
actions that you identify
as possibly suspicious.

559
00:22:37,960 --> 00:22:39,330
You think that there
may be a leak in

560
00:22:39,330 --> 00:22:42,070
performing these actions.

561
00:22:42,070 --> 00:22:42,810
You start the timeline.

562
00:22:42,810 --> 00:22:45,410
You can perform these actions
a number of times.

563
00:22:45,410 --> 00:22:48,810
And so in this case, we
performed them six times.

564
00:22:48,810 --> 00:22:50,050
And then there's a little
garbage can

565
00:22:50,050 --> 00:22:51,500
button at the bottom.

566
00:22:51,500 --> 00:22:54,480
You can click that button, and
that'll force a full garbage

567
00:22:54,480 --> 00:22:56,240
collection.

568
00:22:56,240 --> 00:22:59,930
And if you suspect that this
action should not leave any

569
00:22:59,930 --> 00:23:03,370
dom nodes behind but that
number of nodes is not

570
00:23:03,370 --> 00:23:05,290
dropping back down to your
baseline, you have a pretty

571
00:23:05,290 --> 00:23:07,600
good indication that
there's a leak.

572
00:23:07,600 --> 00:23:10,160
So here we did the experiment
twice, just make sure.

573
00:23:10,160 --> 00:23:13,270
And we see that each time we
forced a GC, that number of

574
00:23:13,270 --> 00:23:16,150
dom nodes is not dropping back
down to the baseline.

575
00:23:16,150 --> 00:23:17,510
So we're pretty sure
we have a leak.

576
00:23:17,510 --> 00:23:19,560
This is an action that we've
identified that should be

577
00:23:19,560 --> 00:23:22,190
clean, but it's obviously not.

578
00:23:22,190 --> 00:23:24,710
JOHN MCCUTCHAN: By clean, you
mean there should be nothing

579
00:23:24,710 --> 00:23:25,720
in the graph afterwards?

580
00:23:25,720 --> 00:23:27,650
LOREENA LEE: We expect that the
actions should not leave

581
00:23:27,650 --> 00:23:28,540
behind any dom nodes.

582
00:23:28,540 --> 00:23:31,150
We think that we've cleaned
up after ourselves.

583
00:23:31,150 --> 00:23:32,440
So we obviously have not.

584
00:23:32,440 --> 00:23:34,880
So now what?

585
00:23:34,880 --> 00:23:37,300
I'm really excited to introduce
the Object Tracker.

586
00:23:37,300 --> 00:23:38,280
And this is brand new.

587
00:23:38,280 --> 00:23:41,990
This is currently only enabled
in Chrome Canary

588
00:23:41,990 --> 00:23:42,900
that you can get now.

589
00:23:42,900 --> 00:23:45,510
But you need to enable the
DevTools Experiments.

590
00:23:45,510 --> 00:23:47,040
And we'll give you instructions
on how to do

591
00:23:47,040 --> 00:23:51,120
that, DevTools Experiments, and
then the Object Tracker.

592
00:23:51,120 --> 00:23:52,870
And this is really cool because
it combines the best

593
00:23:52,870 --> 00:23:54,250
of both worlds.

594
00:23:54,250 --> 00:23:56,640
This combines the timeline
functionality, like the one I

595
00:23:56,640 --> 00:24:00,070
just showed, with the heap
profiler that is already

596
00:24:00,070 --> 00:24:03,360
existing in current
stable channel.

597
00:24:03,360 --> 00:24:05,590
And that heap profiler will tell
you all the objects that

598
00:24:05,590 --> 00:24:07,180
are in the heap at
any given time.

599
00:24:07,180 --> 00:24:09,830
When you collect a snapshot,
it'll show you everything

600
00:24:09,830 --> 00:24:12,390
that's in the heap that's
live at a given time.

601
00:24:12,390 --> 00:24:16,070
But here now, you can start
recording, and it'll take

602
00:24:16,070 --> 00:24:18,720
snapshots periodically through
that recording.

603
00:24:18,720 --> 00:24:22,900
And it'll tell you what objects
were live in that

604
00:24:22,900 --> 00:24:28,470
recording at any given time,
or I should say, that were

605
00:24:28,470 --> 00:24:30,410
allocated during that time.

606
00:24:30,410 --> 00:24:33,500
So let's look a little
bit more in detail.

607
00:24:33,500 --> 00:24:35,900
Here at the top, you see
some color-coded bars.

608
00:24:35,900 --> 00:24:38,210
These identify new objects
that were found that were

609
00:24:38,210 --> 00:24:39,890
allocated during the timeline.

610
00:24:39,890 --> 00:24:42,980
So I said that we take periodic
snapshots while we're

611
00:24:42,980 --> 00:24:43,690
doing this.

612
00:24:43,690 --> 00:24:47,300
And as you take a snapshot, it
does a full profile snapshot,

613
00:24:47,300 --> 00:24:48,920
heap profile.

614
00:24:48,920 --> 00:24:52,950
And it'll look for new objects
that weren't there the

615
00:24:52,950 --> 00:24:54,590
previous time.

616
00:24:54,590 --> 00:24:57,700
So here, you see that there
are 10 bars, and there's

617
00:24:57,700 --> 00:24:59,390
different colors.

618
00:24:59,390 --> 00:25:02,650
The blue bars indicate new
objects that were found during

619
00:25:02,650 --> 00:25:06,080
that time that are still live
at the end of the timeline.

620
00:25:06,080 --> 00:25:07,480
JOHN MCCUTCHAN: At the
end of the capture.

621
00:25:07,480 --> 00:25:08,900
LOREENA LEE: At the end
of the capture.

622
00:25:08,900 --> 00:25:11,550
So the end of this timeframe
that the whole

623
00:25:11,550 --> 00:25:13,080
recording was taken.

624
00:25:13,080 --> 00:25:15,080
The gray bars show that there
were new objects that were

625
00:25:15,080 --> 00:25:19,210
found at that point in time,
but they've since

626
00:25:19,210 --> 00:25:20,210
been garbage collected.

627
00:25:20,210 --> 00:25:24,270
So by the end of the capture,
those objects that are in gray

628
00:25:24,270 --> 00:25:27,250
now have been collected.

629
00:25:27,250 --> 00:25:30,900
You can also narrow in on any
of those bars to get more

630
00:25:30,900 --> 00:25:33,800
information about what exactly
was in that difference.

631
00:25:33,800 --> 00:25:35,990
JOHN MCCUTCHAN: Yeah.

632
00:25:35,990 --> 00:25:40,510
LOREENA LEE: And then down below
is the heap contents.

633
00:25:40,510 --> 00:25:43,770
JOHN MCCUTCHAN: The heap
contents is connected to the

634
00:25:43,770 --> 00:25:44,960
time window that you've
selected.

635
00:25:44,960 --> 00:25:45,310
LOREENA LEE: Right.

636
00:25:45,310 --> 00:25:47,800
JOHN MCCUTCHAN: So it's only
going to show objects that are

637
00:25:47,800 --> 00:25:50,360
alive that are within the time
range that you've picked.

638
00:25:50,360 --> 00:25:51,680
LOREENA LEE: Right.

639
00:25:51,680 --> 00:25:52,460
OK.

640
00:25:52,460 --> 00:25:55,100
I know it's hard to tell from
screenshots, so you probably

641
00:25:55,100 --> 00:25:56,350
want to see a demo.

642
00:25:56,350 --> 00:25:58,410

643
00:25:58,410 --> 00:25:58,650
Let's see.

644
00:25:58,650 --> 00:26:01,180
So we wrote a simple mail-like
app, since we're talking about

645
00:26:01,180 --> 00:26:02,670
Gmail here.

646
00:26:02,670 --> 00:26:06,430
In Gmail, we cached messages
for better performance.

647
00:26:06,430 --> 00:26:10,350
In this little demo, we have
a cache of size 5.

648
00:26:10,350 --> 00:26:13,260
That means that, in theory, no
more than 5 messages should be

649
00:26:13,260 --> 00:26:14,600
in memory at any given time.

650
00:26:14,600 --> 00:26:17,794
So let's take a look.

651
00:26:17,794 --> 00:26:19,270
OK.

652
00:26:19,270 --> 00:26:22,010
So first we're going to start
off with our timeline.

653
00:26:22,010 --> 00:26:24,070
And you see that I'm
on the memory here.

654
00:26:24,070 --> 00:26:27,170
And let's go ahead and we'll
just look at dom node count to

655
00:26:27,170 --> 00:26:29,200
not confuse ourselves.

656
00:26:29,200 --> 00:26:30,280
And let's see.

657
00:26:30,280 --> 00:26:33,540
I said we have a cache
of size 5.

658
00:26:33,540 --> 00:26:35,100
One thing we should always
do is refresh.

659
00:26:35,100 --> 00:26:38,110
Make sure you're starting
with a clean slate.

660
00:26:38,110 --> 00:26:42,350
And we'll go ahead and read
those 5 messages.

661
00:26:42,350 --> 00:26:44,310
So we've now filled
up our cache.

662
00:26:44,310 --> 00:26:49,810
Let's read 5 more, and we'll do
a full garbage collection.

663
00:26:49,810 --> 00:26:51,776
JOHN MCCUTCHAN: Are we going
to start recording?

664
00:26:51,776 --> 00:26:52,260
LOREENA LEE: Oh, yes.

665
00:26:52,260 --> 00:26:53,680
We do need to be recording.

666
00:26:53,680 --> 00:26:54,070
OK.

667
00:26:54,070 --> 00:26:55,550
So the cache is full.

668
00:26:55,550 --> 00:27:01,590
Let's read 5 messages, let's
collect garbage, and let's

669
00:27:01,590 --> 00:27:03,680
stop the recording.

670
00:27:03,680 --> 00:27:07,390
So you see the blue bar at the
top shows you how much memory

671
00:27:07,390 --> 00:27:08,090
is being used.

672
00:27:08,090 --> 00:27:09,340
And we see this stairstep.

673
00:27:09,340 --> 00:27:11,760

674
00:27:11,760 --> 00:27:14,740
This is when I clicked
the next message.

675
00:27:14,740 --> 00:27:17,480
You see there'll
be five steps.

676
00:27:17,480 --> 00:27:20,210
And you know, I'm pretty sure
I clicked that garbage can

677
00:27:20,210 --> 00:27:23,130
button, but I'm not seeing the
dom node count drop down.

678
00:27:23,130 --> 00:27:23,640
JOHN MCCUTCHAN: Yeah.

679
00:27:23,640 --> 00:27:25,900
LOREENA LEE: So let's try it
again, just to make sure.

680
00:27:25,900 --> 00:27:27,010
I'll record.

681
00:27:27,010 --> 00:27:28,260
Read 5 more messages.

682
00:27:28,260 --> 00:27:32,480

683
00:27:32,480 --> 00:27:34,860
Click that.

684
00:27:34,860 --> 00:27:38,720
I'll expand it.

685
00:27:38,720 --> 00:27:40,460
It's dropping down, but
not quite as far as

686
00:27:40,460 --> 00:27:41,410
I expected it to.

687
00:27:41,410 --> 00:27:44,175
I expected it to be down
to the baseline.

688
00:27:44,175 --> 00:27:46,895
Our cache was already full, and
we've still got some dom

689
00:27:46,895 --> 00:27:47,910
nodes here.

690
00:27:47,910 --> 00:27:51,670
So now we're going to go over
to the Profile Panel, see if

691
00:27:51,670 --> 00:27:54,060
we can figure out
what's going on.

692
00:27:54,060 --> 00:27:56,560
Let's refresh, start
from the beginning.

693
00:27:56,560 --> 00:27:59,930
So this new Object Tracker, the
last one here, it's called

694
00:27:59,930 --> 00:28:00,980
Track Allocations.

695
00:28:00,980 --> 00:28:04,010
So this will run the heap
profiler continuously and

696
00:28:04,010 --> 00:28:06,620
collect these snapshots
periodically while we're

697
00:28:06,620 --> 00:28:08,200
interacting with our app.

698
00:28:08,200 --> 00:28:10,750
So we'll start this.

699
00:28:10,750 --> 00:28:16,150
And let's go ahead and
read 10 messages.

700
00:28:16,150 --> 00:28:19,560
7, 8, 9, 10.

701
00:28:19,560 --> 00:28:23,420
And we'll go ahead
and stop it.

702
00:28:23,420 --> 00:28:25,440
So once the snapshot is
loaded, we should

703
00:28:25,440 --> 00:28:26,470
see these 10 bars.

704
00:28:26,470 --> 00:28:29,990
1, 2, 3, 4, 5, 6, 7, 8, 9, 10.

705
00:28:29,990 --> 00:28:34,300
We know our cache is
of size 5, right?

706
00:28:34,300 --> 00:28:36,580
So here we see the total.

707
00:28:36,580 --> 00:28:38,420
Let's scroll this up so
you guys can see it

708
00:28:38,420 --> 00:28:39,670
a little bit better.

709
00:28:39,670 --> 00:28:41,690

710
00:28:41,690 --> 00:28:43,780
So we see these last 5 messages
that we read, and

711
00:28:43,780 --> 00:28:44,820
those are all blue.

712
00:28:44,820 --> 00:28:47,100
So we know that these are still
objects that are live in

713
00:28:47,100 --> 00:28:50,990
the graph at the end of this
whole timeline capture.

714
00:28:50,990 --> 00:28:53,030
But now we have this one blue
bar, this third one

715
00:28:53,030 --> 00:28:54,630
here, and it's blue.

716
00:28:54,630 --> 00:28:57,150
I'm expecting that we only have
5 messages in our cache,

717
00:28:57,150 --> 00:28:58,940
and I see that there's
something

718
00:28:58,940 --> 00:29:00,330
strange going on here.

719
00:29:00,330 --> 00:29:05,530
If we look at this message Aux
Data, which is our message

720
00:29:05,530 --> 00:29:07,790
headers, we actually can
look here we can

721
00:29:07,790 --> 00:29:08,620
see the object count.

722
00:29:08,620 --> 00:29:09,600
And there's 6.

723
00:29:09,600 --> 00:29:11,635
That confuses me, because I
expected that we had a cache

724
00:29:11,635 --> 00:29:14,070
of size 5, so I don't know why
we still have this sixth

725
00:29:14,070 --> 00:29:16,500
message that didn't
get collected.

726
00:29:16,500 --> 00:29:20,860
So we can actually zoom in
on any of these bars.

727
00:29:20,860 --> 00:29:23,190
And we can see exactly
the objects that were

728
00:29:23,190 --> 00:29:24,210
found in the diff.

729
00:29:24,210 --> 00:29:26,850
Basically, this is a diff
between this blue bar and the

730
00:29:26,850 --> 00:29:28,310
previous snapshot.

731
00:29:28,310 --> 00:29:30,180
We see that these objects
are still live.

732
00:29:30,180 --> 00:29:31,920
They're showing up here because
they're still live in

733
00:29:31,920 --> 00:29:35,250
the heap at the end of
this full timeline.

734
00:29:35,250 --> 00:29:37,820
So if I look at one of
these first ones--

735
00:29:37,820 --> 00:29:39,742
That's probably not a good one
because it's got some extra

736
00:29:39,742 --> 00:29:40,340
code in there.

737
00:29:40,340 --> 00:29:42,830
If I look at one of these here
that's all grey, we'll see

738
00:29:42,830 --> 00:29:43,490
nothing here.

739
00:29:43,490 --> 00:29:46,290
And this means that everything
that was found in this diff of

740
00:29:46,290 --> 00:29:49,330
snapshot, this snapshot that
was taken here, any new

741
00:29:49,330 --> 00:29:51,370
allocations here have since been
very garbage collected.

742
00:29:51,370 --> 00:29:52,500
And that's what we expect.

743
00:29:52,500 --> 00:29:55,240
But here we have this blue
bar, which confuses us.

744
00:29:55,240 --> 00:29:56,250
So let's take a look.

745
00:29:56,250 --> 00:29:58,330
We see that there's a message
Aux.Data here.

746
00:29:58,330 --> 00:30:01,830
We have a html div element
that's sticking around.

747
00:30:01,830 --> 00:30:04,280
And so we want to kind of see
what's retaining this.

748
00:30:04,280 --> 00:30:06,150
What's the retaining path
to these objects?

749
00:30:06,150 --> 00:30:09,250

750
00:30:09,250 --> 00:30:13,420
So we see here that the
retaining path has this saved

751
00:30:13,420 --> 00:30:14,620
messages array.

752
00:30:14,620 --> 00:30:17,290
So this is index 0 in the
saved messages array.

753
00:30:17,290 --> 00:30:20,130
And what we see here is that
we actually have some extra

754
00:30:20,130 --> 00:30:22,980
array that's not a cache that's
holding on to this

755
00:30:22,980 --> 00:30:24,590
extra message, and
that's causing

756
00:30:24,590 --> 00:30:26,350
it to not be collected.

757
00:30:26,350 --> 00:30:29,170
And so we can actually go back
to the source and look and see

758
00:30:29,170 --> 00:30:32,050
what this saved messages array
is in this case and go ahead

759
00:30:32,050 --> 00:30:33,465
and make sure that we free
that reference up.

760
00:30:33,465 --> 00:30:35,010
And that will cause this
to get collected.

761
00:30:35,010 --> 00:30:35,350
JOHN MCCUTCHAN: Yeah.

762
00:30:35,350 --> 00:30:40,450
You can use the view of the
retaining path down here as a

763
00:30:40,450 --> 00:30:44,570
clue to where in your source
code this object was allocated

764
00:30:44,570 --> 00:30:46,680
and where it probably should
be cleaned up.

765
00:30:46,680 --> 00:30:47,390
LOREENA LEE: Right.

766
00:30:47,390 --> 00:30:49,930
Right.

767
00:30:49,930 --> 00:30:52,875
So that's the Object Tracker.

768
00:30:52,875 --> 00:30:57,230

769
00:30:57,230 --> 00:30:59,280
Let's go back and see was
this really worth it.

770
00:30:59,280 --> 00:31:01,420
This is kind of a lot of work,
especially if you think about

771
00:31:01,420 --> 00:31:03,000
an application of Gmail size.

772
00:31:03,000 --> 00:31:05,910
The JavaScript is actually huge,
so going through and

773
00:31:05,910 --> 00:31:08,680
performing these techniques
actually can take some time.

774
00:31:08,680 --> 00:31:10,340
But was it really worth it?

775
00:31:10,340 --> 00:31:12,590
And I'd say a resounding yes.

776
00:31:12,590 --> 00:31:15,040
This is the data that we
collected using the

777
00:31:15,040 --> 00:31:17,260
performance memory API that
I mentioned earlier.

778
00:31:17,260 --> 00:31:18,930
This is actually a
graph of about a

779
00:31:18,930 --> 00:31:20,510
10month period in 2012.

780
00:31:20,510 --> 00:31:22,820
If you look far to the left,
you can see that memory was

781
00:31:22,820 --> 00:31:24,990
actually really far
out of control.

782
00:31:24,990 --> 00:31:26,070
JOHN MCCUTCHAN: And the
scale here is just

783
00:31:26,070 --> 00:31:27,690
relative to the median?

784
00:31:27,690 --> 00:31:28,530
LOREENA LEE: Right.

785
00:31:28,530 --> 00:31:31,470
Well, it's relative to
itself, I guess.

786
00:31:31,470 --> 00:31:32,140
Yeah.

787
00:31:32,140 --> 00:31:34,840
So the green line on the bottom
is actually the median.

788
00:31:34,840 --> 00:31:37,680
And the blue line up at the top
is the 99th percentile.

789
00:31:37,680 --> 00:31:40,050
So the blue line represents
mostly our power users.

790
00:31:40,050 --> 00:31:42,390
And you can see that for our
power users we've actually

791
00:31:42,390 --> 00:31:47,020
reduced memory in this 10-month
period by 80%, or

792
00:31:47,020 --> 00:31:48,330
more, actually.

793
00:31:48,330 --> 00:31:50,260
And for our median users--

794
00:31:50,260 --> 00:31:51,360
it's hard to tell on
this graph, just

795
00:31:51,360 --> 00:31:52,860
because of the scale--

796
00:31:52,860 --> 00:31:55,060
we actually reduced the amount
of memory that our median

797
00:31:55,060 --> 00:31:57,933
users was using by over 50%.

798
00:31:57,933 --> 00:31:58,780
JOHN MCCUTCHAN: Nice.

799
00:31:58,780 --> 00:32:00,660
LOREENA LEE: And you'll
see there's these two

800
00:32:00,660 --> 00:32:01,850
peaks on the blue line.

801
00:32:01,850 --> 00:32:04,470
And they're there on the other
lines as well, but the scale

802
00:32:04,470 --> 00:32:05,950
is not quite as obvious.

803
00:32:05,950 --> 00:32:08,560
And what these are actually
showing us is two regressions

804
00:32:08,560 --> 00:32:11,480
that we found that were in
Chrome itself, not in Gmail.

805
00:32:11,480 --> 00:32:13,350
JOHN MCCUTCHAN: So you
found bugs in V8?

806
00:32:13,350 --> 00:32:15,980
LOREENA LEE: We actually did
find some bugs in V8.

807
00:32:15,980 --> 00:32:17,200
And then these particular
cases, they were

808
00:32:17,200 --> 00:32:18,140
fragmentation bugs.

809
00:32:18,140 --> 00:32:20,960
So the garbage collector was
actually collecting garbage,

810
00:32:20,960 --> 00:32:23,590
but it was so fragmented and
in these tiny little chunks

811
00:32:23,590 --> 00:32:26,270
that Gmail wasn't able to use
them for new allocations.

812
00:32:26,270 --> 00:32:28,980
So what we noticed here was that
we mentioned there were

813
00:32:28,980 --> 00:32:30,800
three values that are being
reported by the

814
00:32:30,800 --> 00:32:32,150
performance.memory API.

815
00:32:32,150 --> 00:32:35,380
One of them was totalJSHeapSize,
which was the

816
00:32:35,380 --> 00:32:37,830
memory in use plus
the free space.

817
00:32:37,830 --> 00:32:41,530
And then there was the
usedJSHeapSize, which was the

818
00:32:41,530 --> 00:32:42,140
live objects.

819
00:32:42,140 --> 00:32:43,480
And we noticed that the
gap between these

820
00:32:43,480 --> 00:32:44,740
two lines was growing.

821
00:32:44,740 --> 00:32:46,680
So that's how we've realized
that it wasn't actually a

822
00:32:46,680 --> 00:32:49,350
Gmail problem that was causing
these two peaks.

823
00:32:49,350 --> 00:32:49,730
JOHN MCCUTCHAN: Yeah.

824
00:32:49,730 --> 00:32:51,860
LOREENA LEE: So once those were
fixed, we got things back

825
00:32:51,860 --> 00:32:52,580
under control.

826
00:32:52,580 --> 00:32:55,270
And we're in a pretty good
place right now.

827
00:32:55,270 --> 00:32:56,520
JOHN MCCUTCHAN: Looks like it.

828
00:32:56,520 --> 00:32:58,960

829
00:32:58,960 --> 00:33:01,640
LOREENA LEE: Really, what we're
asking of everybody in

830
00:33:01,640 --> 00:33:06,370
this room, and hopefully beyond,
is to think about how

831
00:33:06,370 --> 00:33:09,280
your memory usage is affecting
your performance.

832
00:33:09,280 --> 00:33:13,490
And we recall that the higher
the memory footprint, the

833
00:33:13,490 --> 00:33:16,130
longer the latencies were and
the wider the variance.

834
00:33:16,130 --> 00:33:18,800
And so, really, these
GC pauses can be

835
00:33:18,800 --> 00:33:22,270
an performance killer.

836
00:33:22,270 --> 00:33:25,440
So ask yourself these questions
about your app.

837
00:33:25,440 --> 00:33:27,050
How much memory is
your page using?

838
00:33:27,050 --> 00:33:30,020
Are you using an amount of
memory that is reasonable for

839
00:33:30,020 --> 00:33:30,890
the size of your app?

840
00:33:30,890 --> 00:33:33,290
If you have a small, not so
interactive app, and you're

841
00:33:33,290 --> 00:33:36,820
using hundreds of megabytes of
memory, you're probably not

842
00:33:36,820 --> 00:33:39,130
using things most efficiently.

843
00:33:39,130 --> 00:33:40,950
JOHN MCCUTCHAN: Even for Gmail,
you were able to reduce

844
00:33:40,950 --> 00:33:44,940
memory usage for the 99th
percentile by 80% without

845
00:33:44,940 --> 00:33:46,480
impacting performance,
I imagine.

846
00:33:46,480 --> 00:33:47,950
LOREENA LEE: Well, without
negatively impacting

847
00:33:47,950 --> 00:33:48,300
performance.

848
00:33:48,300 --> 00:33:48,650
JOHN MCCUTCHAN: Yes.

849
00:33:48,650 --> 00:33:48,790
[INAUDIBLE]

850
00:33:48,790 --> 00:33:51,690
LOREENA LEE: We actually did
see a modest improvement in

851
00:33:51,690 --> 00:33:52,120
our latencies.

852
00:33:52,120 --> 00:33:54,550
And so it really does
make a difference.

853
00:33:54,550 --> 00:33:57,440
For Gmail, latencies are
hard to tell sometimes.

854
00:33:57,440 --> 00:34:00,700
But for the 99th percentile,
seeing a 10% improvement in

855
00:34:00,700 --> 00:34:02,745
latency is a big deal for us.

856
00:34:02,745 --> 00:34:04,140
JOHN MCCUTCHAN: Yeah.

857
00:34:04,140 --> 00:34:06,330
LOREENA LEE: So is your
page leak-free?

858
00:34:06,330 --> 00:34:09,550
When you first load your page,
versus after a day, after two

859
00:34:09,550 --> 00:34:14,070
days, after a week, is
the memory staying in

860
00:34:14,070 --> 00:34:15,239
a reasonable size?

861
00:34:15,239 --> 00:34:16,460
Is it growing over time?

862
00:34:16,460 --> 00:34:20,060
Or are you leaking memory
that you shouldn't be?

863
00:34:20,060 --> 00:34:21,790
And how frequently
are you GCing?

864
00:34:21,790 --> 00:34:24,190
We showed you some tools that
you can use to figure out how

865
00:34:24,190 --> 00:34:27,130
frequently you are GCing and
if those GC pauses are

866
00:34:27,130 --> 00:34:27,950
affecting your performance.

867
00:34:27,950 --> 00:34:28,340
JOHN MCCUTCHAN: Yeah.

868
00:34:28,340 --> 00:34:33,250
If you're seeing a lot of GCs,
that probably indicates that

869
00:34:33,250 --> 00:34:36,250
you're just allocating a ton of
objects inside JavaScript,

870
00:34:36,250 --> 00:34:38,580
which you likely don't
need to be doing.

871
00:34:38,580 --> 00:34:41,310
So that's just another indicator
that maybe there's a

872
00:34:41,310 --> 00:34:44,560
different way to structure your
page or your site so that

873
00:34:44,560 --> 00:34:48,969
the performance impact of
GCs can be lessened.

874
00:34:48,969 --> 00:34:50,219
LOREENA LEE: Right.

875
00:34:50,219 --> 00:34:52,810

876
00:34:52,810 --> 00:34:54,790
And then we showed you
a bunch of tools.

877
00:34:54,790 --> 00:34:57,150
The Chrome Developer Tools
really are getting better and

878
00:34:57,150 --> 00:34:57,920
better every day.

879
00:34:57,920 --> 00:34:59,800
We have some really great
documentation on

880
00:34:59,800 --> 00:35:02,320
developers.google.com that
you can check out.

881
00:35:02,320 --> 00:35:04,630
There's a lot of tutorials on
there that you can use to get

882
00:35:04,630 --> 00:35:06,920
an introduction to
these tools.

883
00:35:06,920 --> 00:35:09,070
We'll actually also be
publishing an article that

884
00:35:09,070 --> 00:35:11,630
goes with this talk, so you can
get more information on

885
00:35:11,630 --> 00:35:14,850
how to enable the Object
Tracker and try it out.

886
00:35:14,850 --> 00:35:17,490
We'll also send you a
link to our demo, so

887
00:35:17,490 --> 00:35:20,000
you can follow along.

888
00:35:20,000 --> 00:35:20,480
JOHN MCCUTCHAN: Yeah.

889
00:35:20,480 --> 00:35:21,880
You can try this out yourself.

890
00:35:21,880 --> 00:35:24,000
You can try the continuous
snapshot technique.

891
00:35:24,000 --> 00:35:27,680
And the article will be
available next week.

892
00:35:27,680 --> 00:35:29,250
LOREENA LEE: And then, there's
the heap profiler.

893
00:35:29,250 --> 00:35:31,750
There's the Object Tracker
that we just showed.

894
00:35:31,750 --> 00:35:33,180
And play around with
everything.

895
00:35:33,180 --> 00:35:34,490
The Timeline is really cool.

896
00:35:34,490 --> 00:35:36,090
You can see, really,
everything that

897
00:35:36,090 --> 00:35:36,750
your page is doing.

898
00:35:36,750 --> 00:35:38,360
When you refresh it,
you can see how the

899
00:35:38,360 --> 00:35:40,380
page actually displays.

900
00:35:40,380 --> 00:35:42,790
There's a lot of great talks
this week that you guys should

901
00:35:42,790 --> 00:35:45,030
try to attend as many as you
can just to get more

902
00:35:45,030 --> 00:35:46,280
information.

903
00:35:46,280 --> 00:35:47,980

904
00:35:47,980 --> 00:35:48,456
All right.

905
00:35:48,456 --> 00:35:49,410
That's it.

906
00:35:49,410 --> 00:35:49,970
Thank you.

907
00:35:49,970 --> 00:35:51,220
JOHN MCCUTCHAN: Thanks,
everyone.

908
00:35:51,220 --> 00:35:56,940

909
00:35:56,940 --> 00:36:01,160
So for reference, there's a
link to the demo source.

910
00:36:01,160 --> 00:36:03,770
You can just hit it
with your browser.

911
00:36:03,770 --> 00:36:07,610
And here are the instructions
on how to enable this Object

912
00:36:07,610 --> 00:36:08,860
Tracker today.

913
00:36:08,860 --> 00:36:11,600

914
00:36:11,600 --> 00:36:12,920
We can take questions.

915
00:36:12,920 --> 00:36:18,800
And be sure to rate the
talk using the app.

916
00:36:18,800 --> 00:36:21,420
AUDIENCE: Hi.

917
00:36:21,420 --> 00:36:25,340
Well, in an ideal world, your
application should not have

918
00:36:25,340 --> 00:36:25,820
memory leaks.

919
00:36:25,820 --> 00:36:27,700
But there's no ideal
world yet.

920
00:36:27,700 --> 00:36:32,340
And so my question is, is it
possible to have some kind of

921
00:36:32,340 --> 00:36:37,380
listener with JavaScript that,
once your application is about

922
00:36:37,380 --> 00:36:41,360
to hit a memory leak, with
JavaScript you will know about

923
00:36:41,360 --> 00:36:45,960
it, and instead of showing this
or that Jim page, you can

924
00:36:45,960 --> 00:36:49,600
take some actions before
actually losing everything?

925
00:36:49,600 --> 00:36:50,640
JOHN MCCUTCHAN: For those of
you who couldn't hear, the

926
00:36:50,640 --> 00:36:54,840
question was, could there be an
event channel that signals

927
00:36:54,840 --> 00:36:55,910
that a memory leak
has occurred?

928
00:36:55,910 --> 00:36:57,105
Is that correct?

929
00:36:57,105 --> 00:36:58,240
AUDIENCE: Is about to occur.

930
00:36:58,240 --> 00:36:59,150
JOHN MCCUTCHAN: Or
about to occur.

931
00:36:59,150 --> 00:37:00,295
Yes.

932
00:37:00,295 --> 00:37:03,810
The issue with that is that
there is no way to know the

933
00:37:03,810 --> 00:37:06,965
intention of the programmer.

934
00:37:06,965 --> 00:37:09,820
V8 can't possibly conclude that,
oh, this reference in

935
00:37:09,820 --> 00:37:13,440
the graph that's keeping this
value here is an error.

936
00:37:13,440 --> 00:37:16,040
Because maybe you actually
intended that

937
00:37:16,040 --> 00:37:17,780
reference to be there.

938
00:37:17,780 --> 00:37:21,150
Although it would be nice to
maybe have some event channels

939
00:37:21,150 --> 00:37:23,250
that tell you when you're
getting close--

940
00:37:23,250 --> 00:37:23,550
AUDIENCE: Yeah.

941
00:37:23,550 --> 00:37:24,820
Yeah. --to the heap
size or something.

942
00:37:24,820 --> 00:37:26,500
Yeah.

943
00:37:26,500 --> 00:37:28,040
LOREENA LEE: You could
definitely have some sort of

944
00:37:28,040 --> 00:37:31,500
listener that would poll this
performance.memory API and

945
00:37:31,500 --> 00:37:35,420
sort of see that the limit
is being approached.

946
00:37:35,420 --> 00:37:38,370
But there's not really any way
that you could say, hey, you

947
00:37:38,370 --> 00:37:40,700
know, you've been holding onto
this thing for a long time.

948
00:37:40,700 --> 00:37:41,720
Are you sure you wanted to?

949
00:37:41,720 --> 00:37:43,220
That's actually really,
really tricky.

950
00:37:43,220 --> 00:37:43,830
AUDIENCE: Oh.

951
00:37:43,830 --> 00:37:44,380
OK.

952
00:37:44,380 --> 00:37:44,990
OK, thanks.

953
00:37:44,990 --> 00:37:47,120
JOHN MCCUTCHAN: Thank you.

954
00:37:47,120 --> 00:37:49,720
AUDIENCE: So in terms of that
process that you guys went

955
00:37:49,720 --> 00:37:52,710
through last year, obviously
the example you showed here

956
00:37:52,710 --> 00:37:54,490
was ridiculously simple.

957
00:37:54,490 --> 00:37:57,270
So there's kind of like, OK,
we have a memory leak.

958
00:37:57,270 --> 00:38:01,740
What did you find were the
common actual sources of the

959
00:38:01,740 --> 00:38:04,310
memory leaks, like the
coding patterns that

960
00:38:04,310 --> 00:38:05,210
were causing them?

961
00:38:05,210 --> 00:38:09,270
And in a code base like Gmail,
which is hundreds of thousands

962
00:38:09,270 --> 00:38:12,290
of lines of code, how would
you just narrow it down?

963
00:38:12,290 --> 00:38:14,780
You have these objects, but then
you need to know where

964
00:38:14,780 --> 00:38:17,740
these objects are getting
allocated and where the bad

965
00:38:17,740 --> 00:38:19,060
stuff is actually happening.

966
00:38:19,060 --> 00:38:19,400
LOREENA LEE: Right.

967
00:38:19,400 --> 00:38:21,670
So we had the heap profiler.

968
00:38:21,670 --> 00:38:22,950
And the Object Tracker
is brand new.

969
00:38:22,950 --> 00:38:23,960
So it would have been
really awesome to

970
00:38:23,960 --> 00:38:24,820
have that last year.

971
00:38:24,820 --> 00:38:25,245
AUDIENCE: Yeah.

972
00:38:25,245 --> 00:38:25,670
Yeah.

973
00:38:25,670 --> 00:38:26,860
LOREENA LEE: That would have
made things a lot easier.

974
00:38:26,860 --> 00:38:27,390
AUDIENCE: For sure.

975
00:38:27,390 --> 00:38:29,790
LOREENA LEE: But using the
heap profiler, there's a

976
00:38:29,790 --> 00:38:32,010
technique that you can take
multiple snapshots and compare

977
00:38:32,010 --> 00:38:32,700
them to each other.

978
00:38:32,700 --> 00:38:35,820
So we performed some actions,
and we saw that memory was

979
00:38:35,820 --> 00:38:37,490
growing when we did something
as simple

980
00:38:37,490 --> 00:38:38,970
as compose and discard.

981
00:38:38,970 --> 00:38:42,080
If you compose a message and you
discard it, once the Undo

982
00:38:42,080 --> 00:38:42,620
[? butterbar ?]

983
00:38:42,620 --> 00:38:45,610
disappears, we really expected
that there should be nothing

984
00:38:45,610 --> 00:38:46,780
left over from that action.

985
00:38:46,780 --> 00:38:49,950
And so we could perform
something like that and then

986
00:38:49,950 --> 00:38:53,850
do these comparisons between
multiple heap profiles, heap

987
00:38:53,850 --> 00:38:57,630
snapshots, and see
what's lingering.

988
00:38:57,630 --> 00:39:00,040
And in those cases, we could
find certain objects, and we

989
00:39:00,040 --> 00:39:03,100
could look for those particular
objects that were

990
00:39:03,100 --> 00:39:04,400
being left behind.

991
00:39:04,400 --> 00:39:06,650
So that was one of them.

992
00:39:06,650 --> 00:39:09,650
I would say we have a few
different categories of bugs

993
00:39:09,650 --> 00:39:10,430
that we found.

994
00:39:10,430 --> 00:39:15,420
One of them was things like
infinitely growing caches, so

995
00:39:15,420 --> 00:39:17,350
things where we were saving
references to things that we

996
00:39:17,350 --> 00:39:19,010
didn't mean to.

997
00:39:19,010 --> 00:39:21,810
One case, we had a list of
callbacks that were supposed

998
00:39:21,810 --> 00:39:25,280
to be invoked when a particular
action occurred.

999
00:39:25,280 --> 00:39:26,890
And that action never occurred,
so we had an

1000
00:39:26,890 --> 00:39:30,780
infinitely growing list
of callbacks.

1001
00:39:30,780 --> 00:39:33,310
There was also a bunch of
cases where we had event

1002
00:39:33,310 --> 00:39:35,970
listeners attached to
particular objects.

1003
00:39:35,970 --> 00:39:38,050
And the event listener
was acting as a

1004
00:39:38,050 --> 00:39:41,610
reference on those objects.

1005
00:39:41,610 --> 00:39:42,900
The reason why I didn't
mention it here

1006
00:39:42,900 --> 00:39:44,660
is the Closure team--

1007
00:39:44,660 --> 00:39:47,150
we use the Closure Compiler--

1008
00:39:47,150 --> 00:39:49,940
they've gone through some really
amazing hoops to try to

1009
00:39:49,940 --> 00:39:53,020
eliminate this particular
coding problem.

1010
00:39:53,020 --> 00:39:56,350
And so if you do use Closure and
you do have this problem

1011
00:39:56,350 --> 00:39:58,870
where you have event listeners
that are causing references to

1012
00:39:58,870 --> 00:40:02,440
particular objects sticking
around, newer versions of

1013
00:40:02,440 --> 00:40:04,362
Closure should eliminate
that problem for you.

1014
00:40:04,362 --> 00:40:04,834
AUDIENCE: OK.

1015
00:40:04,834 --> 00:40:05,306
Great, thanks.

1016
00:40:05,306 --> 00:40:07,790
JOHN MCCUTCHAN: Thanks.

1017
00:40:07,790 --> 00:40:11,050
AUDIENCE: What would be the
ideal size for the young space

1018
00:40:11,050 --> 00:40:13,355
to avoid frequent GC pause?

1019
00:40:13,355 --> 00:40:15,160
How would you determine that?

1020
00:40:15,160 --> 00:40:18,200
JOHN MCCUTCHAN: Well, the ideal
size would be infinite.

1021
00:40:18,200 --> 00:40:20,220
You could just have it
grow forever, and

1022
00:40:20,220 --> 00:40:22,610
you'd never GC pause.

1023
00:40:22,610 --> 00:40:27,510
It's actually very difficult to
find that sweet spot of a

1024
00:40:27,510 --> 00:40:30,190
practical number.

1025
00:40:30,190 --> 00:40:34,420
So that's a difficult
question.

1026
00:40:34,420 --> 00:40:36,300
There's not a straightforward
answer to it, I suppose.

1027
00:40:36,300 --> 00:40:36,790
AUDIENCE: OK.

1028
00:40:36,790 --> 00:40:39,070
So if I can actually
tack this on.

1029
00:40:39,070 --> 00:40:40,120
JOHN MCCUTCHAN: Sure.

1030
00:40:40,120 --> 00:40:43,860
AUDIENCE: In the GC pause that
you showed, freeing up two

1031
00:40:43,860 --> 00:40:47,955
objects had enough room for E.
If there wasn't enough room

1032
00:40:47,955 --> 00:40:52,730
for E, in that case would
that flush to old?

1033
00:40:52,730 --> 00:40:53,420
JOHN MCCUTCHAN: No.

1034
00:40:53,420 --> 00:40:54,460
Young generation.

1035
00:40:54,460 --> 00:40:57,720
Collection occurs without an
old generation collection.

1036
00:40:57,720 --> 00:41:00,080
AUDIENCE: But if the flushing
two objects didn't have enough

1037
00:41:00,080 --> 00:41:00,820
room for E?

1038
00:41:00,820 --> 00:41:01,580
JOHN MCCUTCHAN: Oh, I see.

1039
00:41:01,580 --> 00:41:02,170
Yeah.

1040
00:41:02,170 --> 00:41:06,530
At that point, you would fall
back to we have to do a full

1041
00:41:06,530 --> 00:41:09,120
collection and try
and free memory.

1042
00:41:09,120 --> 00:41:09,520
Yes.

1043
00:41:09,520 --> 00:41:09,975
AUDIENCE: OK.

1044
00:41:09,975 --> 00:41:10,430
Good.

1045
00:41:10,430 --> 00:41:12,270
Thanks.

1046
00:41:12,270 --> 00:41:13,272
JOHN MCCUTCHAN: Thanks.

1047
00:41:13,272 --> 00:41:13,446
Yeah.

1048
00:41:13,446 --> 00:41:13,620
Hey.

1049
00:41:13,620 --> 00:41:16,760
AUDIENCE: So some of the graphs
you showed with the

1050
00:41:16,760 --> 00:41:19,090
Gmail performance with the
different percentiles, that's

1051
00:41:19,090 --> 00:41:22,010
actually awesome.

1052
00:41:22,010 --> 00:41:25,780
So do you have any tips for
building tools like that?

1053
00:41:25,780 --> 00:41:28,450
Are there any tools that you
know of that can help monitor

1054
00:41:28,450 --> 00:41:31,090
your users in production?

1055
00:41:31,090 --> 00:41:32,590
LOREENA LEE: You can actually
just call the

1056
00:41:32,590 --> 00:41:35,290
performance.memory API
from your application

1057
00:41:35,290 --> 00:41:36,000
at any given time.

1058
00:41:36,000 --> 00:41:36,790
[INAUDIBLE].

1059
00:41:36,790 --> 00:41:41,140
AUDIENCE: And that's for memory
and UI latency as well?

1060
00:41:41,140 --> 00:41:43,710
LOREENA LEE: The latency is a
totally separate tracker.

1061
00:41:43,710 --> 00:41:45,600
We have a separate tracker.

1062
00:41:45,600 --> 00:41:46,750
We're actually out of
time, but we're

1063
00:41:46,750 --> 00:41:49,180
happy to stick around.

1064
00:41:49,180 --> 00:41:51,260
We'll probably head upstairs
to the Chrome

1065
00:41:51,260 --> 00:41:54,050
office hours area.

1066
00:41:54,050 --> 00:41:56,920
JOHN MCCUTCHAN: So anyone who
still has questions, you can

1067
00:41:56,920 --> 00:41:59,830
just meet up upstairs in like
10 minutes, and we'll take

1068
00:41:59,830 --> 00:42:00,450
questions there.

1069
00:42:00,450 --> 00:42:02,030
LOREENA LEE: But the short
answer is that latency we

1070
00:42:02,030 --> 00:42:04,330
track completely separately.

1071
00:42:04,330 --> 00:42:05,350
JOHN MCCUTCHAN: Thank
you, everyone.

1072
00:42:05,350 --> 00:42:06,600
LOREENA LEE: Thank you.

1073
00:42:06,600 --> 00:42:09,743

