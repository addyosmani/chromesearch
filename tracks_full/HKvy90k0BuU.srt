1
00:00:00,000 --> 00:00:03,110
JAMES HAWKINS: My name
is James Hawkins.

2
00:00:03,110 --> 00:00:05,510
I'm the tech lead of the Chrome
team in Los Angeles.

3
00:00:05,510 --> 00:00:08,930
And for the past year, we've
been working very closely with

4
00:00:08,930 --> 00:00:12,590
the Google+ Photos team on a new
product that's the Google+

5
00:00:12,590 --> 00:00:14,090
Photos Chrome app.

6
00:00:14,090 --> 00:00:17,240
So this is a Chrome
packaged app.

7
00:00:17,240 --> 00:00:20,120
And if you'll remember, packaged
apps were announced a

8
00:00:20,120 --> 00:00:21,540
little over a year ago.

9
00:00:21,540 --> 00:00:27,870
And this is the key piece of
Chrome's app platform.

10
00:00:27,870 --> 00:00:30,880
Packaged apps give you the
ability to have extended

11
00:00:30,880 --> 00:00:32,520
permissions, you can do
a little bit more.

12
00:00:32,520 --> 00:00:35,920
You can have a more native look
and feel with your app.

13
00:00:35,920 --> 00:00:37,420
It's a step above what
you can do with the

14
00:00:37,420 --> 00:00:39,140
web platform today.

15
00:00:39,140 --> 00:00:42,330
So we're going to talk about
Google+ Photos Chrome app.

16
00:00:42,330 --> 00:00:43,450
Actually, instead of
talking about it,

17
00:00:43,450 --> 00:00:45,160
let's cut to the demo.

18
00:00:45,160 --> 00:00:58,030

19
00:00:58,030 --> 00:01:01,240
So this is Google+ Photos,
the Chrome app.

20
00:01:01,240 --> 00:01:02,980
This is my personal account.

21
00:01:02,980 --> 00:01:05,720
I've got all my photos
loaded up into it.

22
00:01:05,720 --> 00:01:07,450
We're doing some
nice scrolling.

23
00:01:07,450 --> 00:01:09,500
And if you note, I'm on
a Pixel right here.

24
00:01:09,500 --> 00:01:11,850
So we obviously have touchscreen
capabilities to do

25
00:01:11,850 --> 00:01:14,170
scrolling with this.

26
00:01:14,170 --> 00:01:16,230
OK, so we're viewing
some photos.

27
00:01:16,230 --> 00:01:19,480
Let's say I want to go in and
check out a particular photo.

28
00:01:19,480 --> 00:01:21,770
All right, I've got this photo,
and I've got my nice

29
00:01:21,770 --> 00:01:24,620
information, my tags,
and details.

30
00:01:24,620 --> 00:01:27,280
Very neat.

31
00:01:27,280 --> 00:01:30,060
But I just went and used my
camera and took a bunch of

32
00:01:30,060 --> 00:01:32,510
pictures, and I've got
it on an SD card.

33
00:01:32,510 --> 00:01:34,030
I'd like to upload these
to the Cloud.

34
00:01:34,030 --> 00:01:34,960
I want to share with
my friends.

35
00:01:34,960 --> 00:01:36,210
So let's go ahead and do that.

36
00:01:36,210 --> 00:01:44,190

37
00:01:44,190 --> 00:01:45,440
Close this.

38
00:01:45,440 --> 00:01:48,010

39
00:01:48,010 --> 00:01:49,600
So here we go.

40
00:01:49,600 --> 00:01:51,260
The app was already open.

41
00:01:51,260 --> 00:01:53,360
And it's already started
importing photos, and it's

42
00:01:53,360 --> 00:01:55,490
going to start uploading them.

43
00:01:55,490 --> 00:01:59,960
We can view the ones that
are on this SD card.

44
00:01:59,960 --> 00:02:00,380
Cool.

45
00:02:00,380 --> 00:02:02,110
So these are the pictures
that I just took.

46
00:02:02,110 --> 00:02:05,080
Got a little notification that
we had some photos copied, and

47
00:02:05,080 --> 00:02:06,330
they're being uploaded
right now.

48
00:02:06,330 --> 00:02:10,110

49
00:02:10,110 --> 00:02:12,130
We got a notification that we're
finding the best photos,

50
00:02:12,130 --> 00:02:13,620
and there we go.

51
00:02:13,620 --> 00:02:15,700
What you just saw is something
that you heard

52
00:02:15,700 --> 00:02:17,150
about in the keynote.

53
00:02:17,150 --> 00:02:18,530
This is autocuration.

54
00:02:18,530 --> 00:02:22,110
So in the back end, Google said,
we're looking at your

55
00:02:22,110 --> 00:02:24,250
photos, we want to see what
are the best photos of the

56
00:02:24,250 --> 00:02:25,380
ones you just took.

57
00:02:25,380 --> 00:02:29,090
Let's make it very simple for
you to share the best photos

58
00:02:29,090 --> 00:02:30,810
that you have with your
friends, your

59
00:02:30,810 --> 00:02:32,250
families, et cetera.

60
00:02:32,250 --> 00:02:35,340
For example, this photo
has been deemed to be

61
00:02:35,340 --> 00:02:36,680
underexposed.

62
00:02:36,680 --> 00:02:37,030
Cool.

63
00:02:37,030 --> 00:02:37,290
All right.

64
00:02:37,290 --> 00:02:38,400
That's fine.

65
00:02:38,400 --> 00:02:39,220
I'm not too picky.

66
00:02:39,220 --> 00:02:40,700
I just want the best
photos to go up.

67
00:02:40,700 --> 00:02:42,980
So we want to share these.

68
00:02:42,980 --> 00:02:53,720

69
00:02:53,720 --> 00:02:53,985
Cool.

70
00:02:53,985 --> 00:02:55,230
I've shared it with my family.

71
00:02:55,230 --> 00:02:56,480
Cool new photos.

72
00:02:56,480 --> 00:03:08,440

73
00:03:08,440 --> 00:03:12,250
And so these are the photos
that I just shared.

74
00:03:12,250 --> 00:03:13,500
We can change the name.

75
00:03:13,500 --> 00:03:19,960

76
00:03:19,960 --> 00:03:22,780
No, it's '13.

77
00:03:22,780 --> 00:03:24,730
It is early after all.

78
00:03:24,730 --> 00:03:26,890
Cool.

79
00:03:26,890 --> 00:03:29,280
So this is Google+ Photos.

80
00:03:29,280 --> 00:03:31,360
You've got the autocuration
magic behind the scenes.

81
00:03:31,360 --> 00:03:33,460
You've got a very
slick interface.

82
00:03:33,460 --> 00:03:36,840
Very fast viewing of
all your photos,

83
00:03:36,840 --> 00:03:38,950
just really nice scrolling.

84
00:03:38,950 --> 00:03:42,360
And we're going to talk a bit
today about what it took to

85
00:03:42,360 --> 00:03:44,320
develop this product
as a Chrome

86
00:03:44,320 --> 00:03:45,570
packaged app on the platform.

87
00:03:45,570 --> 00:03:49,432

88
00:03:49,432 --> 00:03:51,830
AUDIENCE: Is it available
in the marketplace?

89
00:03:51,830 --> 00:03:53,170
JAMES HAWKINS: This is
not available yet.

90
00:03:53,170 --> 00:03:54,420
It'll be available soon.

91
00:03:54,420 --> 00:03:56,950

92
00:03:56,950 --> 00:03:59,520
So we started developing
this product with a

93
00:03:59,520 --> 00:04:00,540
set of goals in mind.

94
00:04:00,540 --> 00:04:03,220
What did we want
to accomplish?

95
00:04:03,220 --> 00:04:06,930
When we started development, the
only way to view photos in

96
00:04:06,930 --> 00:04:10,390
Chrome OS was through the file
manager, and even then, that

97
00:04:10,390 --> 00:04:11,810
was not the best experience.

98
00:04:11,810 --> 00:04:13,720
You could do some
minimal editing.

99
00:04:13,720 --> 00:04:15,830
You couldn't really
share very easily.

100
00:04:15,830 --> 00:04:19,079
And the viewing experience
was just a stopgap.

101
00:04:19,079 --> 00:04:20,790
That's not to say,
it's not good.

102
00:04:20,790 --> 00:04:22,240
But we wanted to do
something better.

103
00:04:22,240 --> 00:04:24,170
We wanted a better photos
experience for ChromeOS.

104
00:04:24,170 --> 00:04:27,160

105
00:04:27,160 --> 00:04:30,930
In addition, we wanted a place
where the Google+ Photos team

106
00:04:30,930 --> 00:04:34,970
could experiment with new UI,
new back end functionality

107
00:04:34,970 --> 00:04:37,440
like we're talking about
with autocuration.

108
00:04:37,440 --> 00:04:42,020
In fact, autocuration was not
available to the public in the

109
00:04:42,020 --> 00:04:45,660
Google+ desktop until we just
announced it at I/O

110
00:04:45,660 --> 00:04:46,990
a couple days ago.

111
00:04:46,990 --> 00:04:50,170
And so this product was the
only place where the

112
00:04:50,170 --> 00:04:53,950
autocuration team could see
autocuration live, see how it

113
00:04:53,950 --> 00:04:56,860
worked out, get a lot of
feedback on the feature.

114
00:04:56,860 --> 00:04:59,310
And so this is going to continue
to be one of the

115
00:04:59,310 --> 00:05:02,140
places where that feature
development happens like

116
00:05:02,140 --> 00:05:03,390
sandboxed, if you will.

117
00:05:03,390 --> 00:05:06,160

118
00:05:06,160 --> 00:05:08,980
And coming from the Chrome team
side of things, we wanted

119
00:05:08,980 --> 00:05:12,500
to make sure that the platform
had everything that we needed

120
00:05:12,500 --> 00:05:15,500
in order to be very successful
and very easy for people to

121
00:05:15,500 --> 00:05:16,420
develop apps.

122
00:05:16,420 --> 00:05:17,170
What's missing?

123
00:05:17,170 --> 00:05:18,170
Could we identify it?

124
00:05:18,170 --> 00:05:20,580
What are the bugs?

125
00:05:20,580 --> 00:05:23,070
It's a very nascent platform,
and a lot of the API's that

126
00:05:23,070 --> 00:05:26,430
are being developed are even,
right now, in development.

127
00:05:26,430 --> 00:05:29,150
And we wanted to test them
out, have a user for the

128
00:05:29,150 --> 00:05:33,260
platform instead of giving it to
you guys, and you guys have

129
00:05:33,260 --> 00:05:34,210
to cut your teeth on it.

130
00:05:34,210 --> 00:05:35,870
Which is not the best
experience.

131
00:05:35,870 --> 00:05:41,340
We wanted to do that ourselves
to spare you guys some pain.

132
00:05:41,340 --> 00:05:44,020
And as a part of that, as well,
we are Chrome developers

133
00:05:44,020 --> 00:05:46,240
in addition to doing some
of this front end stuff.

134
00:05:46,240 --> 00:05:49,350
So when we did find areas that
were lacking in the platform,

135
00:05:49,350 --> 00:05:53,380
we could go in and add those
APIs that we were missing.

136
00:05:53,380 --> 00:05:55,570
And I'll talk about one of those
specifically later on.

137
00:05:55,570 --> 00:05:59,070

138
00:05:59,070 --> 00:06:03,230
So Chrome, as you know, has
three core principles.

139
00:06:03,230 --> 00:06:05,230
You want your UI
to be extremely

140
00:06:05,230 --> 00:06:06,570
quick, extremely fast.

141
00:06:06,570 --> 00:06:09,280
You want animations to be
very snappy and fluid.

142
00:06:09,280 --> 00:06:11,750
When you have jink, you have
stuttering, you have a really

143
00:06:11,750 --> 00:06:12,810
bad user experience.

144
00:06:12,810 --> 00:06:15,800
It's jarring for the user.

145
00:06:15,800 --> 00:06:19,650
Keeping your app very simple,
to me, it means

146
00:06:19,650 --> 00:06:20,430
getting out of the way.

147
00:06:20,430 --> 00:06:23,080
Get your UI out of the way of
the user, out of the way of

148
00:06:23,080 --> 00:06:24,720
what they're trying to do.

149
00:06:24,720 --> 00:06:26,780
And sometimes that is actually
the hardest thing to

150
00:06:26,780 --> 00:06:28,720
accomplish.

151
00:06:28,720 --> 00:06:30,900
Security, obviously, is
extremely important.

152
00:06:30,900 --> 00:06:34,430
You want to keep your users
secure not only from your app

153
00:06:34,430 --> 00:06:41,840
misbehaving but from malicious
attackers that can use your

154
00:06:41,840 --> 00:06:43,100
app to harm your user.

155
00:06:43,100 --> 00:06:45,870
You want to make sure that
that is not possible.

156
00:06:45,870 --> 00:06:48,010
So we took these principles to
mind when we were developing

157
00:06:48,010 --> 00:06:48,640
in the app.

158
00:06:48,640 --> 00:06:51,880
And the challenges that we faced
when developing the app

159
00:06:51,880 --> 00:06:53,495
I'm going to frame around
these core principles.

160
00:06:53,495 --> 00:06:58,970

161
00:06:58,970 --> 00:06:59,770
Speed.

162
00:06:59,770 --> 00:07:00,650
You've got to be fast.

163
00:07:00,650 --> 00:07:01,900
Everybody wants to be fast.

164
00:07:01,900 --> 00:07:04,980

165
00:07:04,980 --> 00:07:08,790
One of the first problems we
ran into was with having to

166
00:07:08,790 --> 00:07:11,890
have a client side photo and
needing to know if we needed

167
00:07:11,890 --> 00:07:12,750
to upload it or not.

168
00:07:12,750 --> 00:07:15,630
You obviously don't want to
waste bandwidth if the user

169
00:07:15,630 --> 00:07:17,530
already has that photo
in the Cloud.

170
00:07:17,530 --> 00:07:21,450
And so the way we did that is
to store SHA-512 hashes of

171
00:07:21,450 --> 00:07:24,820
these photos in the Cloud when
it was already uploaded.

172
00:07:24,820 --> 00:07:27,260
And so when we have a new photo
to upload, we have to

173
00:07:27,260 --> 00:07:29,960
calculate that hash to
say hey, do you have

174
00:07:29,960 --> 00:07:30,670
this photo or not?

175
00:07:30,670 --> 00:07:32,710
And if not, we don't
need to upload it.

176
00:07:32,710 --> 00:07:36,810

177
00:07:36,810 --> 00:07:38,990
So we have a little demo here.

178
00:07:38,990 --> 00:07:42,000
This is a quite large image.

179
00:07:42,000 --> 00:07:44,000
It's about 12 megabytes,
I think.

180
00:07:44,000 --> 00:07:46,950
And this is just one example
of what the user could be

181
00:07:46,950 --> 00:07:50,250
uploading that we need
to get the hash of.

182
00:07:50,250 --> 00:07:53,870
And we found that the JavaScript
implementation,

183
00:07:53,870 --> 00:07:57,260
while we could optimize it as
much as we possibly could, it

184
00:07:57,260 --> 00:08:00,980
could never compare to a
native implementation.

185
00:08:00,980 --> 00:08:03,380
And we got that native
implementation through Native

186
00:08:03,380 --> 00:08:05,170
Client, which allows
you to run C++

187
00:08:05,170 --> 00:08:07,110
binaries in your web app.

188
00:08:07,110 --> 00:08:10,000
It's a really amazing technology
that is extremely

189
00:08:10,000 --> 00:08:12,990
useful, especially for these use
cases where you need to do

190
00:08:12,990 --> 00:08:15,670
data processing, you want to get
bare bones as close to the

191
00:08:15,670 --> 00:08:17,240
metal as possible.

192
00:08:17,240 --> 00:08:18,530
So I'm going to do
a little demo.

193
00:08:18,530 --> 00:08:20,700
We have hashing done
in JavaScript.

194
00:08:20,700 --> 00:08:22,200
And we have hashing done
in Native Client.

195
00:08:22,200 --> 00:08:24,350
And we're going to get
the timings of those.

196
00:08:24,350 --> 00:08:25,967
And we'll see what the
difference is.

197
00:08:25,967 --> 00:08:30,170

198
00:08:30,170 --> 00:08:31,540
OK.

199
00:08:31,540 --> 00:08:34,600
Almost three seconds compared
to 200 milliseconds.

200
00:08:34,600 --> 00:08:37,330
That is an order of magnitude
difference.

201
00:08:37,330 --> 00:08:38,299
That's amazing.

202
00:08:38,299 --> 00:08:40,799
Not to mention the fact that
Native Client doesn't block

203
00:08:40,799 --> 00:08:42,190
the UI, the main thread.

204
00:08:42,190 --> 00:08:45,850
Whereas this JavaScript
implementation does.

205
00:08:45,850 --> 00:08:48,330
So if you're taking three
seconds to hash an image, your

206
00:08:48,330 --> 00:08:49,660
user is doing nothing.

207
00:08:49,660 --> 00:08:51,950
They're looking at your app
not doing anything.

208
00:08:51,950 --> 00:08:54,660
So Native Client saved
us on this one.

209
00:08:54,660 --> 00:08:58,640
And, in fact, with more
native-like apps being

210
00:08:58,640 --> 00:09:01,230
produced for the web, I think
we're going to see Native

211
00:09:01,230 --> 00:09:03,880
Client being used a
tremendous amount.

212
00:09:03,880 --> 00:09:07,080
One of the first big apps that
was done with Native Client

213
00:09:07,080 --> 00:09:08,400
was actually games.

214
00:09:08,400 --> 00:09:09,710
That makes perfect sense.

215
00:09:09,710 --> 00:09:12,850
You've got to have high, super
high performance calculating

216
00:09:12,850 --> 00:09:14,100
with a lot of data.

217
00:09:14,100 --> 00:09:21,270

218
00:09:21,270 --> 00:09:23,930
So actually, I want to go in,
and let's look at this and see

219
00:09:23,930 --> 00:09:26,480
how we hooked up with
Native Client.

220
00:09:26,480 --> 00:09:31,720

221
00:09:31,720 --> 00:09:33,020
So we're going to go into
the JavaScript.

222
00:09:33,020 --> 00:09:38,300

223
00:09:38,300 --> 00:09:42,000
And the meat of this is the
NaCl hash for the NaCl

224
00:09:42,000 --> 00:09:42,560
implementation.

225
00:09:42,560 --> 00:09:44,760
We'll ignore the JavaScript
for now.

226
00:09:44,760 --> 00:09:47,450
We're going to do document,
the element ID file_io.

227
00:09:47,450 --> 00:09:51,040
I/O. So let's go see
what that was.

228
00:09:51,040 --> 00:09:52,780
That is, I'm going to
zoom this up so you

229
00:09:52,780 --> 00:09:54,030
guys can see it.

230
00:09:54,030 --> 00:09:56,900

231
00:09:56,900 --> 00:10:00,320
That's an embed of
type X NaCl.

232
00:10:00,320 --> 00:10:04,630
This file_io.nmf is an
NaCl manifest format.

233
00:10:04,630 --> 00:10:08,140
And it specifies what
the binary is for--

234
00:10:08,140 --> 00:10:09,190
I'm not going to open it up.

235
00:10:09,190 --> 00:10:10,990
But it specifies what
the binary is

236
00:10:10,990 --> 00:10:12,880
that needs to be run.

237
00:10:12,880 --> 00:10:16,910
We communicate with this
with postMessage.

238
00:10:16,910 --> 00:10:19,620
So we postMessage the file
name, and inside the

239
00:10:19,620 --> 00:10:22,480
implementation of the NaCl
module, we take that file

240
00:10:22,480 --> 00:10:27,460
name, do the hashing on it in
C++, that's compiled, and send

241
00:10:27,460 --> 00:10:30,240
a message back through the
NaCl API to the app.

242
00:10:30,240 --> 00:10:33,020
And we handle that
message here.

243
00:10:33,020 --> 00:10:34,510
So this is essentially
how we were doing

244
00:10:34,510 --> 00:10:35,190
it in Native Client.

245
00:10:35,190 --> 00:10:36,150
It's actually really simple.

246
00:10:36,150 --> 00:10:40,680
So this is what, maybe 10
lines total of code for

247
00:10:40,680 --> 00:10:41,510
handling this.

248
00:10:41,510 --> 00:10:44,420
And C++ code on the
other side.

249
00:10:44,420 --> 00:10:47,760
The meat of it is getting the
NaCl module built, which there

250
00:10:47,760 --> 00:10:48,970
are tons of tutorials
out there.

251
00:10:48,970 --> 00:10:50,220
It's not that hard.

252
00:10:50,220 --> 00:10:59,610

253
00:10:59,610 --> 00:11:00,860
Doesn't want to full screen.

254
00:11:00,860 --> 00:11:06,170

255
00:11:06,170 --> 00:11:07,546
OK, hold on.

256
00:11:07,546 --> 00:11:20,010

257
00:11:20,010 --> 00:11:21,260
Just one second.

258
00:11:21,260 --> 00:11:28,204

259
00:11:28,204 --> 00:11:28,690
Oh, yeah.

260
00:11:28,690 --> 00:11:29,770
Thank you very much.

261
00:11:29,770 --> 00:11:31,020
I was zoomed in.

262
00:11:31,020 --> 00:11:40,120

263
00:11:40,120 --> 00:11:43,490
So the next issue that we
are running into is

264
00:11:43,490 --> 00:11:44,960
the data store layer.

265
00:11:44,960 --> 00:11:46,850
So with Photos, there
are users that

266
00:11:46,850 --> 00:11:49,350
have, say, 40,000 photos.

267
00:11:49,350 --> 00:11:50,930
This is a case that
we have to handle.

268
00:11:50,930 --> 00:11:52,300
It's very difficult.

269
00:11:52,300 --> 00:11:55,150
And the fact that this app needs
to be native, needs to

270
00:11:55,150 --> 00:11:58,570
act like a real app on your
platform, you have to have

271
00:11:58,570 --> 00:12:01,150
offline support, which means you
need to store your users'

272
00:12:01,150 --> 00:12:03,440
data locally to some degree.

273
00:12:03,440 --> 00:12:04,740
You don't have to store
everything but

274
00:12:04,740 --> 00:12:06,250
at least the metadata.

275
00:12:06,250 --> 00:12:10,050
For Photos, you would have maybe
a link to where the file

276
00:12:10,050 --> 00:12:13,980
is on the file system and the
dimensions of the photo and

277
00:12:13,980 --> 00:12:16,460
any other metadata
that you have.

278
00:12:16,460 --> 00:12:18,750
This needs to be stored
somewhere in your data layer,

279
00:12:18,750 --> 00:12:23,000
and we use IndexedDB do this.

280
00:12:23,000 --> 00:12:25,170
The problem that we ran
into with our initial

281
00:12:25,170 --> 00:12:29,200
implementation is that we were
not using transactions in

282
00:12:29,200 --> 00:12:31,050
IndexedDB appropriately.

283
00:12:31,050 --> 00:12:34,710
And this was kind of killer
because it's not immediately

284
00:12:34,710 --> 00:12:37,130
obvious what you're doing wrong
when your reads are

285
00:12:37,130 --> 00:12:39,240
going really slowly
unless you're very

286
00:12:39,240 --> 00:12:40,880
familiar with the API.

287
00:12:40,880 --> 00:12:43,340
So I'll give you a demo here.

288
00:12:43,340 --> 00:12:47,120
We have writing 1,000 records,
reading, removing them, et

289
00:12:47,120 --> 00:12:50,530
cetera, and with transaction
and with no transaction.

290
00:12:50,530 --> 00:12:51,780
We'll see what the
differences are.

291
00:12:51,780 --> 00:12:56,110

292
00:12:56,110 --> 00:12:59,540
OK, it's taking a long time.

293
00:12:59,540 --> 00:13:00,420
And this is even worse.

294
00:13:00,420 --> 00:13:03,780
This is two orders of magnitude
worse without

295
00:13:03,780 --> 00:13:05,100
transactions.

296
00:13:05,100 --> 00:13:05,970
And it's very simple.

297
00:13:05,970 --> 00:13:08,550
Let's go in and see what
the transactions do.

298
00:13:08,550 --> 00:13:19,160

299
00:13:19,160 --> 00:13:22,990
So you open a transaction,
we'll zoom this up.

300
00:13:22,990 --> 00:13:24,110
And I thank you very much.

301
00:13:24,110 --> 00:13:26,240
I will zoom back out when
I'm done with this.

302
00:13:26,240 --> 00:13:33,000

303
00:13:33,000 --> 00:13:35,590
So we have a notification when
the transaction is complete.

304
00:13:35,590 --> 00:13:39,400
That is when we say I've done
all of my 1,000 operations.

305
00:13:39,400 --> 00:13:42,690
And you just do all of your
operations at once using the

306
00:13:42,690 --> 00:13:44,890
transaction object.

307
00:13:44,890 --> 00:13:48,190
You get the object store out
from the transaction.

308
00:13:48,190 --> 00:13:50,780
You do your operation
on the store.

309
00:13:50,780 --> 00:13:52,980
And once this goes
out of scope, the

310
00:13:52,980 --> 00:13:54,460
transaction will be complete.

311
00:13:54,460 --> 00:13:55,580
And we'll be done.

312
00:13:55,580 --> 00:14:01,880
The implementation that doesn't
use transaction has

313
00:14:01,880 --> 00:14:04,330
one database transaction
per call.

314
00:14:04,330 --> 00:14:06,270
So every time you are doing a
new call, you're creating a

315
00:14:06,270 --> 00:14:07,240
new transaction.

316
00:14:07,240 --> 00:14:08,490
Very inefficient.

317
00:14:08,490 --> 00:14:23,650

318
00:14:23,650 --> 00:14:26,990
So I think the biggest part
of making this app very

319
00:14:26,990 --> 00:14:29,540
performant is the scrolling
performance.

320
00:14:29,540 --> 00:14:32,740
And this was the biggest
challenge for us to solve.

321
00:14:32,740 --> 00:14:34,560
There's a lot of optimizations
you have to do

322
00:14:34,560 --> 00:14:35,820
all across the board.

323
00:14:35,820 --> 00:14:37,580
You have to make sure that
you don't have any leaks.

324
00:14:37,580 --> 00:14:39,940
You have to make sure that
you're doing the right thing

325
00:14:39,940 --> 00:14:42,910
in order to be on fast
scroll path.

326
00:14:42,910 --> 00:14:45,630
This needs to be very
non-choppy.

327
00:14:45,630 --> 00:14:48,340
Otherwise, if it is choppy,
your users are jarred.

328
00:14:48,340 --> 00:14:49,810
And they're just
very confused.

329
00:14:49,810 --> 00:14:51,510
It looks like not
a native app.

330
00:14:51,510 --> 00:14:54,940
It looks like a web app.

331
00:14:54,940 --> 00:14:58,730
And so the solution for this
is a fast scroll path.

332
00:14:58,730 --> 00:15:01,960
The fast scroll path is
where the GPU does the

333
00:15:01,960 --> 00:15:03,180
scrolling for you.

334
00:15:03,180 --> 00:15:07,000
Offload the processing for
handling this chunk of video

335
00:15:07,000 --> 00:15:10,040
memory, you've got everything
rendered into it, and whenever

336
00:15:10,040 --> 00:15:12,280
you scroll, you just ask the
GPU to do the [? offset ?]

337
00:15:12,280 --> 00:15:13,010
for you.

338
00:15:13,010 --> 00:15:15,570
This is common in games,
graphics, whatever.

339
00:15:15,570 --> 00:15:16,980
And we're starting to
add this to the

340
00:15:16,980 --> 00:15:18,800
browser in a lot of places.

341
00:15:18,800 --> 00:15:22,190
Keep in mind that this is very
preliminary, and the GPU team

342
00:15:22,190 --> 00:15:23,670
is working very hard on this.

343
00:15:23,670 --> 00:15:27,320
But there are a lot of things
you have to keep in mind.

344
00:15:27,320 --> 00:15:30,510
When you do scrolling, the
element that you scroll has to

345
00:15:30,510 --> 00:15:31,520
be the body element.

346
00:15:31,520 --> 00:15:32,910
That's the first thing.

347
00:15:32,910 --> 00:15:36,790
And I say that right off the bat
because it's not obvious

348
00:15:36,790 --> 00:15:39,210
that is a requirement
or a constraint.

349
00:15:39,210 --> 00:15:42,720
And you can set up your DOM,
your HTML structure, in such a

350
00:15:42,720 --> 00:15:46,620
way that it's very hard
after the fact to move

351
00:15:46,620 --> 00:15:47,790
scrolling to the body.

352
00:15:47,790 --> 00:15:49,300
And we ran into that problem.

353
00:15:49,300 --> 00:15:51,740
It was a total pain.

354
00:15:51,740 --> 00:15:53,690
For example, let's go look
at the app for a second.

355
00:15:53,690 --> 00:15:58,100

356
00:15:58,100 --> 00:16:00,380
We have our main content
here in the middle.

357
00:16:00,380 --> 00:16:01,640
And I'm going to go into
the single photo

358
00:16:01,640 --> 00:16:02,650
view to show you more.

359
00:16:02,650 --> 00:16:06,340
In the toolbar on the top and
this sidebar on the right, the

360
00:16:06,340 --> 00:16:09,580
toolbar and the sidebar were
siblings of the main content.

361
00:16:09,580 --> 00:16:11,150
And this was all in one wrapper

362
00:16:11,150 --> 00:16:12,510
that could be scrolled.

363
00:16:12,510 --> 00:16:14,380
This doesn't work because
you're not on the body.

364
00:16:14,380 --> 00:16:17,170
And in order to be on the body
element, we had to make the

365
00:16:17,170 --> 00:16:20,580
toolbar and the sidebar
fixed position.

366
00:16:20,580 --> 00:16:23,680
And that has its own
intricacies.

367
00:16:23,680 --> 00:16:26,320
Like for example, the scroll
bar goes all way the up

368
00:16:26,320 --> 00:16:27,440
through the toolbar.

369
00:16:27,440 --> 00:16:30,390
There's really not anything we
can do about that right now.

370
00:16:30,390 --> 00:16:32,780
And if that's the worst of our
problems that gets us this

371
00:16:32,780 --> 00:16:34,900
type of scrolling, this fast
scrolling, then it's

372
00:16:34,900 --> 00:16:36,150
definitely worth it.

373
00:16:36,150 --> 00:16:40,940

374
00:16:40,940 --> 00:16:42,770
You also want to make sure
when you're handling the

375
00:16:42,770 --> 00:16:45,720
scroll event, that you're
not doing too much work.

376
00:16:45,720 --> 00:16:49,260
This is when the browser is
saying I'm about to scroll,

377
00:16:49,260 --> 00:16:51,590
I'm about to change
your UI, the page.

378
00:16:51,590 --> 00:16:53,930
If you start doing a lot of
processing, maybe start

379
00:16:53,930 --> 00:16:55,800
loading a bunch of image
elements, a lot of photo

380
00:16:55,800 --> 00:16:59,520
elements, that inherently is
going to make the scrolling a

381
00:16:59,520 --> 00:17:01,300
lot worse, a lot slower.

382
00:17:01,300 --> 00:17:05,660
So you want to offload your
processing to a time that is

383
00:17:05,660 --> 00:17:06,960
not in your body scrolling.

384
00:17:06,960 --> 00:17:09,690
Perhaps queueing up and batching
operations that could

385
00:17:09,690 --> 00:17:11,180
be done later.

386
00:17:11,180 --> 00:17:13,660
And we'll talk about that
in one of our solutions.

387
00:17:13,660 --> 00:17:16,750
One thing that we had to do
was to reduce image loads.

388
00:17:16,750 --> 00:17:20,369
So when you set the source
attribute on an image element,

389
00:17:20,369 --> 00:17:23,450
the browser, no matter whether
it's in the view port or not,

390
00:17:23,450 --> 00:17:26,040
the image element has
to decode the image.

391
00:17:26,040 --> 00:17:28,900
And we found that the decoding
can be very expensive, and it

392
00:17:28,900 --> 00:17:31,820
obviously scales with the
size of the image.

393
00:17:31,820 --> 00:17:34,720
So you want to question
expensive

394
00:17:34,720 --> 00:17:37,180
operations like that.

395
00:17:37,180 --> 00:17:39,340
And setting image source is
one of those expensive

396
00:17:39,340 --> 00:17:41,550
operations.

397
00:17:41,550 --> 00:17:45,340
So we talked about batching your
heavy processing so that

398
00:17:45,340 --> 00:17:47,530
you're not doing everything
in your scroll.

399
00:17:47,530 --> 00:17:51,400
One way to do this, and the best
way right now, is to have

400
00:17:51,400 --> 00:17:54,910
a callback to this method call
RequestAnimationFrame.

401
00:17:54,910 --> 00:17:58,950
This method is a way for the
browser to alert you, hey, I'm

402
00:17:58,950 --> 00:18:03,070
about to do an animation, and
you should do some heavy

403
00:18:03,070 --> 00:18:05,370
processing in this time period,
batch it all up.

404
00:18:05,370 --> 00:18:07,240
Do everything at once because
we're going to

405
00:18:07,240 --> 00:18:08,570
swap everything out.

406
00:18:08,570 --> 00:18:11,450
And this is a way for the
browser to say this will be

407
00:18:11,450 --> 00:18:13,610
less janky.

408
00:18:13,610 --> 00:18:16,330
And so whenever we do
scrolling, we do

409
00:18:16,330 --> 00:18:19,330
RequestAnimationFrame, and then
we obviously need to load

410
00:18:19,330 --> 00:18:20,050
more elements.

411
00:18:20,050 --> 00:18:21,750
So when we
RequestAnimationFrame, the

412
00:18:21,750 --> 00:18:24,640
callback, we do that
image loading then.

413
00:18:24,640 --> 00:18:26,410
Because that's when the browser
says, do your heavy,

414
00:18:26,410 --> 00:18:27,640
intensive processing.

415
00:18:27,640 --> 00:18:30,210
And this is really great
to have high

416
00:18:30,210 --> 00:18:33,340
performance in your scrolling.

417
00:18:33,340 --> 00:18:36,460
Another thing that I think is
starting to be more well

418
00:18:36,460 --> 00:18:39,950
known, but it is not that well
known I think, and it's not

419
00:18:39,950 --> 00:18:42,860
very necessarily intuitive, is
that when you measure certain

420
00:18:42,860 --> 00:18:46,490
properties on DOM elements, you
can cause reflows, which

421
00:18:46,490 --> 00:18:47,900
may cause repaints.

422
00:18:47,900 --> 00:18:49,930
And painting is the one
thing you want to

423
00:18:49,930 --> 00:18:51,370
minimize at all costs.

424
00:18:51,370 --> 00:18:53,290
If you're doing a bunch of
paints, then you don't have

425
00:18:53,290 --> 00:18:55,990
the benefit of the GPU doing
the scroll for you.

426
00:18:55,990 --> 00:18:59,860
Because you're just thrashing
what the GPU had.

427
00:18:59,860 --> 00:19:00,820
ScrollTop, for example.

428
00:19:00,820 --> 00:19:03,800
If you're reading scrollTop, not
writing to it, if you read

429
00:19:03,800 --> 00:19:05,710
it, you're going to do a
reflow, and you could

430
00:19:05,710 --> 00:19:07,740
potentially repaint.

431
00:19:07,740 --> 00:19:08,490
Another one is

432
00:19:08,490 --> 00:19:10,670
getClientBoundingRect on elements.

433
00:19:10,670 --> 00:19:13,310
And you know what, it's kind
of iffy on some of these

434
00:19:13,310 --> 00:19:15,010
whether it will cause
a reflow or not.

435
00:19:15,010 --> 00:19:17,410
There are several good articles,
and I recommend

436
00:19:17,410 --> 00:19:21,430
looking up reflow, HTML reflow,
to get a lot of

437
00:19:21,430 --> 00:19:22,410
information about this.

438
00:19:22,410 --> 00:19:25,040
But this is something that
you have to keep in mind.

439
00:19:25,040 --> 00:19:27,290
This is the next stage
of app development.

440
00:19:27,290 --> 00:19:31,220
And this type of performance is
what these apps are going

441
00:19:31,220 --> 00:19:32,085
to be doing.

442
00:19:32,085 --> 00:19:33,670
And you want your app to
be this performant.

443
00:19:33,670 --> 00:19:36,580

444
00:19:36,580 --> 00:19:38,410
Garbage collection is nasty.

445
00:19:38,410 --> 00:19:40,900
JavaScript is a fun language.

446
00:19:40,900 --> 00:19:46,450
And, obviously, the way the
memory layout works is very

447
00:19:46,450 --> 00:19:48,680
fortunate in some ways, but
garbage collection is not one

448
00:19:48,680 --> 00:19:49,570
of those ways.

449
00:19:49,570 --> 00:19:52,140
So you want to try to minimize
garbage collection by

450
00:19:52,140 --> 00:19:55,790
minimizing the pressure
buildup on memory.

451
00:19:55,790 --> 00:20:01,250
One of the ways that we do that
in this Photos app is if

452
00:20:01,250 --> 00:20:04,380
you consider it, you have your
main viewport, and you have

453
00:20:04,380 --> 00:20:06,620
image elements for each
of the photos that the

454
00:20:06,620 --> 00:20:07,720
user wants to see.

455
00:20:07,720 --> 00:20:09,730
And we obviously have to
preload before and

456
00:20:09,730 --> 00:20:11,520
after the view port.

457
00:20:11,520 --> 00:20:13,780
And that could be 40,000
DOM nodes.

458
00:20:13,780 --> 00:20:14,840
That's too many.

459
00:20:14,840 --> 00:20:16,600
That's going to cause a lot of
garbage collection, a lot of

460
00:20:16,600 --> 00:20:18,470
memory pressure that
you don't need.

461
00:20:18,470 --> 00:20:23,030
Consider that you can compress
those nodes given like say a

462
00:20:23,030 --> 00:20:27,980
square of 1,024 by 768
higher up that is not

463
00:20:27,980 --> 00:20:29,480
visible in the viewport.

464
00:20:29,480 --> 00:20:31,680
Get rid of all those nodes,
you can either store them

465
00:20:31,680 --> 00:20:34,450
around somewhere, but at least
keep them out of the tree, and

466
00:20:34,450 --> 00:20:37,040
replace them with one
div that's sized

467
00:20:37,040 --> 00:20:38,900
the exact same size.

468
00:20:38,900 --> 00:20:40,970
So that's like compressing
what you had before.

469
00:20:40,970 --> 00:20:43,020
And that will keep the structure
of your document,

470
00:20:43,020 --> 00:20:45,830
will not change the size
of the entire body.

471
00:20:45,830 --> 00:20:47,680
So the user won't even
be aware that

472
00:20:47,680 --> 00:20:49,520
you've taken nodes out.

473
00:20:49,520 --> 00:20:52,280
A nifty little trick
you can do.

474
00:20:52,280 --> 00:20:53,010
It's really important.

475
00:20:53,010 --> 00:20:53,780
Leaks are bad.

476
00:20:53,780 --> 00:20:54,780
Everybody knows that.

477
00:20:54,780 --> 00:20:57,660
But you've got to pay
attention to it.

478
00:20:57,660 --> 00:21:01,220
The profiler inside of
Chrome itself can

479
00:21:01,220 --> 00:21:02,280
really help with this.

480
00:21:02,280 --> 00:21:03,530
Let's take a look real quick.

481
00:21:03,530 --> 00:21:08,570

482
00:21:08,570 --> 00:21:09,820
Nope.

483
00:21:09,820 --> 00:21:12,540

484
00:21:12,540 --> 00:21:18,510
So profiles here allows you
to take a heap snapshot.

485
00:21:18,510 --> 00:21:20,730
Obviously, the heap snapshot
for this is not going to be

486
00:21:20,730 --> 00:21:22,880
entirely interesting.

487
00:21:22,880 --> 00:21:25,300
But it does show you some of the
objects that are going on.

488
00:21:25,300 --> 00:21:27,870
So we have like this slide
deck object, and

489
00:21:27,870 --> 00:21:28,620
there are two of them.

490
00:21:28,620 --> 00:21:32,530
So I may question if I only have
one set of slides, why do

491
00:21:32,530 --> 00:21:34,530
I have two slide decks?

492
00:21:34,530 --> 00:21:35,550
I don't know the
answer to that.

493
00:21:35,550 --> 00:21:37,590
Could be a leak.

494
00:21:37,590 --> 00:21:40,350
We found, in many instances of
just going through this, and

495
00:21:40,350 --> 00:21:43,510
you can arrange things by, for
example, dominators, which are

496
00:21:43,510 --> 00:21:45,580
saying this thing is huge.

497
00:21:45,580 --> 00:21:47,740
Obviously, you want to go
through the native stuff at

498
00:21:47,740 --> 00:21:50,720
the top that's not yours, but
get down to where you're

499
00:21:50,720 --> 00:21:54,600
allocating stuff and say
this is too heavy.

500
00:21:54,600 --> 00:21:58,720
This slide deck is too
heavy, for example.

501
00:21:58,720 --> 00:22:02,050
And that's just one way to say I
need to go in here and start

502
00:22:02,050 --> 00:22:03,970
looking for places where
I may be leaking.

503
00:22:03,970 --> 00:22:06,630
I may not be freeing references,
removing

504
00:22:06,630 --> 00:22:08,370
references, et cetera.

505
00:22:08,370 --> 00:22:10,480
There are a lot of tools that
can help with this.

506
00:22:10,480 --> 00:22:12,580
They're, in our experience,
not very great.

507
00:22:12,580 --> 00:22:15,930
There's not a lot of tools right
now that have a very low

508
00:22:15,930 --> 00:22:16,990
false positive rate.

509
00:22:16,990 --> 00:22:19,230
But it can point you in
the right direction.

510
00:22:19,230 --> 00:22:22,290
And it doesn't hurt to just run
it every once in awhile

511
00:22:22,290 --> 00:22:24,160
and say these are the known
false positives.

512
00:22:24,160 --> 00:22:27,060
These are the ones
we need to fix.

513
00:22:27,060 --> 00:22:28,700
Listeners can get
very expensive.

514
00:22:28,700 --> 00:22:31,790
We had an instance where you
would start the app with no

515
00:22:31,790 --> 00:22:35,570
photos, and we had
40,000 listeners.

516
00:22:35,570 --> 00:22:37,010
What are they listening to?

517
00:22:37,010 --> 00:22:39,100
I mean, that doesn't
even make sense.

518
00:22:39,100 --> 00:22:41,180
You need to make sure that
things are being detached

519
00:22:41,180 --> 00:22:41,840
appropriately.

520
00:22:41,840 --> 00:22:43,490
They stop listening.

521
00:22:43,490 --> 00:22:46,630
They can be dangerous not just
in the memory footprint but

522
00:22:46,630 --> 00:22:48,140
also in the processing
footprint.

523
00:22:48,140 --> 00:22:51,650
If these listeners are being
fired on events, and they

524
00:22:51,650 --> 00:22:53,540
don't need to be listening, then
they're going to do some

525
00:22:53,540 --> 00:22:55,280
processing that is
unnecessary.

526
00:22:55,280 --> 00:22:58,010
And that's going to hurt your
performance as well.

527
00:22:58,010 --> 00:23:00,120
And we already talked about
profiling memory usage, so

528
00:23:00,120 --> 00:23:03,260
we'll skip that.

529
00:23:03,260 --> 00:23:05,830
So back to simplicity.

530
00:23:05,830 --> 00:23:09,490
I truly think this is one of the
most difficult things that

531
00:23:09,490 --> 00:23:13,570
you have to solve in an app, how
to get out of the way so

532
00:23:13,570 --> 00:23:16,420
that the user can just see what
they want to see, do what

533
00:23:16,420 --> 00:23:20,940
they want to do, minimize your
UI footprint, et cetera.

534
00:23:20,940 --> 00:23:24,090
And the Chrome platform is
really starting to take over

535
00:23:24,090 --> 00:23:26,960
this and give you APIs
that allow you to

536
00:23:26,960 --> 00:23:28,210
get out of the way.

537
00:23:28,210 --> 00:23:30,530

538
00:23:30,530 --> 00:23:34,110
One of the big ones we
had was with sign-in.

539
00:23:34,110 --> 00:23:38,350
Signing into an app really feels
like a web page that you

540
00:23:38,350 --> 00:23:39,540
have to sign into.

541
00:23:39,540 --> 00:23:42,520
Especially if you don't have
the ability to sign in once

542
00:23:42,520 --> 00:23:45,470
and have that persistent across
multiple lifetimes,

543
00:23:45,470 --> 00:23:49,160
multiple instances of the app,
it just doesn't feel native.

544
00:23:49,160 --> 00:23:52,140
And we do, that's our goal
is to feel native.

545
00:23:52,140 --> 00:23:54,580
Also, if you're signing in,
that's a step, that's a road

546
00:23:54,580 --> 00:23:57,880
block to the user getting to
do what they want to do.

547
00:23:57,880 --> 00:23:59,880
And so we really needed
a way around this.

548
00:23:59,880 --> 00:24:04,190
And thankfully, the Chrome
platform has a way.

549
00:24:04,190 --> 00:24:07,800
There is this thing called the
Identity API which allows you

550
00:24:07,800 --> 00:24:10,920
to retrieve the OAuth2 token
of the user that's

551
00:24:10,920 --> 00:24:12,130
currently signed in.

552
00:24:12,130 --> 00:24:14,780
Now this app is right now
designed for ChromeOS.

553
00:24:14,780 --> 00:24:18,090
But the Identity API works
on all platforms.

554
00:24:18,090 --> 00:24:20,340
So if the user is signed into
the browser, you can get their

555
00:24:20,340 --> 00:24:23,430
OAuth2 token for their
Google account.

556
00:24:23,430 --> 00:24:28,190
For example, in this app, I
didn't have to sign in.

557
00:24:28,190 --> 00:24:29,590
There is no sign in
button anywhere.

558
00:24:29,590 --> 00:24:32,810
When you start the app, I don't
ask you to sign in, or

559
00:24:32,810 --> 00:24:34,400
I'm not asked to sign in.

560
00:24:34,400 --> 00:24:37,305
And that all comes from the
Identity API and the fact that

561
00:24:37,305 --> 00:24:39,510
on ChromeOS, specifically,
you're always

562
00:24:39,510 --> 00:24:40,540
signed into the browser.

563
00:24:40,540 --> 00:24:43,410
So for an app on ChromeOS, you
shouldn't have to sign in if

564
00:24:43,410 --> 00:24:45,390
you're using Google Accounts.

565
00:24:45,390 --> 00:24:49,640
Now you may not be using Google
Accounts, and the

566
00:24:49,640 --> 00:24:51,495
Identity API has a solution
for that.

567
00:24:51,495 --> 00:24:54,190
It's called launch
WebAuth flow.

568
00:24:54,190 --> 00:24:58,510
And so with that API, you can
pass in a third party URL in

569
00:24:58,510 --> 00:25:02,030
point for OAuth2, and under
the hood, all of

570
00:25:02,030 --> 00:25:04,805
the workings happen.

571
00:25:04,805 --> 00:25:08,890
A pop-up is shown that allows
the user to login.

572
00:25:08,890 --> 00:25:11,960
Now, obviously, that doesn't
solve the issue of getting out

573
00:25:11,960 --> 00:25:13,300
of the way and not having
a dialogue.

574
00:25:13,300 --> 00:25:15,510
But if you're not using Google
Accounts, which is a fair

575
00:25:15,510 --> 00:25:18,590
point, you need a way to sign
in the user to your app.

576
00:25:18,590 --> 00:25:22,020
And that token can be
persisted across

577
00:25:22,020 --> 00:25:23,280
instances of the app.

578
00:25:23,280 --> 00:25:27,600
So, for example, in this code
sample here, we are calling

579
00:25:27,600 --> 00:25:30,840
getAuthToken, and we're
storing that token.

580
00:25:30,840 --> 00:25:32,720
So for the lifetime of the app,
we don't have to keep

581
00:25:32,720 --> 00:25:35,290
calling getAuthToken, we just
have the token around.

582
00:25:35,290 --> 00:25:39,620
And we build our requests
with this token.

583
00:25:39,620 --> 00:25:42,410
For example, the Photos
back end at Google.

584
00:25:42,410 --> 00:25:44,920
We're going to do a request
to read all the

585
00:25:44,920 --> 00:25:46,980
photos of the user.

586
00:25:46,980 --> 00:25:49,770
And so what we've done is we
have the token stored.

587
00:25:49,770 --> 00:25:52,430
We just keep using this same
token for all of our requests

588
00:25:52,430 --> 00:25:52,890
in the app.

589
00:25:52,890 --> 00:25:54,220
It's really easy to use.

590
00:25:54,220 --> 00:26:01,120

591
00:26:01,120 --> 00:26:03,980
So like I said, I had
a camera, and I had

592
00:26:03,980 --> 00:26:05,270
an SD card in it.

593
00:26:05,270 --> 00:26:10,660
And I plugged it in, and the
right thing just happened.

594
00:26:10,660 --> 00:26:11,680
It's a Photos app.

595
00:26:11,680 --> 00:26:13,060
I've installed this app.

596
00:26:13,060 --> 00:26:16,470
I said I trust this app to
do what I need it to do,

597
00:26:16,470 --> 00:26:18,530
including the fact that
it says it has

598
00:26:18,530 --> 00:26:21,120
access to your media.

599
00:26:21,120 --> 00:26:24,690
Currently, in the web today,
and in most native apps as

600
00:26:24,690 --> 00:26:29,230
well, you have to select the
media specifically, say by the

601
00:26:29,230 --> 00:26:32,980
file open dialog, which I
consider the worst piece of UI

602
00:26:32,980 --> 00:26:33,665
in browser history.

603
00:26:33,665 --> 00:26:34,550
It's awful.

604
00:26:34,550 --> 00:26:37,150
But everybody has to
go through that.

605
00:26:37,150 --> 00:26:39,580
The alternative is Flash, but
even then, you still have to

606
00:26:39,580 --> 00:26:42,210
do file directory browsing,
et cetera.

607
00:26:42,210 --> 00:26:43,640
We wanted to get rid of that.

608
00:26:43,640 --> 00:26:46,540

609
00:26:46,540 --> 00:26:49,500
The solution to this was the
Media Gallery API, which is

610
00:26:49,500 --> 00:26:51,400
like the pinnacle
API in this app.

611
00:26:51,400 --> 00:26:52,822
It's what makes this app pop.

612
00:26:52,822 --> 00:26:54,860
It's what makes it real.

613
00:26:54,860 --> 00:27:00,120
The Media Galleries API allows
the developer to have access

614
00:27:00,120 --> 00:27:05,040
to media devices, so SD cards,
platform media, like my

615
00:27:05,040 --> 00:27:09,180
pictures or the photos
on a Mac.

616
00:27:09,180 --> 00:27:10,810
And it has a seamless access.

617
00:27:10,810 --> 00:27:14,230
You don't have to ask the user
at the time of app running, at

618
00:27:14,230 --> 00:27:15,870
the app running, only
at installation and

619
00:27:15,870 --> 00:27:17,320
only that one time.

620
00:27:17,320 --> 00:27:21,200
So in this app, we have UI that
shows up a notification

621
00:27:21,200 --> 00:27:22,625
that says you just plugged
in a card, we're

622
00:27:22,625 --> 00:27:23,890
going to start uploading.

623
00:27:23,890 --> 00:27:26,940
And you have the ability to stop
the uploading, but that

624
00:27:26,940 --> 00:27:28,290
action happens right away.

625
00:27:28,290 --> 00:27:30,940
The user doesn't have to wait,
and the user doesn't have to

626
00:27:30,940 --> 00:27:32,845
do the file open dialog,
which is just awful.

627
00:27:32,845 --> 00:27:35,600

628
00:27:35,600 --> 00:27:38,590
So here's a little code snapshot
of how to use this.

629
00:27:38,590 --> 00:27:41,680
The API call is
getMediaFileSystems.

630
00:27:41,680 --> 00:27:45,410
And if you're familiar with
it, it returns a DOM file

631
00:27:45,410 --> 00:27:49,450
system, which has its own file
entries inside of that.

632
00:27:49,450 --> 00:27:52,000
Its directory structure, you can
read through this with the

633
00:27:52,000 --> 00:27:53,460
file system API.

634
00:27:53,460 --> 00:27:56,180
So this is really neat.

635
00:27:56,180 --> 00:27:59,350
We just have this one little
layer on top of the already

636
00:27:59,350 --> 00:28:04,410
existing file system API that
restricts what is shown to the

637
00:28:04,410 --> 00:28:06,510
app to just media locations.

638
00:28:06,510 --> 00:28:11,250
For example, when I plugged in
the SD card, it knew that it

639
00:28:11,250 --> 00:28:14,740
had a DCIM folder and said
we think this is a media.

640
00:28:14,740 --> 00:28:18,380
It's a simple heuristic, but
it really solves 90% of the

641
00:28:18,380 --> 00:28:20,140
use cases that we're
looking for.

642
00:28:20,140 --> 00:28:22,700
If you plugged in an external
drive, and it had a DCIM

643
00:28:22,700 --> 00:28:25,080
directory, we would say
that it probably has

644
00:28:25,080 --> 00:28:26,440
photos on it as well.

645
00:28:26,440 --> 00:28:27,690
And we would start
loading that.

646
00:28:27,690 --> 00:28:35,440

647
00:28:35,440 --> 00:28:39,760
So the first time I saw the
Pixel screen, it was detached

648
00:28:39,760 --> 00:28:40,840
from the actual laptop.

649
00:28:40,840 --> 00:28:42,770
It was not even put
together yet.

650
00:28:42,770 --> 00:28:44,290
It was this little piece.

651
00:28:44,290 --> 00:28:45,790
And he said, you have to
see this, one of the

652
00:28:45,790 --> 00:28:46,800
developers of the Pixel.

653
00:28:46,800 --> 00:28:50,180
And he showed it to me, and it
was just mind blowing, the

654
00:28:50,180 --> 00:28:51,210
picture that he showed on it.

655
00:28:51,210 --> 00:28:53,200
I'd never seen something
like this.

656
00:28:53,200 --> 00:28:56,460
And then he started swiping it
and moving things around, the

657
00:28:56,460 --> 00:28:59,820
touch on this one screen,
it was just amazing.

658
00:28:59,820 --> 00:29:03,410
And so you have the ability when
writing apps not just for

659
00:29:03,410 --> 00:29:07,080
this but say for tablets as
well, like high DPI tablets,

660
00:29:07,080 --> 00:29:11,240
you obviously have MacBooks
that have Retina Display.

661
00:29:11,240 --> 00:29:13,560
You want to make sure that
you're optimizing for these

662
00:29:13,560 --> 00:29:15,190
form factors which are becoming

663
00:29:15,190 --> 00:29:16,440
more and more prevalent.

664
00:29:16,440 --> 00:29:19,650

665
00:29:19,650 --> 00:29:23,070
And for the high resolution
display, it's not hard.

666
00:29:23,070 --> 00:29:27,050
You just provide 2x assets,
high-resolution assets.

667
00:29:27,050 --> 00:29:29,820
The API to do this
is in CSS itself.

668
00:29:29,820 --> 00:29:31,550
It's called WebKit Media Set.

669
00:29:31,550 --> 00:29:34,980
And you can specify
the multiplicative

670
00:29:34,980 --> 00:29:37,010
factor, so 1x or 2x.

671
00:29:37,010 --> 00:29:40,030
And you just pass in the right
resource through that.

672
00:29:40,030 --> 00:29:42,590
One thing to keep in mind is
that you want to make sure to

673
00:29:42,590 --> 00:29:47,250
set the background size of your
asset to the low res.

674
00:29:47,250 --> 00:29:51,630
So we have this close icon,
and it's 32 pixels in the

675
00:29:51,630 --> 00:29:53,230
low-res asset.

676
00:29:53,230 --> 00:29:55,750
When we load the high-res asset,
we still want it to be

677
00:29:55,750 --> 00:29:59,590
32 pixels on the screen.

678
00:29:59,590 --> 00:30:01,810
So that doesn't blow up
un-proportionally.

679
00:30:01,810 --> 00:30:06,630
We just have it more dense
inside of those 32 pixels.

680
00:30:06,630 --> 00:30:09,070
You want to make sure you do
this especially if your user

681
00:30:09,070 --> 00:30:11,190
is going to be on a
high-resolution display

682
00:30:11,190 --> 00:30:16,040
because on most browsers and
definitely in Chrome, the

683
00:30:16,040 --> 00:30:19,470
scaling algorithm for images to
scale up to high resolution

684
00:30:19,470 --> 00:30:21,820
is optimized for speed,
not quality.

685
00:30:21,820 --> 00:30:25,280
You'll get very blurry images,
and your users are going to

686
00:30:25,280 --> 00:30:26,290
get a headache after a while.

687
00:30:26,290 --> 00:30:27,540
It looks really bad.

688
00:30:27,540 --> 00:30:30,900
We had a regression one time
where the high-resolution

689
00:30:30,900 --> 00:30:32,770
assets were not being
loaded properly.

690
00:30:32,770 --> 00:30:35,900
And every body was like, oh
my gosh, this is awful.

691
00:30:35,900 --> 00:30:37,930
Something is clearly wrong
with this app.

692
00:30:37,930 --> 00:30:39,910
And imagine if your user
saw that, they're

693
00:30:39,910 --> 00:30:40,970
not expecting it.

694
00:30:40,970 --> 00:30:42,860
They just know something
is wrong.

695
00:30:42,860 --> 00:30:45,590

696
00:30:45,590 --> 00:30:47,950
And to touch support.

697
00:30:47,950 --> 00:30:49,330
This is a really fun
thing to touch.

698
00:30:49,330 --> 00:30:52,940
And they always say, why would
you touch this laptop screen?

699
00:30:52,940 --> 00:30:55,520
People don't want to reach over
their keyboard to do it.

700
00:30:55,520 --> 00:30:58,610
But the more you use this, the
more you start touching

701
00:30:58,610 --> 00:30:59,900
everything around you.

702
00:30:59,900 --> 00:31:01,060
Like you reach over
everything.

703
00:31:01,060 --> 00:31:04,810
I touch my work 32-inch monitor

704
00:31:04,810 --> 00:31:06,110
expecting it to do something.

705
00:31:06,110 --> 00:31:06,770
And it doesn't.

706
00:31:06,770 --> 00:31:08,840
It's extremely frustrating.

707
00:31:08,840 --> 00:31:10,930
More and more, displays are
going to be touch, whether

708
00:31:10,930 --> 00:31:14,530
it's a hybrid, whether it can
be converted, et cetera.

709
00:31:14,530 --> 00:31:17,960
Your app should really handle,
if not touch gestures

710
00:31:17,960 --> 00:31:23,060
specifically like dragging and
touch start, touch end, to

711
00:31:23,060 --> 00:31:25,700
consider what your user
actions should be.

712
00:31:25,700 --> 00:31:27,350
For example, consider
the Photos view.

713
00:31:27,350 --> 00:31:31,700

714
00:31:31,700 --> 00:31:34,120
So we have this photo here.

715
00:31:34,120 --> 00:31:36,470
I admit, I was in the wrong
when we were having this

716
00:31:36,470 --> 00:31:37,290
discussion.

717
00:31:37,290 --> 00:31:39,990
I felt that we should
have double-click to

718
00:31:39,990 --> 00:31:41,980
activate these objects.

719
00:31:41,980 --> 00:31:44,180
So if I wanted to go into the
single photo view for this

720
00:31:44,180 --> 00:31:46,200
photo, I should have
double-click.

721
00:31:46,200 --> 00:31:49,640
And that was me coming from
wanting to have a more native

722
00:31:49,640 --> 00:31:50,360
experience.

723
00:31:50,360 --> 00:31:55,040
And in native apps and in the
file system browsing around

724
00:31:55,040 --> 00:31:57,820
things, you double-click to
activate for the most part.

725
00:31:57,820 --> 00:31:59,820
And I thought that would be
a more native experience.

726
00:31:59,820 --> 00:32:02,220
But then we had the issue of
well, what do you do when

727
00:32:02,220 --> 00:32:03,090
you're tapping?

728
00:32:03,090 --> 00:32:05,600
Do you double tap the screen?

729
00:32:05,600 --> 00:32:06,180
No.

730
00:32:06,180 --> 00:32:07,500
That doesn't work.

731
00:32:07,500 --> 00:32:10,940
We could have it where you, with
a mouse or a track pad,

732
00:32:10,940 --> 00:32:13,980
that you double-click, and
then with touch, you

733
00:32:13,980 --> 00:32:14,500
single-click.

734
00:32:14,500 --> 00:32:17,400
But then you have a very
confusing UX, your user

735
00:32:17,400 --> 00:32:18,590
doesn't know what to do.

736
00:32:18,590 --> 00:32:20,240
And then they're going to start
doing the wrong thing

737
00:32:20,240 --> 00:32:20,860
the entire time.

738
00:32:20,860 --> 00:32:24,570
They're going to start double
touching the screen.

739
00:32:24,570 --> 00:32:28,220
So the key takeaway for this one
is just to consider that

740
00:32:28,220 --> 00:32:30,710
tap support is very important.

741
00:32:30,710 --> 00:32:35,290
Users are going to start using
tap and touch screens.

742
00:32:35,290 --> 00:32:38,210
And you don't necessarily have
to have full touch support.

743
00:32:38,210 --> 00:32:40,860
Just think about what your
UX is going to be.

744
00:32:40,860 --> 00:32:42,790
I know a lot of you are
engineers, maybe some of you

745
00:32:42,790 --> 00:32:44,320
are designers in UX.

746
00:32:44,320 --> 00:32:45,910
But it's all our responsibility
to create the

747
00:32:45,910 --> 00:32:47,160
best looking app.

748
00:32:47,160 --> 00:32:50,210

749
00:32:50,210 --> 00:32:54,730
So on to security, that
last principle.

750
00:32:54,730 --> 00:32:57,260
This section, it can come
off a little dry.

751
00:32:57,260 --> 00:33:00,750
It's kind of difficult to deal
with, but security is

752
00:33:00,750 --> 00:33:03,110
extremely important
for the user.

753
00:33:03,110 --> 00:33:06,540

754
00:33:06,540 --> 00:33:09,370
And there are a lot of things in
the platform that at first

755
00:33:09,370 --> 00:33:12,760
feel like you have to deal with,
but at the end, assuming

756
00:33:12,760 --> 00:33:14,930
you start designing your app
the right way from the

757
00:33:14,930 --> 00:33:17,450
beginning, you're
much better off.

758
00:33:17,450 --> 00:33:18,935
Your user is much safer.

759
00:33:18,935 --> 00:33:22,300

760
00:33:22,300 --> 00:33:27,020
So content security policy is
this essentially white list,

761
00:33:27,020 --> 00:33:30,810
black list that says your app
has access to these resources,

762
00:33:30,810 --> 00:33:33,810
these remote URLs, these
domains, et cetera.

763
00:33:33,810 --> 00:33:37,130
And by default, you really don't
have access to hardly

764
00:33:37,130 --> 00:33:38,010
anything at all.

765
00:33:38,010 --> 00:33:40,930
As you're adding a white list
for resources your app should

766
00:33:40,930 --> 00:33:44,280
have access to, you consider
like your back end server, you

767
00:33:44,280 --> 00:33:47,560
obviously need access to
that, and nothing else.

768
00:33:47,560 --> 00:33:51,990
So if an attacker gets a hold
of your app, something gets

769
00:33:51,990 --> 00:33:55,230
injected, and starts making
requests to some malicious

770
00:33:55,230 --> 00:33:58,780
server, those requests are going
to be denied because

771
00:33:58,780 --> 00:34:01,920
they're blocked by content
security policy.

772
00:34:01,920 --> 00:34:04,770
The key thing here is to start
designing your app from the

773
00:34:04,770 --> 00:34:07,360
very beginning with content
security policy in mind.

774
00:34:07,360 --> 00:34:09,120
You can't load remote scripts.

775
00:34:09,120 --> 00:34:10,820
You can't use eval.

776
00:34:10,820 --> 00:34:14,560
And, for us, this was kind of
a problem because we were

777
00:34:14,560 --> 00:34:17,719
getting JSON objects back from
the server, and so we had to

778
00:34:17,719 --> 00:34:20,850
translate those into objects
using eval, and

779
00:34:20,850 --> 00:34:22,739
we couldn't do that.

780
00:34:22,739 --> 00:34:25,780
So what we ended up doing was
having a sandboxed iframe that

781
00:34:25,780 --> 00:34:29,280
had the use of eval inside of
it, and we passed the JSON

782
00:34:29,280 --> 00:34:30,820
objects into this iframe.

783
00:34:30,820 --> 00:34:34,389
It would do the eval, get the
object back, and then post a

784
00:34:34,389 --> 00:34:36,520
message back to the
app, this object.

785
00:34:36,520 --> 00:34:39,620
So if something malicious goes
on, the eval is going wonky,

786
00:34:39,620 --> 00:34:42,370
that sandbox iframe has no
permissions whatsoever.

787
00:34:42,370 --> 00:34:44,420
All it can do is communicate
back and forth.

788
00:34:44,420 --> 00:34:46,690
So you're pretty safe
as far as that goes.

789
00:34:46,690 --> 00:34:51,590

790
00:34:51,590 --> 00:34:52,699
Making requests.

791
00:34:52,699 --> 00:34:55,020
So you can't say image
source equal remote.

792
00:34:55,020 --> 00:34:58,080
You actually have to pull down
the bits for that image.

793
00:34:58,080 --> 00:35:00,250
So all of these photos, we have
to pull them down from

794
00:35:00,250 --> 00:35:01,240
the server.

795
00:35:01,240 --> 00:35:04,220
XML HTTP requests is
the way we do this.

796
00:35:04,220 --> 00:35:08,560
You just create your URL for
the request, send it off.

797
00:35:08,560 --> 00:35:11,740
You get your response, you
should save it in your data

798
00:35:11,740 --> 00:35:12,860
layer obviously.

799
00:35:12,860 --> 00:35:15,960
And then once you get that,
the data gets bubbled up

800
00:35:15,960 --> 00:35:17,210
through your UI.

801
00:35:17,210 --> 00:35:20,880

802
00:35:20,880 --> 00:35:23,610
And another tip as far as
thinking what you should do

803
00:35:23,610 --> 00:35:26,920
from the beginning, designing
from the beginning, resource

804
00:35:26,920 --> 00:35:29,790
compilation comes in very handy
with packaged apps.

805
00:35:29,790 --> 00:35:32,690
We particularly use Closure, but
there are a lot of tools

806
00:35:32,690 --> 00:35:35,320
that you can use to
do the same thing.

807
00:35:35,320 --> 00:35:38,550
You're going to say,
essentially, in your main HTML

808
00:35:38,550 --> 00:35:42,900
of the packaged app, script
equals some local file.

809
00:35:42,900 --> 00:35:45,480
You could say a bunch of local
files, but it's a lot easier

810
00:35:45,480 --> 00:35:48,300
to just have your code compiled,
have it minified, et

811
00:35:48,300 --> 00:35:50,520
cetera, and say script equals
this local file.

812
00:35:50,520 --> 00:35:54,830

813
00:35:54,830 --> 00:36:00,350
So to wrap it up, we look back
at what our goals were, and I

814
00:36:00,350 --> 00:36:03,600
think we really achieved
those goals.

815
00:36:03,600 --> 00:36:06,150
We identified holes
in the platform,

816
00:36:06,150 --> 00:36:07,340
APIs that were missing.

817
00:36:07,340 --> 00:36:09,900
We added media gallery APIs.

818
00:36:09,900 --> 00:36:13,040
We tested a lot of features
from Google+ Photos.

819
00:36:13,040 --> 00:36:16,230
We got autocuration working
really well.

820
00:36:16,230 --> 00:36:18,760
And we just pushed the platform
to its limits.

821
00:36:18,760 --> 00:36:20,740
How far can you go with this?

822
00:36:20,740 --> 00:36:23,090
How hard is it for developers
to use this?

823
00:36:23,090 --> 00:36:25,000
I think the answer
is not very hard.

824
00:36:25,000 --> 00:36:27,650
The biggest thing you have to
do is to understand your

825
00:36:27,650 --> 00:36:29,820
constraints from the
very beginning.

826
00:36:29,820 --> 00:36:33,260
Understand that you don't have
access to remote URLs.

827
00:36:33,260 --> 00:36:35,390
Understand that if you want fast
scrolling, you need to

828
00:36:35,390 --> 00:36:36,740
scroll your body.

829
00:36:36,740 --> 00:36:39,870
And, obviously, the platform is
constantly changing, things

830
00:36:39,870 --> 00:36:40,910
are being fixed.

831
00:36:40,910 --> 00:36:45,440
I know I've reached out to the
GPU team a lot to say, this is

832
00:36:45,440 --> 00:36:46,480
not easy enough.

833
00:36:46,480 --> 00:36:47,590
We have to fix this.

834
00:36:47,590 --> 00:36:52,140
And just imagine the evolution
that's happening right now.

835
00:36:52,140 --> 00:36:55,680
You can see it at I/O. This
platform is just moving

836
00:36:55,680 --> 00:36:57,470
forward at the speed of light,
the things that you're going

837
00:36:57,470 --> 00:36:58,470
to be able to do.

838
00:36:58,470 --> 00:37:00,590
It's getting a lot easier.

839
00:37:00,590 --> 00:37:02,850
And it's getting a lot better.

840
00:37:02,850 --> 00:37:07,230
So packaged apps, yeah, we
definitely want that.

841
00:37:07,230 --> 00:37:10,910
And I think the way to think
about it in terms of how does

842
00:37:10,910 --> 00:37:14,290
it relate to web apps is that
you could have the core of

843
00:37:14,290 --> 00:37:17,100
your app have functionality
that is available

844
00:37:17,100 --> 00:37:19,840
cross-platform, is not
necessarily specific to

845
00:37:19,840 --> 00:37:23,020
Chrome, doesn't have these
extended APIs and permissions

846
00:37:23,020 --> 00:37:24,570
that are requested.

847
00:37:24,570 --> 00:37:27,640
And in doing that, you're going
to have a lot safer API.

848
00:37:27,640 --> 00:37:31,186
For example, you've got to use
XML HTTP requests, you're

849
00:37:31,186 --> 00:37:34,480
going to have content security
policy support, all of that

850
00:37:34,480 --> 00:37:35,220
from the get-go.

851
00:37:35,220 --> 00:37:37,080
And that's just your
core bundle.

852
00:37:37,080 --> 00:37:40,140
Layered on top of this is all
the goodies that you get from

853
00:37:40,140 --> 00:37:40,680
the platform.

854
00:37:40,680 --> 00:37:43,120
You get the Identity
API, so use it.

855
00:37:43,120 --> 00:37:44,320
If you have it, use it.

856
00:37:44,320 --> 00:37:46,030
You get Media Galleries API.

857
00:37:46,030 --> 00:37:46,450
Use it.

858
00:37:46,450 --> 00:37:48,730
And if not, degrade
gracefully.

859
00:37:48,730 --> 00:37:52,290
And this is how if you build
your app, whether it's for

860
00:37:52,290 --> 00:37:54,750
Chrome packaged apps
specifically, or if you're

861
00:37:54,750 --> 00:37:57,690
going to deploy it on the web
across multiple browsers, if

862
00:37:57,690 --> 00:38:00,620
you do this, you can have one
product that can work on

863
00:38:00,620 --> 00:38:01,950
multiple platforms.

864
00:38:01,950 --> 00:38:05,570
And on some platforms, it just
has more functionality.

865
00:38:05,570 --> 00:38:07,600
We've done that with Google+
Photos Chrome app.

866
00:38:07,600 --> 00:38:10,850
And we think it's working
out really well.

867
00:38:10,850 --> 00:38:14,590
So I actually think we don't
have time for questions.

868
00:38:14,590 --> 00:38:15,880
We only have about
a minute left.

869
00:38:15,880 --> 00:38:19,346
But I will be at the Office
Hours bar if you want to come

870
00:38:19,346 --> 00:38:21,090
by and ask any questions
you have.

871
00:38:21,090 --> 00:38:22,900
It's been a real pleasure.

872
00:38:22,900 --> 00:38:24,490
Thank you very much
for attending.

873
00:38:24,490 --> 00:38:26,230
And I hope to see
you guys soon.

874
00:38:26,230 --> 00:38:30,013
[APPLAUSE]

