1
00:00:00,000 --> 00:00:05,010

2
00:00:05,010 --> 00:00:05,690
COLT MCANLIS: Everybody.

3
00:00:05,690 --> 00:00:06,880
My name is Colt McAnlis.

4
00:00:06,880 --> 00:00:09,790
I'm a game developer advocate
here at Google, focusing on

5
00:00:09,790 --> 00:00:11,490
Native Client and Chrome.

6
00:00:11,490 --> 00:00:13,460
Thank you all for coming
to the Google Dev Day.

7
00:00:13,460 --> 00:00:16,770
We've got a lot of great talks
so far today and hopefully

8
00:00:16,770 --> 00:00:20,040
this will continue in our
processes to get you ready to

9
00:00:20,040 --> 00:00:22,330
use web gaming, I suppose
is the big thing.

10
00:00:22,330 --> 00:00:25,280
Here at GDC, there's a lot of
focus on console, but everyone

11
00:00:25,280 --> 00:00:26,740
is moving towards web gaming.

12
00:00:26,740 --> 00:00:29,190
And we understand that this is
an important trend in sort of

13
00:00:29,190 --> 00:00:31,470
the evolution of gaming
as a whole.

14
00:00:31,470 --> 00:00:33,600
And what we're going to talk
about today is best practices

15
00:00:33,600 --> 00:00:34,680
in developing those
web gaming.

16
00:00:34,680 --> 00:00:38,150
So being at Google, you sort of
have an interesting ability

17
00:00:38,150 --> 00:00:40,680
to look at the broad spectrum
of data and the number of

18
00:00:40,680 --> 00:00:44,220
developers out there on the web
doing some amazing things,

19
00:00:44,220 --> 00:00:47,030
and mine that data, look at it
from different angles, and

20
00:00:47,030 --> 00:00:49,320
sort of construct the best
practices document.

21
00:00:49,320 --> 00:00:51,260
And that's really what
this talk is about.

22
00:00:51,260 --> 00:00:54,590
This doc very specifically is
focused to developers who are

23
00:00:54,590 --> 00:00:59,070
not already multi-millionaires
at developing web games.

24
00:00:59,070 --> 00:01:01,470
If you're already if you're a
making millions and millions

25
00:01:01,470 --> 00:01:04,140
of dollars with your web game,
chances are you know

26
00:01:04,140 --> 00:01:05,670
everything that I'm about
to talk about.

27
00:01:05,670 --> 00:01:07,090
So feel free, check
your emails.

28
00:01:07,090 --> 00:01:08,420
Zone out.

29
00:01:08,420 --> 00:01:10,540
Figure out what parties you're
going to at GDC.

30
00:01:10,540 --> 00:01:12,890
Have fun with that.

31
00:01:12,890 --> 00:01:15,710
In mean time for everybody
else, we're going to talk

32
00:01:15,710 --> 00:01:17,820
today about developing a web
game in modern browsers.

33
00:01:17,820 --> 00:01:20,170
Now the interesting point
here is twofold.

34
00:01:20,170 --> 00:01:23,560
First off is I'm saying
in modern browsers.

35
00:01:23,560 --> 00:01:26,650
So I think we can all agree that
when we talk about web

36
00:01:26,650 --> 00:01:30,590
gaming, there's sort of this
threshold of minimum feature

37
00:01:30,590 --> 00:01:32,780
set that we're not willing
to go below.

38
00:01:32,780 --> 00:01:34,400
A lot of developers when you
talk about web gaming and they

39
00:01:34,400 --> 00:01:35,470
say well, what about ubiquity?

40
00:01:35,470 --> 00:01:36,980
What about reach?

41
00:01:36,980 --> 00:01:40,230
But at the same time, they're
not really able to make the

42
00:01:40,230 --> 00:01:42,870
experience of their game
translate to these older

43
00:01:42,870 --> 00:01:45,410
browsers that don't have
the same capabilities.

44
00:01:45,410 --> 00:01:48,460
So today, I want to make sure
that we're focusing things

45
00:01:48,460 --> 00:01:50,880
since you are at the Google
Developer Day, that we're

46
00:01:50,880 --> 00:01:52,310
actually talking about Chrome.

47
00:01:52,310 --> 00:01:54,680
Chrome is considered
a modern browser.

48
00:01:54,680 --> 00:01:57,700
It's a very important
linchpin in the

49
00:01:57,700 --> 00:01:58,580
pushing of things forward.

50
00:01:58,580 --> 00:02:01,490
Google has a lot of vested
interest in making sure that

51
00:02:01,490 --> 00:02:03,560
this is a platform that we can
continue to push the internet

52
00:02:03,560 --> 00:02:06,880
forward in positive ways, and
basically enrich the ecosystem

53
00:02:06,880 --> 00:02:07,910
for all of humanity.

54
00:02:07,910 --> 00:02:10,220
Because pretty much everyone
uses the internet nowadays.

55
00:02:10,220 --> 00:02:12,860
And if you don't use the
internet, hopefully

56
00:02:12,860 --> 00:02:14,000
we'll fix that soon.

57
00:02:14,000 --> 00:02:15,940
Anyhow, let's get started.

58
00:02:15,940 --> 00:02:17,720
So let's start from the top.

59
00:02:17,720 --> 00:02:19,910
If you're a console developer
and you've never shipped a web

60
00:02:19,910 --> 00:02:22,040
game, you have no idea
we're talking about.

61
00:02:22,040 --> 00:02:25,860
And you generally have no idea
what entails web games.

62
00:02:25,860 --> 00:02:27,510
So let's talk about
that for a minute.

63
00:02:27,510 --> 00:02:29,050
So first off, a web game
generally have

64
00:02:29,050 --> 00:02:29,850
some sort of client.

65
00:02:29,850 --> 00:02:33,190
The client is downloaded from a
server to the client to the

66
00:02:33,190 --> 00:02:36,050
end user's machine in a web
page that does some

67
00:02:36,050 --> 00:02:37,470
interesting things.

68
00:02:37,470 --> 00:02:39,960
On the end user's machine, it
usually does some sort of

69
00:02:39,960 --> 00:02:40,885
scripting and displays.

70
00:02:40,885 --> 00:02:43,650
This means code execution as
well as visual display--

71
00:02:43,650 --> 00:02:46,410
2D, 3D, or whatnot.

72
00:02:46,410 --> 00:02:48,010
In addition to that,
this is served--

73
00:02:48,010 --> 00:02:50,080
the client, including the
scripting data and all the

74
00:02:50,080 --> 00:02:51,630
information is to display--

75
00:02:51,630 --> 00:02:54,060
is served from some sort
of content server.

76
00:02:54,060 --> 00:02:55,260
This could be a web server or a

77
00:02:55,260 --> 00:02:56,950
scalable distributed network.

78
00:02:56,950 --> 00:02:58,690
And it also has some relational

79
00:02:58,690 --> 00:03:00,340
context to a database.

80
00:03:00,340 --> 00:03:02,610
This is because most people
nowadays in web gaming, they

81
00:03:02,610 --> 00:03:04,140
require you to log in.

82
00:03:04,140 --> 00:03:07,510
They store your saved game state
in the cloud somewhere--

83
00:03:07,510 --> 00:03:11,180
have you purchase an item, who's
your friends, have you

84
00:03:11,180 --> 00:03:13,480
invited this person,
what level are you.

85
00:03:13,480 --> 00:03:14,840
This information is
all stored in some

86
00:03:14,840 --> 00:03:15,970
sort of large database.

87
00:03:15,970 --> 00:03:18,190
And I could rattle off a bunch
of acronyms about what

88
00:03:18,190 --> 00:03:20,750
databases are and what databases
aren't, but we'll

89
00:03:20,750 --> 00:03:22,420
stick to just saying
that clients

90
00:03:22,420 --> 00:03:24,630
communicate with databases.

91
00:03:24,630 --> 00:03:26,400
Once you've got your content
server to distribute your

92
00:03:26,400 --> 00:03:29,040
content to your client side and
your database to sort of

93
00:03:29,040 --> 00:03:32,940
understand the relation to the
user and the universe that

94
00:03:32,940 --> 00:03:36,170
you're trying to generate, some
games also have a game

95
00:03:36,170 --> 00:03:36,990
play server.

96
00:03:36,990 --> 00:03:39,960
Now a game play server is really
the realm of what we

97
00:03:39,960 --> 00:03:41,790
call AAA niche gaming.

98
00:03:41,790 --> 00:03:44,550
So this is things like first
person shooters, real time

99
00:03:44,550 --> 00:03:47,650
strategy games, things that
run at 60 Hertz on some

100
00:03:47,650 --> 00:03:50,700
ungodly monitor that you need
some computer from the future

101
00:03:50,700 --> 00:03:52,900
to generally be able to run
on your local machine.

102
00:03:52,900 --> 00:03:55,340
These games effectively require
some piece of hardware

103
00:03:55,340 --> 00:03:57,990
running in some server farm
actually running the

104
00:03:57,990 --> 00:04:00,960
simulation of the game to keep
all of the clients in sync at

105
00:04:00,960 --> 00:04:02,740
the proper frequencies.

106
00:04:02,740 --> 00:04:04,330
Now some games require
this on the web.

107
00:04:04,330 --> 00:04:05,460
Some don't.

108
00:04:05,460 --> 00:04:07,950
But it's important to
point this out here.

109
00:04:07,950 --> 00:04:09,600
So once you've got this working,
sooner or later

110
00:04:09,600 --> 00:04:10,600
you're going to want
a social graph.

111
00:04:10,600 --> 00:04:12,670
This is the real power
of the web.

112
00:04:12,670 --> 00:04:15,020
When you start talking about
what's the difference between

113
00:04:15,020 --> 00:04:19,180
a web game and a console game
and a PC game that you go buy

114
00:04:19,180 --> 00:04:21,839
from a retailer, what you're
really looking at is that a

115
00:04:21,839 --> 00:04:25,040
web game gives you direct access
to a social graph in an

116
00:04:25,040 --> 00:04:26,740
immersive manner that
you can't get

117
00:04:26,740 --> 00:04:28,920
in those other relations.

118
00:04:28,920 --> 00:04:31,060
And then once you have all of
this, the final thing a web

119
00:04:31,060 --> 00:04:32,490
game does is monetize.

120
00:04:32,490 --> 00:04:34,920
At the end of the day, you
guys gotta make money.

121
00:04:34,920 --> 00:04:37,730
We've all got significant others
and mother-in-laws who

122
00:04:37,730 --> 00:04:39,800
say we should get real jobs
instead of making video games

123
00:04:39,800 --> 00:04:40,730
for a living.

124
00:04:40,730 --> 00:04:44,150
We want to prove them wrong by
monetizing effectively and

125
00:04:44,150 --> 00:04:45,860
making it rain with
dollar bills.

126
00:04:45,860 --> 00:04:47,293
That's sort of the goal.

127
00:04:47,293 --> 00:04:52,250
The good news here is that as
Google as a platform provider,

128
00:04:52,250 --> 00:04:57,110
we've actually got software
services in place to handle

129
00:04:57,110 --> 00:05:00,250
and address all of these needs
for a web game on your behalf.

130
00:05:00,250 --> 00:05:02,340
And the rest of the talk, we're
going to be talking

131
00:05:02,340 --> 00:05:04,650
about the best practices
in doing all of these

132
00:05:04,650 --> 00:05:05,670
items you see here.

133
00:05:05,670 --> 00:05:08,220
But we're going to do it from
the context of the Google

134
00:05:08,220 --> 00:05:10,750
services, mainly because of
well, obviously we want you to

135
00:05:10,750 --> 00:05:11,530
use our services.

136
00:05:11,530 --> 00:05:12,770
We think that they're
fantastic.

137
00:05:12,770 --> 00:05:16,050
But also, it just sort of gives
us a line in the sand as

138
00:05:16,050 --> 00:05:18,000
far as documentation
is concerned.

139
00:05:18,000 --> 00:05:20,900
We want to make sure that we can
provide the documentation

140
00:05:20,900 --> 00:05:22,970
for the ideas that we're
talking about.

141
00:05:22,970 --> 00:05:25,220
So then our content databases,
what we're going to talk about

142
00:05:25,220 --> 00:05:26,320
today is Google App Engine.

143
00:05:26,320 --> 00:05:29,550
It provides you both content
distribution for web pages and

144
00:05:29,550 --> 00:05:32,000
static data, dynamic data,
everything you need, as well

145
00:05:32,000 --> 00:05:33,150
as a relational database.

146
00:05:33,150 --> 00:05:35,010
You actually store your
table information,

147
00:05:35,010 --> 00:05:36,570
players and what not.

148
00:05:36,570 --> 00:05:38,210
For social graph, we've
got Google+.

149
00:05:38,210 --> 00:05:41,270
If you don't have a Google+
account, go get one now.

150
00:05:41,270 --> 00:05:43,270
Make sure you sign up by the
end of the talk so then you

151
00:05:43,270 --> 00:05:46,070
can follow me on Google+ where
I spend most of my time

152
00:05:46,070 --> 00:05:49,510
posting about web gaming and
Native Client development.

153
00:05:49,510 --> 00:05:51,970
And for monetization, we've
got this great integration

154
00:05:51,970 --> 00:05:55,030
point called Google Wallet which
is super easy to use.

155
00:05:55,030 --> 00:05:56,840
It has a lot of benefits that
we'll talk to you towards the

156
00:05:56,840 --> 00:05:57,730
end of the slide.

157
00:05:57,730 --> 00:06:00,850
In addition to these right here,
we've also got a couple

158
00:06:00,850 --> 00:06:02,380
others that you should be
interested in the we'll talk

159
00:06:02,380 --> 00:06:03,050
about today.

160
00:06:03,050 --> 00:06:04,440
The first is Google Analytics.

161
00:06:04,440 --> 00:06:08,130
Google Analytics is typically
designed as a way to track

162
00:06:08,130 --> 00:06:10,540
your users' movements and who
visits your website, where

163
00:06:10,540 --> 00:06:12,800
they come from, how they're
using your website, what's

164
00:06:12,800 --> 00:06:15,240
wrong, what's broken, what's
popular, and whatnot.

165
00:06:15,240 --> 00:06:17,580
But this could actually be
modified with a few APIs to

166
00:06:17,580 --> 00:06:19,080
work very well for games.

167
00:06:19,080 --> 00:06:20,480
We'll talk about how
you use that.

168
00:06:20,480 --> 00:06:21,910
And then finally is the
Chrome Web Store.

169
00:06:21,910 --> 00:06:26,640
Chrome Web Store is an amazing
sort of outlet that Google has

170
00:06:26,640 --> 00:06:29,350
launched about a year and a
half ago now that provides

171
00:06:29,350 --> 00:06:32,350
sort of a content discovery
portal for all things web.

172
00:06:32,350 --> 00:06:34,940
We've got an amazing plethora
of applications both

173
00:06:34,940 --> 00:06:36,280
games and not games.

174
00:06:36,280 --> 00:06:39,370
But if you're looking for an
amazing place for users to

175
00:06:39,370 --> 00:06:42,830
develop your content in a
curated, informative way,

176
00:06:42,830 --> 00:06:44,910
definitely check out the
Chrome Web Store.

177
00:06:44,910 --> 00:06:46,720
Now on this graph here you'll
notice that we don't really

178
00:06:46,720 --> 00:06:48,800
have a solution for
gameplay servers.

179
00:06:48,800 --> 00:06:52,210
And the only thing I can say
about that is stay tuned.

180
00:06:52,210 --> 00:06:53,010
So the rundown.

181
00:06:53,010 --> 00:06:55,440
So grab your coffee, grab your
laptop, grab your phone.

182
00:06:55,440 --> 00:06:56,790
Let's talk about what we're
going to do today.

183
00:06:56,790 --> 00:06:58,780
So we're going to talk about
content distribution,

184
00:06:58,780 --> 00:07:00,670
databases, proper
practices there.

185
00:07:00,670 --> 00:07:02,890
We're going to talk about login
and authentication.

186
00:07:02,890 --> 00:07:05,140
You'd actually be surprised
about how many problems there

187
00:07:05,140 --> 00:07:07,300
are with login and
authentication that make users

188
00:07:07,300 --> 00:07:08,360
drop off the radar.

189
00:07:08,360 --> 00:07:11,320
Then we're going to talk about
localization, rendering, web

190
00:07:11,320 --> 00:07:13,420
and platform, and
user metrics.

191
00:07:13,420 --> 00:07:14,700
These are all important
things.

192
00:07:14,700 --> 00:07:16,110
And then finally, we're going
to finish this off with

193
00:07:16,110 --> 00:07:17,340
monetization which--

194
00:07:17,340 --> 00:07:19,290
I put that at the end because
we all know you're only here

195
00:07:19,290 --> 00:07:20,030
to talk about monetization.

196
00:07:20,030 --> 00:07:23,020
The rest of this stuff
is icing on the cake.

197
00:07:23,020 --> 00:07:24,070
So let's talk about
serving content.

198
00:07:24,070 --> 00:07:26,420
Start at the beginning.

199
00:07:26,420 --> 00:07:28,910
So let's say all of your
data is served

200
00:07:28,910 --> 00:07:31,380
from some server somewhere.

201
00:07:31,380 --> 00:07:33,150
Your data is usually uploaded
to the web.

202
00:07:33,150 --> 00:07:35,250
That web creates the
information.

203
00:07:35,250 --> 00:07:36,030
It stores it.

204
00:07:36,030 --> 00:07:36,550
It scales it.

205
00:07:36,550 --> 00:07:37,370
It replicates it.

206
00:07:37,370 --> 00:07:39,460
You can see here are some
of standard items do you

207
00:07:39,460 --> 00:07:40,800
typically see on your server--

208
00:07:40,800 --> 00:07:44,420
HTML, JavaScript, images,
JSON files, ZIPs,

209
00:07:44,420 --> 00:07:46,270
sound files, and whatnot.

210
00:07:46,270 --> 00:07:48,010
What happens is that
the client--

211
00:07:48,010 --> 00:07:49,940
the user machine effectively--

212
00:07:49,940 --> 00:07:52,840
sits around and it will
generally do a page load or

213
00:07:52,840 --> 00:07:56,680
resource or load or from
JavaScript an XHttpRequest you

214
00:07:56,680 --> 00:07:57,920
can Google that and figure
out what the

215
00:07:57,920 --> 00:07:59,620
proper syntax is there--

216
00:07:59,620 --> 00:08:02,150
to fetch this data from
the internet or

217
00:08:02,150 --> 00:08:03,720
the server in general.

218
00:08:03,720 --> 00:08:05,320
The cool thing is
that Chrome--

219
00:08:05,320 --> 00:08:07,490
again, we're going to
focus on that--

220
00:08:07,490 --> 00:08:09,950
Chrome will automatically cache
anything given through

221
00:08:09,950 --> 00:08:10,980
this load for you.

222
00:08:10,980 --> 00:08:13,510
So if you actually do a page
load, Chrome will go ahead and

223
00:08:13,510 --> 00:08:16,090
grab the HTML and JavaScript
and JPGs and

224
00:08:16,090 --> 00:08:17,400
JSON data for you.

225
00:08:17,400 --> 00:08:19,600
If you need to grab your ZIP
files or your OGG datas,

226
00:08:19,600 --> 00:08:21,700
you're probably going through
some resource load or some

227
00:08:21,700 --> 00:08:25,510
XHttpRequest. And when you do
those, Chrome will cache that

228
00:08:25,510 --> 00:08:27,230
data as well.

229
00:08:27,230 --> 00:08:30,775
The good news about this is
that caching is automatic.

230
00:08:30,775 --> 00:08:32,720
You don't have to do anything
to take advantage of It.

231
00:08:32,720 --> 00:08:33,505
You grab your data.

232
00:08:33,505 --> 00:08:34,570
It's stored on the local disk.

233
00:08:34,570 --> 00:08:37,850
When the user requests that data
again, Chrome will check

234
00:08:37,850 --> 00:08:40,130
the local disk first. If it's
there, it'll grab it and load

235
00:08:40,130 --> 00:08:42,080
it up and use it.

236
00:08:42,080 --> 00:08:44,340
It it's timed out or if it
detects that there's some of

237
00:08:44,340 --> 00:08:46,770
the reason it needs, it'll go
back to the web and grab it

238
00:08:46,770 --> 00:08:47,060
from there.

239
00:08:47,060 --> 00:08:48,770
This is all handled
on your behalf.

240
00:08:48,770 --> 00:08:51,880
The bad news about this though
is that it is in fact handled

241
00:08:51,880 --> 00:08:54,740
on your behalf, which means that
any time during the day

242
00:08:54,740 --> 00:08:57,830
the user can either delete their
cache or go download 17

243
00:08:57,830 --> 00:08:58,950
gigs of other data.

244
00:08:58,950 --> 00:09:00,970
And that data will invalidate
the cache and

245
00:09:00,970 --> 00:09:02,070
push your stuff out.

246
00:09:02,070 --> 00:09:05,950
So really, you have no ability
to track when your data's

247
00:09:05,950 --> 00:09:08,270
going to be evicted, and how
that's going to relate to the

248
00:09:08,270 --> 00:09:10,520
end user experience.

249
00:09:10,520 --> 00:09:13,330
So the good news is modern
browsers actually implement a

250
00:09:13,330 --> 00:09:15,430
specific file store API.

251
00:09:15,430 --> 00:09:19,310
The file store API allows you
to write to a persistent

252
00:09:19,310 --> 00:09:22,570
obfuscated sandbox section
of the user's hard drive.

253
00:09:22,570 --> 00:09:24,790
Which means that when you
actually grab this data from

254
00:09:24,790 --> 00:09:28,280
the web, you can actually store
it somewhere so that you

255
00:09:28,280 --> 00:09:31,340
control the caching, so that
then you directly control the

256
00:09:31,340 --> 00:09:32,810
user's experience with
the caching.

257
00:09:32,810 --> 00:09:33,850
And that's very important.

258
00:09:33,850 --> 00:09:36,520
If you've got 14 gigabytes of
data sitting around, you're

259
00:09:36,520 --> 00:09:38,960
going to want to know how the
user is loading it and when

260
00:09:38,960 --> 00:09:40,710
they're loading so that you
can optimize for their

261
00:09:40,710 --> 00:09:41,500
experience.

262
00:09:41,500 --> 00:09:43,090
At the end of the day, they're
the guys give you the money.

263
00:09:43,090 --> 00:09:46,270
You gotta make it
right for them.

264
00:09:46,270 --> 00:09:47,610
So let's talk about scaling.

265
00:09:47,610 --> 00:09:50,090
So let's say you've made in the
most amazing game ever.

266
00:09:50,090 --> 00:09:53,120
It's called catfightpig.com.

267
00:09:53,120 --> 00:09:53,500
Whatever.

268
00:09:53,500 --> 00:09:54,820
I don't know.

269
00:09:54,820 --> 00:09:55,850
And you make this game.

270
00:09:55,850 --> 00:09:56,790
You put it up on the web.

271
00:09:56,790 --> 00:09:59,820
And then all of a sudden, you
get a million billion 100,000

272
00:09:59,820 --> 00:10:03,530
people that decide to download
your game and play and run it.

273
00:10:03,530 --> 00:10:05,710
Well, the problem is that
you've just went viral.

274
00:10:05,710 --> 00:10:08,480
And if you don't have a proper
scaling solution on your

275
00:10:08,480 --> 00:10:10,990
server side to handle the
scaling the just happened on

276
00:10:10,990 --> 00:10:13,560
the client side, your viral
ability is going to go through

277
00:10:13,560 --> 00:10:14,860
the floor really quick.

278
00:10:14,860 --> 00:10:17,360
So what happens is you need to
move to something like a

279
00:10:17,360 --> 00:10:19,710
distributable content
distribution server.

280
00:10:19,710 --> 00:10:22,510
So you need to find some way,
use some service out there to

281
00:10:22,510 --> 00:10:24,510
actually replicate your content
across all of these

282
00:10:24,510 --> 00:10:26,990
different servers so that it can
be handed to the clients

283
00:10:26,990 --> 00:10:28,130
as they request it.

284
00:10:28,130 --> 00:10:29,650
Now there's some great services
out there, for

285
00:10:29,650 --> 00:10:33,910
example Google App Engine which
will handle replication

286
00:10:33,910 --> 00:10:37,680
as well as regional replication
on your behalf.

287
00:10:37,680 --> 00:10:41,570
That means that say someone in
France is accessing your data,

288
00:10:41,570 --> 00:10:44,700
and you've uploaded it to
servers here in California.

289
00:10:44,700 --> 00:10:47,050
They're still going to get fast
access speeds to that

290
00:10:47,050 --> 00:10:50,280
data because Google's handled
all the back end of making

291
00:10:50,280 --> 00:10:53,790
sure that it exists on a web
server that's near that user

292
00:10:53,790 --> 00:10:55,640
so they get it at the
correct speeds.

293
00:10:55,640 --> 00:10:57,530
The good thing is you don't
have to worry about that.

294
00:10:57,530 --> 00:11:00,510
If you've just rented some web
server sitting somewhere in

295
00:11:00,510 --> 00:11:02,740
someone's basement, you're not
going to get the same ability.

296
00:11:02,740 --> 00:11:05,530
So international customers or
customers that may not have

297
00:11:05,530 --> 00:11:08,500
direct access to that guy's
basement, Bill's basement

298
00:11:08,500 --> 00:11:12,490
we'll call it, are going to
get a lower feature set.

299
00:11:12,490 --> 00:11:14,430
So when you're serving this
data, it's important to think

300
00:11:14,430 --> 00:11:16,740
about what the costs associated
with it are.

301
00:11:16,740 --> 00:11:18,820
Hosting data has a cost. And
let's talk about how it's

302
00:11:18,820 --> 00:11:19,670
being used.

303
00:11:19,670 --> 00:11:22,800
So today, typically developers
use loose files.

304
00:11:22,800 --> 00:11:23,750
They define--

305
00:11:23,750 --> 00:11:27,310
and this is sort of defined as
a result of the way that HTML

306
00:11:27,310 --> 00:11:28,540
and JavaScript works.

307
00:11:28,540 --> 00:11:29,570
You can simply go in there.

308
00:11:29,570 --> 00:11:30,420
You define an image.

309
00:11:30,420 --> 00:11:31,500
You define a JavaScript link.

310
00:11:31,500 --> 00:11:36,320
You define these as an exact
path to a resource on the web.

311
00:11:36,320 --> 00:11:39,640
So what happens is the browser
will effectively issue

312
00:11:39,640 --> 00:11:42,340
asynchronous loads for all
of these web resources.

313
00:11:42,340 --> 00:11:43,400
So it'll go out to
the internet.

314
00:11:43,400 --> 00:11:44,640
It'll say hey, please
give me this thing.

315
00:11:44,640 --> 00:11:46,710
Let me know once you've
received it.

316
00:11:46,710 --> 00:11:48,190
Now this is fantastic.

317
00:11:48,190 --> 00:11:50,610
This mean that the web browser
and the client are sort of

318
00:11:50,610 --> 00:11:54,010
optimizing the load process
based on your behalf, sending

319
00:11:54,010 --> 00:11:56,260
all this stuff out
and getting them.

320
00:11:56,260 --> 00:11:58,030
And of course, when it does
receive it, it puts it in the

321
00:11:58,030 --> 00:11:59,840
Chrome cache, which is
again good for you.

322
00:11:59,840 --> 00:12:02,100
Of course, we talked about the
Chrome cache before and all

323
00:12:02,100 --> 00:12:04,580
the benefits and downsides
of that.

324
00:12:04,580 --> 00:12:09,010
Now anyone who's shipped a game
on the PC or on console

325
00:12:09,010 --> 00:12:11,830
knows that archiving is a
much, much better way to

326
00:12:11,830 --> 00:12:12,970
handle this.

327
00:12:12,970 --> 00:12:15,840
Because of the fact that any
time you read from a resource

328
00:12:15,840 --> 00:12:16,980
or a medium--

329
00:12:16,980 --> 00:12:20,160
be it hard drive or CD or
even the internet--

330
00:12:20,160 --> 00:12:23,340
you're going to induce a lot
of bandwidth incurrence.

331
00:12:23,340 --> 00:12:24,750
So you're going to say
give me this load.

332
00:12:24,750 --> 00:12:27,290
It's going to take 10 seconds,
20 seconds, a minute, two

333
00:12:27,290 --> 00:12:28,310
minutes, whatever.

334
00:12:28,310 --> 00:12:29,960
You want to reduce that
amount of time.

335
00:12:29,960 --> 00:12:32,870
Now if you have tons and tons
and tons and tons of files,

336
00:12:32,870 --> 00:12:36,330
you may have to be blocking some
files, loading others in

337
00:12:36,330 --> 00:12:37,070
different orders.

338
00:12:37,070 --> 00:12:38,370
It just gets into madness.

339
00:12:38,370 --> 00:12:40,290
So what most developers do is
they'll actually zip all of

340
00:12:40,290 --> 00:12:42,260
this data up, or they'll archive
the information.

341
00:12:42,260 --> 00:12:44,560
They put all of their loose
files into a single archive,

342
00:12:44,560 --> 00:12:47,150
and then they download
that archive.

343
00:12:47,150 --> 00:12:49,900
Now once you do this though,
you have to note that the

344
00:12:49,900 --> 00:12:51,970
archiving of this information
is not going to come through

345
00:12:51,970 --> 00:12:53,000
the same paths.

346
00:12:53,000 --> 00:12:55,050
What you want to be doing to
make sure that this archive

347
00:12:55,050 --> 00:12:56,530
comes down properly
is store it in the

348
00:12:56,530 --> 00:12:58,390
persistent file store.

349
00:12:58,390 --> 00:13:00,500
And then you're going to want to
modify your runtime code so

350
00:13:00,500 --> 00:13:03,340
that it checks the persistent
file store for the existence

351
00:13:03,340 --> 00:13:05,490
of the zip first before actually
communicating with

352
00:13:05,490 --> 00:13:06,700
the rest of their system.

353
00:13:06,700 --> 00:13:07,930
So this is a benefit.

354
00:13:07,930 --> 00:13:10,940
This means that you are now
controlling how the assets are

355
00:13:10,940 --> 00:13:13,010
bundled, how they're
distributed, how they get to

356
00:13:13,010 --> 00:13:15,370
the user's machine, and how the
user machine responds to

357
00:13:15,370 --> 00:13:16,390
having them.

358
00:13:16,390 --> 00:13:17,710
This gives you a
lot of control.

359
00:13:17,710 --> 00:13:20,890
Again, this is important because
it optimizes for the

360
00:13:20,890 --> 00:13:21,930
user's experience.

361
00:13:21,930 --> 00:13:25,400
You can stream data in, you can
stream it out, et cetera.

362
00:13:25,400 --> 00:13:28,870
Now one of the bad sides of
archiving is twofold.

363
00:13:28,870 --> 00:13:31,240
First off is that you sort of
lose the ability to just

364
00:13:31,240 --> 00:13:32,830
randomly grab files
from the internet.

365
00:13:32,830 --> 00:13:34,500
You have to grab these
larger blobs.

366
00:13:34,500 --> 00:13:36,930
And these larger blobs then
sometimes take more time, so

367
00:13:36,930 --> 00:13:38,370
you have to make different
loading screens and

368
00:13:38,370 --> 00:13:40,310
asynchronous results and
all these other things.

369
00:13:40,310 --> 00:13:43,330
So you want to move towards
something called segmenting.

370
00:13:43,330 --> 00:13:45,090
Effectively, the idea behind
this is it you're not going to

371
00:13:45,090 --> 00:13:47,600
just create one large zip file
for all of your assets.

372
00:13:47,600 --> 00:13:50,440
You're going to create many
smaller archives.

373
00:13:50,440 --> 00:13:52,560
And these archives are going
to be bundle based upon

374
00:13:52,560 --> 00:13:54,370
different parameters
and metrics.

375
00:13:54,370 --> 00:13:57,500
For instance, you could say that
your original zip file is

376
00:13:57,500 --> 00:13:58,720
only five megs.

377
00:13:58,720 --> 00:14:01,330
That zip file contains
everything like the main menu

378
00:14:01,330 --> 00:14:03,790
and the starting guide so the
user can load your game and

379
00:14:03,790 --> 00:14:06,910
see a spinning character and do
their character creation.

380
00:14:06,910 --> 00:14:08,960
Meanwhile, it's actually
streaming in the other

381
00:14:08,960 --> 00:14:10,090
archive behind it.

382
00:14:10,090 --> 00:14:12,480
So this allows your user to get
into the game immediately,

383
00:14:12,480 --> 00:14:14,860
and then spend time doing
something instead of waiting

384
00:14:14,860 --> 00:14:17,090
for the loading bar to get
all their data in there.

385
00:14:17,090 --> 00:14:21,900
Another reason to segment your
assets is due to monetization.

386
00:14:21,900 --> 00:14:25,120
So let's say that your
particular game where you sell

387
00:14:25,120 --> 00:14:28,210
chunks of game content in
one gigabyte bursts.

388
00:14:28,210 --> 00:14:30,920
So chapter five, chapter
six, chapter seven.

389
00:14:30,920 --> 00:14:33,210
And there's a large demand for
each one of those from a

390
00:14:33,210 --> 00:14:34,510
monetization standpoint.

391
00:14:34,510 --> 00:14:35,610
What you're going to want to do
is you're going to want to

392
00:14:35,610 --> 00:14:38,370
segment each of those in two
separate monetization

393
00:14:38,370 --> 00:14:42,090
categories so that you don't
stream that data to the user

394
00:14:42,090 --> 00:14:43,990
until they've actually
paid you for it.

395
00:14:43,990 --> 00:14:47,070
Again, hosting and streaming
cost something.

396
00:14:47,070 --> 00:14:49,610
So you want to optimize the
content that you're streaming

397
00:14:49,610 --> 00:14:52,180
to the user based upon whether
or not they've paid you.

398
00:14:52,180 --> 00:14:54,600
You don't want to have a 15
gigabyte game, stream it all

399
00:14:54,600 --> 00:14:56,650
of the user, and only
have 2% of those

400
00:14:56,650 --> 00:14:57,700
users actually convert.

401
00:14:57,700 --> 00:14:59,060
That means you're going to be
wasting a lot of money.

402
00:14:59,060 --> 00:15:01,060
It doesn't make sense.

403
00:15:01,060 --> 00:15:05,400
With this though, you're going
to need some sort of manifest

404
00:15:05,400 --> 00:15:08,270
file because the final cool
thing about archiving and some

405
00:15:08,270 --> 00:15:11,330
sort of segmented set up is
you actually need a way to

406
00:15:11,330 --> 00:15:14,880
define what zips are invalid
and not invalid from the

407
00:15:14,880 --> 00:15:16,230
persistent file store.

408
00:15:16,230 --> 00:15:18,995
So the user will go grab a zip
from the net, they'll store it

409
00:15:18,995 --> 00:15:21,570
to the local persistent store,
and then you go upload a new

410
00:15:21,570 --> 00:15:23,930
zip because you've made balance
changes or whatnot.

411
00:15:23,930 --> 00:15:26,930
Now the user needs the ability
to query some sort of file

412
00:15:26,930 --> 00:15:28,960
that says whether or not that
zip is out of date.

413
00:15:28,960 --> 00:15:30,600
So that way, they say hey,
this is out of date.

414
00:15:30,600 --> 00:15:32,800
We need to go fetch it from
the server and update our

415
00:15:32,800 --> 00:15:34,190
local cache view.

416
00:15:34,190 --> 00:15:36,270
So basically you want to segment
all of your stuff

417
00:15:36,270 --> 00:15:38,860
based upon game resources,
monetization resources, and

418
00:15:38,860 --> 00:15:41,530
then create some sort of
manifest file that allows the

419
00:15:41,530 --> 00:15:44,910
client machine to keep
up with that data.

420
00:15:44,910 --> 00:15:47,040
Now let's talk about Google
App Engine specifically.

421
00:15:47,040 --> 00:15:49,020
Let's just focus on that for a
minute and say that that's

422
00:15:49,020 --> 00:15:50,970
where you're hosting
your concept.

423
00:15:50,970 --> 00:15:52,140
So you can store your segmented

424
00:15:52,140 --> 00:15:53,130
binary archives here.

425
00:15:53,130 --> 00:15:54,320
That's fantastic.

426
00:15:54,320 --> 00:15:56,910
This allows you to carefully
control your server costs.

427
00:15:56,910 --> 00:16:00,160
Again, this is a metric that
matters to you because how

428
00:16:00,160 --> 00:16:02,150
you're serving your data
directly relates to how much

429
00:16:02,150 --> 00:16:04,970
it costs you to serve
that data.

430
00:16:04,970 --> 00:16:07,620
Google App Engine allows you
to store any asset that's

431
00:16:07,620 --> 00:16:12,170
under 32 megabytes HTML style
or sort of direct store.

432
00:16:12,170 --> 00:16:14,500
Which means you just upload it
and it's no big deal and it's

433
00:16:14,500 --> 00:16:16,400
stored just like
any other file.

434
00:16:16,400 --> 00:16:19,110
It's sort of seamless
integration for you.

435
00:16:19,110 --> 00:16:21,430
You can read the documentation
on how exactly that works.

436
00:16:21,430 --> 00:16:24,150
For anything above 32 megabytes
though, you have to

437
00:16:24,150 --> 00:16:26,140
store it from a different
file store and that's

438
00:16:26,140 --> 00:16:27,110
the blobstore API.

439
00:16:27,110 --> 00:16:29,070
Now it's still hosted on Google
App Engine, but you

440
00:16:29,070 --> 00:16:31,130
have to use a separate
API to access it.

441
00:16:31,130 --> 00:16:32,690
And this is again really
important.

442
00:16:32,690 --> 00:16:35,710
This sort of forces you to
optimize how you're getting

443
00:16:35,710 --> 00:16:38,630
your data, because there may
be tiered costs available.

444
00:16:38,630 --> 00:16:41,060
There may be specifics streaming
solutions you need

445
00:16:41,060 --> 00:16:41,960
to be aware of.

446
00:16:41,960 --> 00:16:44,400
This is important stuff.

447
00:16:44,400 --> 00:16:46,560
Also for that, you need
to set the browser

448
00:16:46,560 --> 00:16:47,900
cache expiration date.

449
00:16:47,900 --> 00:16:51,330
So any of this binary data
that's served from Google App

450
00:16:51,330 --> 00:16:53,900
Engine, when it hits the
client, the client's

451
00:16:53,900 --> 00:16:55,770
effectively going to
say here's how long

452
00:16:55,770 --> 00:16:57,140
this data is valid.

453
00:16:57,140 --> 00:16:59,380
Here's how long I think you
should keep this around.

454
00:16:59,380 --> 00:17:02,850
So the cache then has this large
amazing metric that says

455
00:17:02,850 --> 00:17:06,050
hey, all of these items in the
cache, they've expired, they

456
00:17:06,050 --> 00:17:09,030
can be expelled to bring
new data in.

457
00:17:09,030 --> 00:17:13,200
You can actually set the browser
time for that file.

458
00:17:13,200 --> 00:17:15,380
And if you click that link
there, you can actually set it

459
00:17:15,380 --> 00:17:16,619
to be some larger time.

460
00:17:16,619 --> 00:17:18,880
I think the default is
actually 10 minutes.

461
00:17:18,880 --> 00:17:21,800
So that means for a user playing
your game, let's say

462
00:17:21,800 --> 00:17:24,000
there's 56 hours of game play.

463
00:17:24,000 --> 00:17:27,089
If you don't set this particular
header for the data

464
00:17:27,089 --> 00:17:29,600
that's served to your client,
that means that the client,

465
00:17:29,600 --> 00:17:32,440
the browser, Chrome, the cache,
will say that after 10

466
00:17:32,440 --> 00:17:34,620
minutes, all that data can be
invalidated and flushed to

467
00:17:34,620 --> 00:17:35,190
something else.

468
00:17:35,190 --> 00:17:37,090
Now if you're using the
persistent file store, this

469
00:17:37,090 --> 00:17:38,710
shouldn't necessarily
be a big deal.

470
00:17:38,710 --> 00:17:41,300
But in some cases it's
still smart to set

471
00:17:41,300 --> 00:17:43,730
that expiration date.

472
00:17:43,730 --> 00:17:46,060
This brings us to a public
service announcement.

473
00:17:46,060 --> 00:17:50,880
Do not use the existence of data
on the user's machine to

474
00:17:50,880 --> 00:17:54,680
represent that the user has
purchased that data.

475
00:17:54,680 --> 00:17:57,230
So anyone in here who has
handled any sort of problems

476
00:17:57,230 --> 00:18:00,990
with piracy for video games
knows this to be true.

477
00:18:00,990 --> 00:18:04,190
Effectively, if a user purchases
your item and then

478
00:18:04,190 --> 00:18:08,060
refunds that purchase and the
item's data has been streamed

479
00:18:08,060 --> 00:18:11,410
to them and stored on disk and
the user who loads your game

480
00:18:11,410 --> 00:18:13,770
up, what happens?

481
00:18:13,770 --> 00:18:17,070
If your code actually goes
through and says, oh the sword

482
00:18:17,070 --> 00:18:18,610
of Antioch exists
on your desk.

483
00:18:18,610 --> 00:18:20,390
You must have access to it.

484
00:18:20,390 --> 00:18:22,300
Then the user could effectively
buy all the items,

485
00:18:22,300 --> 00:18:24,540
get them all downloaded, return
all the items. You

486
00:18:24,540 --> 00:18:26,580
don't get any money, but they
get all the free stuff.

487
00:18:26,580 --> 00:18:27,300
That's not good.

488
00:18:27,300 --> 00:18:28,840
You want to make sure that
you don't do it that way.

489
00:18:28,840 --> 00:18:29,870
So public service
announcement.

490
00:18:29,870 --> 00:18:31,915
Do not use the existence of
the data on the disc that

491
00:18:31,915 --> 00:18:34,310
you've streamed to the user to
represent the fact that the

492
00:18:34,310 --> 00:18:35,860
user has bought the item.

493
00:18:35,860 --> 00:18:36,590
Just don't do it.

494
00:18:36,590 --> 00:18:39,870
It's madness.

495
00:18:39,870 --> 00:18:41,120
Let's talk about databases.

496
00:18:41,120 --> 00:18:43,200

497
00:18:43,200 --> 00:18:45,360
This is again correlated
databases, so

498
00:18:45,360 --> 00:18:48,130
not like binary databases.

499
00:18:48,130 --> 00:18:51,600
So App Engine has relational
databases using

500
00:18:51,600 --> 00:18:53,230
the GQL query language.

501
00:18:53,230 --> 00:18:55,470
And if you click on the GQL
link, it'll take you to a nice

502
00:18:55,470 --> 00:18:58,080
amazing page that talks about
the syntax, how to use it, how

503
00:18:58,080 --> 00:18:58,680
not to use it.

504
00:18:58,680 --> 00:19:01,310
It also gives you great in-depth
examples about how to

505
00:19:01,310 --> 00:19:03,570
get started using it and all
these amazing things.

506
00:19:03,570 --> 00:19:05,540
As far as app Engine is
concerned, it really gives you

507
00:19:05,540 --> 00:19:08,710
the trifecta of hosting data,
hosting content, and also

508
00:19:08,710 --> 00:19:11,040
giving you database.

509
00:19:11,040 --> 00:19:13,990
The cool thing too is it
auto-scales to handle demand.

510
00:19:13,990 --> 00:19:16,590
This is the most important
thing.

511
00:19:16,590 --> 00:19:19,650
Let's say that you go a year and
a half of having your app

512
00:19:19,650 --> 00:19:21,490
online and nobody
downloads it.

513
00:19:21,490 --> 00:19:25,540
Then one day, you add in a cat
with a really cool pink wizard

514
00:19:25,540 --> 00:19:27,490
hat, then all of a sudden
the entire internet has

515
00:19:27,490 --> 00:19:28,760
to have your game.

516
00:19:28,760 --> 00:19:31,190
When the entire internet starts
knocking on your door,

517
00:19:31,190 --> 00:19:33,440
the servers for Google App
Engine will scale up

518
00:19:33,440 --> 00:19:35,340
dynamically to handle
that balance load.

519
00:19:35,340 --> 00:19:37,140
You don't have to do anything.

520
00:19:37,140 --> 00:19:38,620
If you've rented your
own servers, this

521
00:19:38,620 --> 00:19:39,950
is a massive problem.

522
00:19:39,950 --> 00:19:42,530
All of a sudden you need to
employ five IT guys and six

523
00:19:42,530 --> 00:19:45,480
more server racks and buy all
this hardware that then in

524
00:19:45,480 --> 00:19:47,220
another month you
may not need.

525
00:19:47,220 --> 00:19:49,220
So you've invested a lot of
sunk cost into something

526
00:19:49,220 --> 00:19:51,980
that's pretty much seasonal.

527
00:19:51,980 --> 00:19:53,250
The fact that App
Engine handles

528
00:19:53,250 --> 00:19:55,230
that for you is amazing.

529
00:19:55,230 --> 00:19:58,090
Of course, the cost is based
upon performance here.

530
00:19:58,090 --> 00:20:01,060
So this means that as more users
are using your service

531
00:20:01,060 --> 00:20:03,560
and monetizing through you
service, of course the cost

532
00:20:03,560 --> 00:20:04,240
goes up a little bit.

533
00:20:04,240 --> 00:20:06,410
The goal is to make sure that
the ratio between these two is

534
00:20:06,410 --> 00:20:09,280
always set in your favor.

535
00:20:09,280 --> 00:20:11,690
And to do this, to make sure
of this the first thing you

536
00:20:11,690 --> 00:20:12,940
need to do is make
sure the set the

537
00:20:12,940 --> 00:20:15,380
cache-time for any GET responses.

538
00:20:15,380 --> 00:20:17,440
And now a GET response on the
internet for those of you

539
00:20:17,440 --> 00:20:19,150
haven't used it, you
get effectively a

540
00:20:19,150 --> 00:20:21,540
POST and GET reset--

541
00:20:21,540 --> 00:20:26,410
a POST and GET message is
defined as either querying

542
00:20:26,410 --> 00:20:29,520
data from some database or
server or page versus setting

543
00:20:29,520 --> 00:20:31,820
data to that server or
database or page.

544
00:20:31,820 --> 00:20:34,170
Now again, a GET effectively
is a pull request.

545
00:20:34,170 --> 00:20:36,450
So what's occurring here
is that you're pulling

546
00:20:36,450 --> 00:20:38,340
information from Google
App Engine.

547
00:20:38,340 --> 00:20:41,690
And what's happening is when you
requests that data, Google

548
00:20:41,690 --> 00:20:44,340
App Engine will go find
that data, say OK,

549
00:20:44,340 --> 00:20:45,490
this result has occurred.

550
00:20:45,490 --> 00:20:48,670
I'm going to cache this away
in case this user or a next

551
00:20:48,670 --> 00:20:51,690
user or someone else goes and
tries to fetch the same data.

552
00:20:51,690 --> 00:20:54,000
If it finds it in its cache
automatically, it'll go ahead

553
00:20:54,000 --> 00:20:55,610
and return that data for you.

554
00:20:55,610 --> 00:20:58,920
But you need to set the
cache-time for that.

555
00:20:58,920 --> 00:21:02,190
Otherwise much like the Chrome
cache in the client's machine,

556
00:21:02,190 --> 00:21:03,740
it'll evict it based
upon duration.

557
00:21:03,740 --> 00:21:05,630
So here's how to do
that in Python.

558
00:21:05,630 --> 00:21:08,240
Again, there's great links on
the intertubes about how to do

559
00:21:08,240 --> 00:21:09,150
this directly.

560
00:21:09,150 --> 00:21:10,280
So we create a date object.

561
00:21:10,280 --> 00:21:13,580
We set it to a specific age
way, way in the future.

562
00:21:13,580 --> 00:21:16,170
And then in our response packet
that Google App Engine

563
00:21:16,170 --> 00:21:18,850
provides to the client, we
actually set the maximum age

564
00:21:18,850 --> 00:21:21,400
for that data to some
large metric.

565
00:21:21,400 --> 00:21:23,120
So this allows the clients
to then cache it on

566
00:21:23,120 --> 00:21:23,810
their side, as well.

567
00:21:23,810 --> 00:21:25,890
Which is good because then the
client says hey, I'm going to

568
00:21:25,890 --> 00:21:26,780
query the same data.

569
00:21:26,780 --> 00:21:28,010
I don't even have to
go to the internet.

570
00:21:28,010 --> 00:21:30,860
I just grab it locally.

571
00:21:30,860 --> 00:21:33,290
This brings us to the next point
is using Memcache which

572
00:21:33,290 --> 00:21:34,840
is on the server side of that.

573
00:21:34,840 --> 00:21:36,690
Click the link, get
more information.

574
00:21:36,690 --> 00:21:39,510
Memcache is effectively intended
for fast access to

575
00:21:39,510 --> 00:21:40,510
cache results of queries.

576
00:21:40,510 --> 00:21:43,110
Now again, you've got 100
million users all hitting your

577
00:21:43,110 --> 00:21:45,800
Google App Engine instance at
one time, all querying data,

578
00:21:45,800 --> 00:21:47,250
all grabbing it from different
directions.

579
00:21:47,250 --> 00:21:50,250
It would be great if you were
able to analyze that and

580
00:21:50,250 --> 00:21:52,940
figure out what the most common
things are and then

581
00:21:52,940 --> 00:21:54,320
optimize different
sets for that.

582
00:21:54,320 --> 00:21:56,710
Now if you don't have that
ability your or the stuff is

583
00:21:56,710 --> 00:21:58,910
just too far across the map,
then you want to use something

584
00:21:58,910 --> 00:22:01,010
called Memcache.

585
00:22:01,010 --> 00:22:02,360
And Memcache works like this.

586
00:22:02,360 --> 00:22:05,770
Effectively you test whether or
not the Memcache has some

587
00:22:05,770 --> 00:22:06,970
specific data.

588
00:22:06,970 --> 00:22:09,880
If it has the data, then
you return that data.

589
00:22:09,880 --> 00:22:12,710
So let's say the user says I
want to find out how many

590
00:22:12,710 --> 00:22:15,960
people are playing the game
right now in Argentina.

591
00:22:15,960 --> 00:22:19,030
And you store that
in into Memcache.

592
00:22:19,030 --> 00:22:20,750
It's already there, so you
return the number of people

593
00:22:20,750 --> 00:22:22,130
playing the game in Argentina.

594
00:22:22,130 --> 00:22:23,970
If it doesn't exist--
if the data hasn't

595
00:22:23,970 --> 00:22:25,180
been stored in Memcache--

596
00:22:25,180 --> 00:22:27,540
then you actually get the data,
find out how many people

597
00:22:27,540 --> 00:22:30,100
are playing, store it into
Memcache, and then return it

598
00:22:30,100 --> 00:22:30,800
to the user.

599
00:22:30,800 --> 00:22:32,560
So this means the next person
that comes through the says

600
00:22:32,560 --> 00:22:34,880
hey, I'm in Argentina, find the
number of people playing,

601
00:22:34,880 --> 00:22:36,110
it'll return the
proper result.

602
00:22:36,110 --> 00:22:38,460
And of course, there's a lot of
amazing things behind the

603
00:22:38,460 --> 00:22:41,050
scenes about what happens when
that data changes without them

604
00:22:41,050 --> 00:22:42,410
knowing about it, things
like that.

605
00:22:42,410 --> 00:22:44,360
We aren't going to
get into that.

606
00:22:44,360 --> 00:22:45,840
Click the link, learn more.

607
00:22:45,840 --> 00:22:46,525
Expand your horizons.

608
00:22:46,525 --> 00:22:49,510
Learn some new stuff today.

609
00:22:49,510 --> 00:22:53,320
So most of your clients will
again as we talked about have

610
00:22:53,320 --> 00:22:54,740
some sort of networked
component.

611
00:22:54,740 --> 00:22:56,870
You're going to want to
communicate with other players

612
00:22:56,870 --> 00:22:58,140
is the basic multiplayer
thing.

613
00:22:58,140 --> 00:22:58,840
You're on the internet.

614
00:22:58,840 --> 00:23:00,060
You want to play with
other people.

615
00:23:00,060 --> 00:23:02,080
Social is more fun.

616
00:23:02,080 --> 00:23:03,310
So there's one technique
to do.

617
00:23:03,310 --> 00:23:05,870
This is called polling, which
is effectively where each

618
00:23:05,870 --> 00:23:08,560
client that's connected to a
service will actually poll the

619
00:23:08,560 --> 00:23:10,490
server and say hey, has
anything changed.

620
00:23:10,490 --> 00:23:12,430
If something's changed, the
server pushes the data to the

621
00:23:12,430 --> 00:23:14,130
client through the request
process, and

622
00:23:14,130 --> 00:23:15,470
everyone moves forward.

623
00:23:15,470 --> 00:23:19,030
The problem with this is that
for low latency games, games

624
00:23:19,030 --> 00:23:22,260
where things only update once
every 5 minutes, 10 minutes,

625
00:23:22,260 --> 00:23:24,490
30 seconds, something like that,
you're going to spend a

626
00:23:24,490 --> 00:23:27,040
lot of time asking the server
for things effectively

627
00:23:27,040 --> 00:23:29,490
clogging your pipe,
upping your cost,

628
00:23:29,490 --> 00:23:31,550
et cetera, et cetera.

629
00:23:31,550 --> 00:23:34,130
And this can be avoided by using
something on Google App

630
00:23:34,130 --> 00:23:35,740
Engine called the Channel API.

631
00:23:35,740 --> 00:23:38,720
The Channel API effectively
allows your client to

632
00:23:38,720 --> 00:23:42,330
communicate the server and open
a pipe that stays open.

633
00:23:42,330 --> 00:23:44,990
So then the server when data
does change, like the number

634
00:23:44,990 --> 00:23:47,560
of players in Argentina, that
when that does change, the

635
00:23:47,560 --> 00:23:49,730
server tells the client hey,
this data has changed.

636
00:23:49,730 --> 00:23:51,440
I need you to update
on your side.

637
00:23:51,440 --> 00:23:53,910
This allows your client your
server to communicate only

638
00:23:53,910 --> 00:23:55,310
when they have to.

639
00:23:55,310 --> 00:23:56,970
And this is a good,
good thing.

640
00:23:56,970 --> 00:23:59,700
Because this means that your
overhead for communication is

641
00:23:59,700 --> 00:24:02,530
low, the amount of cost
spent on transfer and

642
00:24:02,530 --> 00:24:02,865
bandwidth is low.

643
00:24:02,865 --> 00:24:04,930
This Is a fantastic thing.

644
00:24:04,930 --> 00:24:07,110
One of the downsides with the
Channel API right now is that

645
00:24:07,110 --> 00:24:09,060
it can only communicate
with JavaScript.

646
00:24:09,060 --> 00:24:11,470
So this is really highlighted
and designed for

647
00:24:11,470 --> 00:24:12,910
web games in general.

648
00:24:12,910 --> 00:24:15,310
For those of you who want to
communicate with the Channel

649
00:24:15,310 --> 00:24:19,250
API on Google App Engine and
using C++ or some other sort

650
00:24:19,250 --> 00:24:22,130
of language, it's worth noting
that the Channel API is

651
00:24:22,130 --> 00:24:26,360
actually based upon a protocol
called XMPP.

652
00:24:26,360 --> 00:24:28,310
And effectively it wraps all
the communication and

653
00:24:28,310 --> 00:24:30,720
handshaking up into JavaScript
and provides a JavaScript

654
00:24:30,720 --> 00:24:31,600
library to you.

655
00:24:31,600 --> 00:24:34,490
Now if you are so inclined that
you would like to use

656
00:24:34,490 --> 00:24:37,980
this technology, feel free to
actually deconstruct what the

657
00:24:37,980 --> 00:24:39,680
JavaScript is wrapping and
figure out the proper

658
00:24:39,680 --> 00:24:41,520
handshakes and message
passing.

659
00:24:41,520 --> 00:24:42,900
That's up to you.

660
00:24:42,900 --> 00:24:45,630
I have talked with some people
and don't see any particular

661
00:24:45,630 --> 00:24:47,080
wrappers for different languages
in the pipe.

662
00:24:47,080 --> 00:24:48,530
But if there's a lot of
user demand, maybe

663
00:24:48,530 --> 00:24:49,260
we can change that.

664
00:24:49,260 --> 00:24:50,410
So email me.

665
00:24:50,410 --> 00:24:52,340
I'm here to help.

666
00:24:52,340 --> 00:24:53,490
Login and authentication.

667
00:24:53,490 --> 00:24:55,770
This is a pain point.

668
00:24:55,770 --> 00:25:00,220
So how many of you in here got
wanted to play a game and then

669
00:25:00,220 --> 00:25:03,970
as soon as it asks you to log
in or create an account, you

670
00:25:03,970 --> 00:25:06,000
just shut the game off.

671
00:25:06,000 --> 00:25:07,090
That's barrier zero.

672
00:25:07,090 --> 00:25:09,050
Like man, I just want
to play this game.

673
00:25:09,050 --> 00:25:10,130
Why do you need my data?

674
00:25:10,130 --> 00:25:11,430
I don't want to give
you my information.

675
00:25:11,430 --> 00:25:13,560
I'm afraid what you're going to
do with it or I don't want

676
00:25:13,560 --> 00:25:14,550
to get spammed.

677
00:25:14,550 --> 00:25:16,630
So let's talk about best
practices for login and

678
00:25:16,630 --> 00:25:18,560
authentication.

679
00:25:18,560 --> 00:25:20,020
So everyone's seen this.

680
00:25:20,020 --> 00:25:21,520
This is a standard login.

681
00:25:21,520 --> 00:25:22,330
Please login.

682
00:25:22,330 --> 00:25:24,940
If you don't have an account,
click here to create one.

683
00:25:24,940 --> 00:25:28,130
The problem is, your website
may have that, but so every

684
00:25:28,130 --> 00:25:29,020
other site on the internet.

685
00:25:29,020 --> 00:25:31,070
Everyone says I want to
create your login.

686
00:25:31,070 --> 00:25:32,180
I want to create an account.

687
00:25:32,180 --> 00:25:34,480
I want to hold user information,
et cetera.

688
00:25:34,480 --> 00:25:36,240
This is not beneficial
for the user.

689
00:25:36,240 --> 00:25:38,120
The user does not want
to come to your page

690
00:25:38,120 --> 00:25:38,900
to create an account.

691
00:25:38,900 --> 00:25:40,410
That's not the reason
they're there.

692
00:25:40,410 --> 00:25:41,960
The reason they're there
is to play your game.

693
00:25:41,960 --> 00:25:44,530
And you want to reduce the
barrier to that, because that

694
00:25:44,530 --> 00:25:46,070
means you'll get more money.

695
00:25:46,070 --> 00:25:48,860
So the goal here is rather than
asking the user to create

696
00:25:48,860 --> 00:25:52,350
an account, allow them to use an
existing account to login.

697
00:25:52,350 --> 00:25:54,720
And there's some great
technologies out there that

698
00:25:54,720 --> 00:25:55,170
allow this.

699
00:25:55,170 --> 00:25:56,185
One of them is OpenID.

700
00:25:56,185 --> 00:25:58,540
I'm going to talk about OpenID
here for a second.

701
00:25:58,540 --> 00:26:00,710
OpenID effectively
allows you--

702
00:26:00,710 --> 00:26:02,810
it's effectively
a decentralized

703
00:26:02,810 --> 00:26:04,030
authentication service.

704
00:26:04,030 --> 00:26:08,080
So the user can effectively use
multiple different logins

705
00:26:08,080 --> 00:26:09,410
to access your account.

706
00:26:09,410 --> 00:26:11,900
And effectively what occurs here
is the user will click

707
00:26:11,900 --> 00:26:14,340
their given account provider
that they want--

708
00:26:14,340 --> 00:26:16,840
Google, Yahoo, Blogger,
something like that.

709
00:26:16,840 --> 00:26:17,950
They'll click sign in.

710
00:26:17,950 --> 00:26:21,100
Sign in auto-direct the user
to another page handled by

711
00:26:21,100 --> 00:26:22,430
those providers.

712
00:26:22,430 --> 00:26:24,920
Authentication will occur
on their side.

713
00:26:24,920 --> 00:26:27,610
You will then get a proper
result saying did they pass or

714
00:26:27,610 --> 00:26:28,130
did they fail.

715
00:26:28,130 --> 00:26:29,950
So you don't even have to handle
all the handshaking.

716
00:26:29,950 --> 00:26:32,380
All you have to do is provide
the link, the information, let

717
00:26:32,380 --> 00:26:33,490
them let them handle it.

718
00:26:33,490 --> 00:26:34,830
This is fantastic.

719
00:26:34,830 --> 00:26:36,770
This means you get ti take all
of those different dialogues

720
00:26:36,770 --> 00:26:37,580
and bring them down.

721
00:26:37,580 --> 00:26:40,840
So the user can use something
they already have to login.

722
00:26:40,840 --> 00:26:41,710
Reduction of barriers.

723
00:26:41,710 --> 00:26:43,870
It's what we're all about.

724
00:26:43,870 --> 00:26:47,140
Now how this works with your
side though is that when the

725
00:26:47,140 --> 00:26:49,500
user logs in with one of these
other services or through

726
00:26:49,500 --> 00:26:52,240
OpenID, it's going to hand you
an authentication key.

727
00:26:52,240 --> 00:26:55,030
It's going to say here's
the GUID for this user.

728
00:26:55,030 --> 00:26:59,330
Now it's important that you do
not pass this user ID around

729
00:26:59,330 --> 00:27:00,190
sort of willynilly.

730
00:27:00,190 --> 00:27:01,990
This is a very important
concept here.

731
00:27:01,990 --> 00:27:04,200
So you're going to have your
relational data table here,

732
00:27:04,200 --> 00:27:05,650
and you're going to receive
that auth key.

733
00:27:05,650 --> 00:27:07,360
The problem is you're also going
to receive the auth key

734
00:27:07,360 --> 00:27:09,540
probably for a number of other
providers as well.

735
00:27:09,540 --> 00:27:11,810
So let's say you really want
to go the gamut here.

736
00:27:11,810 --> 00:27:14,090
You're allow the user to use
login their Google+ ID, with

737
00:27:14,090 --> 00:27:16,620
their Facebook ID, with their
Apple ID, and all these other

738
00:27:16,620 --> 00:27:17,460
sorts of things.

739
00:27:17,460 --> 00:27:20,660
You're going to have unique
IDs populating this table.

740
00:27:20,660 --> 00:27:22,570
So the question is there, if
you're going to hand those

741
00:27:22,570 --> 00:27:24,350
keys around, which one
do you pass around?

742
00:27:24,350 --> 00:27:25,370
Is the first one they uses?

743
00:27:25,370 --> 00:27:26,480
Is it the last one they use?

744
00:27:26,480 --> 00:27:29,560
It is some MD5 hash of all
the things concatenated.

745
00:27:29,560 --> 00:27:30,200
No.

746
00:27:30,200 --> 00:27:31,360
The better way to do
this is to actually

747
00:27:31,360 --> 00:27:32,650
create a user game key.

748
00:27:32,650 --> 00:27:35,200
So the first time the user logs
into your service, if

749
00:27:35,200 --> 00:27:38,180
their unique ID in some way,
shape, or form doesn't exist

750
00:27:38,180 --> 00:27:40,070
already in the database, go
ahead and create one and

751
00:27:40,070 --> 00:27:41,710
create a new user key.

752
00:27:41,710 --> 00:27:43,650
You want to use that
user key everywhere

753
00:27:43,650 --> 00:27:44,710
else in your database.

754
00:27:44,710 --> 00:27:47,630
So if you've got your primary
player information, the number

755
00:27:47,630 --> 00:27:51,070
of games they have, their
friends list, this should all

756
00:27:51,070 --> 00:27:54,030
be sorted by the game key that's
unique to your game,

757
00:27:54,030 --> 00:27:57,180
not the key that's unique to
their authentication provider.

758
00:27:57,180 --> 00:27:59,600
It's very important for you.

759
00:27:59,600 --> 00:28:01,670
In addition to this, this
is actually sort of an

760
00:28:01,670 --> 00:28:04,370
interesting concept that people
go back and forth on.

761
00:28:04,370 --> 00:28:06,690
On one side you, want to reduce
the barrier to the user

762
00:28:06,690 --> 00:28:09,110
logging into your service
because you want to make sure

763
00:28:09,110 --> 00:28:10,970
to make sure that they get
there, they get to play in the

764
00:28:10,970 --> 00:28:13,610
game, and they get the service
benefits from logging in that

765
00:28:13,610 --> 00:28:14,840
you provide for them.

766
00:28:14,840 --> 00:28:17,830
On the other side though, you
want to create a massive

767
00:28:17,830 --> 00:28:18,920
amount of security.

768
00:28:18,920 --> 00:28:22,380
I think one of the constant news
articles you have always

769
00:28:22,380 --> 00:28:24,430
showing up on the internet
is my account

770
00:28:24,430 --> 00:28:26,490
got hacked by blank.

771
00:28:26,490 --> 00:28:28,000
People are constantly losing
their accounts.

772
00:28:28,000 --> 00:28:29,490
They're constantly
losing their game

773
00:28:29,490 --> 00:28:30,810
progress, their servers.

774
00:28:30,810 --> 00:28:34,250
And within in-app purchase being
sort of where it is and

775
00:28:34,250 --> 00:28:38,490
the dominating force it has in
the monetization realm right

776
00:28:38,490 --> 00:28:41,400
now, you want to make sure that
users have a secure way

777
00:28:41,400 --> 00:28:44,160
of logging into your game and
keeping their content secure,

778
00:28:44,160 --> 00:28:46,990
so that their sister or their
brother or their angry ex

779
00:28:46,990 --> 00:28:49,500
doesn't go and do something
malicious.

780
00:28:49,500 --> 00:28:52,860
So one way to do this is
two-step security How this

781
00:28:52,860 --> 00:28:55,580
works is that the user logs in
with their first ID, so their

782
00:28:55,580 --> 00:28:56,850
username and the password.

783
00:28:56,850 --> 00:29:00,150
And they're then prompted to
enter a verification code

784
00:29:00,150 --> 00:29:02,150
generated by some application.

785
00:29:02,150 --> 00:29:04,180
Now this application could come
in many forms. It could

786
00:29:04,180 --> 00:29:08,830
be a key ring that has
information associated to it.

787
00:29:08,830 --> 00:29:10,840
It can come from your mobile
phone, et cetera, et cetera.

788
00:29:10,840 --> 00:29:13,770
But the purpose is that the user
has to then authenticate

789
00:29:13,770 --> 00:29:17,400
with a random number that's
generated on some time series.

790
00:29:17,400 --> 00:29:20,770
So for you or random person to
access someone else's account

791
00:29:20,770 --> 00:29:23,400
that has two-step authentication
set up, you not

792
00:29:23,400 --> 00:29:25,400
only have to have their
username, but you have to have

793
00:29:25,400 --> 00:29:27,790
their password as well, and you
have to have their mobile

794
00:29:27,790 --> 00:29:31,910
phone and be able to get access
in their mobile phone

795
00:29:31,910 --> 00:29:33,980
to that program that actually
provides this key.

796
00:29:33,980 --> 00:29:36,970
Now this is pretty good security
across the board.

797
00:29:36,970 --> 00:29:40,700
The good news is for you that
you can set up this service on

798
00:29:40,700 --> 00:29:43,840
your web server and on your
account for free and use it

799
00:29:43,840 --> 00:29:46,390
for free, and provide it
to your users for free.

800
00:29:46,390 --> 00:29:48,350
Really there's no reason
to not allow this.

801
00:29:48,350 --> 00:29:49,710
Now don't force it.

802
00:29:49,710 --> 00:29:51,820
Allow your users to decide
if they want it or not.

803
00:29:51,820 --> 00:29:53,680
But there's no reason
to not do it.

804
00:29:53,680 --> 00:29:55,000
In fact there's a great link
here at the bottom.

805
00:29:55,000 --> 00:29:57,740
If you click that, it'll take to
page that has a JavaScript

806
00:29:57,740 --> 00:30:00,280
implementation, a server side
implementation, and actually

807
00:30:00,280 --> 00:30:03,060
shows you how to put the whole
thing together within like 20

808
00:30:03,060 --> 00:30:03,870
minutes of work.

809
00:30:03,870 --> 00:30:05,100
Now that's fantastic.

810
00:30:05,100 --> 00:30:07,890
And the cool thing is they can
use their existing Google

811
00:30:07,890 --> 00:30:10,540
authenticator application on
their iPhone or their Android

812
00:30:10,540 --> 00:30:12,035
phone, so they could
use your service.

813
00:30:12,035 --> 00:30:14,210
It's a great thing to do.

814
00:30:14,210 --> 00:30:15,860
Localization.

815
00:30:15,860 --> 00:30:17,180
This is a big one.

816
00:30:17,180 --> 00:30:18,170
Console developers.

817
00:30:18,170 --> 00:30:21,520
Let's see your hands if you've
ever ran into problems with

818
00:30:21,520 --> 00:30:22,640
localization.

819
00:30:22,640 --> 00:30:23,260
Everyone.

820
00:30:23,260 --> 00:30:23,900
Exactly.

821
00:30:23,900 --> 00:30:26,320
It's not a big deal.

822
00:30:26,320 --> 00:30:27,500
Localizing matters.

823
00:30:27,500 --> 00:30:29,890
And this should matter more as
a web game than any sort of

824
00:30:29,890 --> 00:30:32,220
console developer or any
PC developer has

825
00:30:32,220 --> 00:30:33,670
ever told you before.

826
00:30:33,670 --> 00:30:36,380
There are big markets
internationally.

827
00:30:36,380 --> 00:30:39,970
We've seen some games monetize
horribly in the States that

828
00:30:39,970 --> 00:30:42,530
completely blew up in Europe.

829
00:30:42,530 --> 00:30:44,310
Like David Hasselhoff.

830
00:30:44,310 --> 00:30:47,440
No one bought this guy's musical
album in America.

831
00:30:47,440 --> 00:30:50,750
But for some reason,
he's a pop diva in

832
00:30:50,750 --> 00:30:51,740
Europe and in Germany.

833
00:30:51,740 --> 00:30:52,480
I don't get.

834
00:30:52,480 --> 00:30:53,330
I didn't like his music.

835
00:30:53,330 --> 00:30:54,210
I listened to it.

836
00:30:54,210 --> 00:30:57,420
It wasn't for me, but
hey, I'm this guy.

837
00:30:57,420 --> 00:31:00,860
So the fact is that if you're
going actually take your game

838
00:31:00,860 --> 00:31:03,100
and move it into these markets
to try to capitalize on the

839
00:31:03,100 --> 00:31:06,330
monetization opportunities
there, the first step you need

840
00:31:06,330 --> 00:31:07,830
to look at is language.

841
00:31:07,830 --> 00:31:11,370
Your game has a certain amount
of strings or certain amount

842
00:31:11,370 --> 00:31:13,850
of text that's being prompted
to the user.

843
00:31:13,850 --> 00:31:14,610
You've got menus.

844
00:31:14,610 --> 00:31:15,420
You got dialogues.

845
00:31:15,420 --> 00:31:16,680
You've got item descriptions.

846
00:31:16,680 --> 00:31:17,930
You've got cost description.

847
00:31:17,930 --> 00:31:19,190
You have quest understandings.

848
00:31:19,190 --> 00:31:21,620
You've got a lot of text.

849
00:31:21,620 --> 00:31:23,150
If you want to move into these
other markets, you need to

850
00:31:23,150 --> 00:31:25,470
communicate in their language
because not everyone speaks

851
00:31:25,470 --> 00:31:27,360
the language that you speak.

852
00:31:27,360 --> 00:31:29,340
The problem is that all the
languages don't act the same.

853
00:31:29,340 --> 00:31:32,130
For instance, the first problem
is the languages all

854
00:31:32,130 --> 00:31:33,470
read in different directions.

855
00:31:33,470 --> 00:31:37,080
So let's say you've created
this amazing storyline and

856
00:31:37,080 --> 00:31:40,300
your UI designer came through
created amazing UI for this

857
00:31:40,300 --> 00:31:43,170
for the storyline to present it
to the user and display it.

858
00:31:43,170 --> 00:31:45,810
The problem is when you put it
in Japanese, Japanese reads

859
00:31:45,810 --> 00:31:47,080
vertically instead
of horizontally.

860
00:31:47,080 --> 00:31:49,170
So what happens now?

861
00:31:49,170 --> 00:31:52,100
How does the UI stand
up to that?

862
00:31:52,100 --> 00:31:54,350
This sort of forces you to go
back and change your UI layout

863
00:31:54,350 --> 00:31:57,170
based upon the languages
that are available.

864
00:31:57,170 --> 00:32:00,610
In addition that, long words
and phrases are a problem.

865
00:32:00,610 --> 00:32:03,630
How the language is translated
in your language, English for

866
00:32:03,630 --> 00:32:06,170
example, to other languages,
German, may

867
00:32:06,170 --> 00:32:06,940
be completely different.

868
00:32:06,940 --> 00:32:10,670
Like what's 3 words or 15
characters in English maybe 37

869
00:32:10,670 --> 00:32:11,570
characters in German.

870
00:32:11,570 --> 00:32:14,060
A great story about this
is in-app purchase.

871
00:32:14,060 --> 00:32:17,370
So the in-app purchase guys had
originally created some

872
00:32:17,370 --> 00:32:21,180
specific UI and specific
dialogue, and had a specific

873
00:32:21,180 --> 00:32:24,960
window size and had it all
scaling and working perfectly.

874
00:32:24,960 --> 00:32:27,820
But when that data was
auto-translated to German,

875
00:32:27,820 --> 00:32:31,170
what happened was the text
actually pushed the buy button

876
00:32:31,170 --> 00:32:33,430
off the side of the
screen and you

877
00:32:33,430 --> 00:32:34,940
couldn't resize the window.

878
00:32:34,940 --> 00:32:36,820
So what happened was if you were
trying to buy this item

879
00:32:36,820 --> 00:32:38,930
in Germany, you couldn't buy it
because the buy button was

880
00:32:38,930 --> 00:32:40,840
completely gone.

881
00:32:40,840 --> 00:32:42,770
This is the type of problems
that you need to be thinking

882
00:32:42,770 --> 00:32:44,120
about with your UI.

883
00:32:44,120 --> 00:32:45,860
Of course, word wrap and
everything was implemented

884
00:32:45,860 --> 00:32:46,510
very quickly.

885
00:32:46,510 --> 00:32:48,570
And then everyone was able to
purchase, but the problem is

886
00:32:48,570 --> 00:32:50,810
that this is real.

887
00:32:50,810 --> 00:32:51,940
So how you do then.

888
00:32:51,940 --> 00:32:52,750
So let's say OK, cool.

889
00:32:52,750 --> 00:32:54,500
I want to localize my product.

890
00:32:54,500 --> 00:32:57,420
The first step is detecting
the user's language.

891
00:32:57,420 --> 00:32:59,670
In JavaScript, you can use a
nifty little function here

892
00:32:59,670 --> 00:33:00,750
navigator.language.

893
00:33:00,750 --> 00:33:02,360
Simple and easy to use.

894
00:33:02,360 --> 00:33:05,010
The problem is that this
actually isn't

895
00:33:05,010 --> 00:33:06,380
changeable by the user.

896
00:33:06,380 --> 00:33:09,310
So if the user actually goes
into their browser and checks

897
00:33:09,310 --> 00:33:12,820
the language in their browser,
it doesn't change the result

898
00:33:12,820 --> 00:33:13,780
of navigator.language.

899
00:33:13,780 --> 00:33:15,430
This is actually a common
problem that

900
00:33:15,430 --> 00:33:17,000
everyone deals with.

901
00:33:17,000 --> 00:33:20,070
What it does change, though,
is it changes is the

902
00:33:20,070 --> 00:33:23,850
HTTPaccept header when you're
doing a GET or SET response.

903
00:33:23,850 --> 00:33:26,750
So there's kind of a work around
in hack, but I'm giving

904
00:33:26,750 --> 00:33:28,365
a fast pass here so you
don't have to deal

905
00:33:28,365 --> 00:33:29,790
with the same problem.

906
00:33:29,790 --> 00:33:32,380
So what you can do it this is
knowing that the GET and SET

907
00:33:32,380 --> 00:33:34,520
requests actually have the real
language that the user

908
00:33:34,520 --> 00:33:37,910
has set in their browser, you
could actually poll a server

909
00:33:37,910 --> 00:33:39,260
and get the result back
and that'll have the

910
00:33:39,260 --> 00:33:40,430
real language in it.

911
00:33:40,430 --> 00:33:42,030
And here's how to do that.

912
00:33:42,030 --> 00:33:43,670
There's a great website
up there called

913
00:33:43,670 --> 00:33:45,850
ajaxhttpheaders.appspot.com.

914
00:33:45,850 --> 00:33:46,890
He's a very generous guy.

915
00:33:46,890 --> 00:33:49,430
You can click the link at the
bottom to go his post about

916
00:33:49,430 --> 00:33:50,650
how he did all this stuff.

917
00:33:50,650 --> 00:33:52,780
But effectively, you
send off an AJAX

918
00:33:52,780 --> 00:33:55,000
request to that location.

919
00:33:55,000 --> 00:33:57,755
When you get your response,
you query for a specific

920
00:33:57,755 --> 00:33:58,860
Accept-Language.

921
00:33:58,860 --> 00:34:01,310
And that's going to have the two
digit code that actually

922
00:34:01,310 --> 00:34:03,370
responds to the user's
language.

923
00:34:03,370 --> 00:34:05,550
Once you get that two digit
code, you can then pass that

924
00:34:05,550 --> 00:34:08,699
off your localization process
and that will then define

925
00:34:08,699 --> 00:34:11,159
which table you pull
strings from.

926
00:34:11,159 --> 00:34:13,429
The link at the bottom by the
way has the source code for

927
00:34:13,429 --> 00:34:15,600
the client side JavaScript
function which you're looking

928
00:34:15,600 --> 00:34:18,909
at here, as well as the server
side code which is posted at

929
00:34:18,909 --> 00:34:20,500
ajaxhttpheaders.

930
00:34:20,500 --> 00:34:23,090
And I think he actually has
a jQuery module as well.

931
00:34:23,090 --> 00:34:25,510
So if you're trying to
detect the language,

932
00:34:25,510 --> 00:34:28,150
navigator.language works well,
but this is actually sort of

933
00:34:28,150 --> 00:34:30,659
the definitive thing.

934
00:34:30,659 --> 00:34:33,360
Now the cool thing is-- and I
feel this isn't really a best

935
00:34:33,360 --> 00:34:35,300
practice, but this is important
to point this out as

936
00:34:35,300 --> 00:34:36,570
a tool chain process--

937
00:34:36,570 --> 00:34:38,500
is that there are some
tools to actually do

938
00:34:38,500 --> 00:34:39,610
translation for you.

939
00:34:39,610 --> 00:34:41,969
Most the time for game
development, you usually get

940
00:34:41,969 --> 00:34:45,639
all your strings in a file,
outsource that to some firm in

941
00:34:45,639 --> 00:34:49,120
Dublin usually is the case, and
they'll charge you some

942
00:34:49,120 --> 00:34:51,300
money and they'll give you back
everything translated.

943
00:34:51,300 --> 00:34:52,500
This doesn't always work.

944
00:34:52,500 --> 00:34:54,610
Like sometimes you need to
iterate on things, you don't

945
00:34:54,610 --> 00:34:55,639
have time to translating
or you don't

946
00:34:55,639 --> 00:34:56,830
have a budget to translate.

947
00:34:56,830 --> 00:34:58,980
There's some really cool tools
that Google provides that

948
00:34:58,980 --> 00:35:00,100
allows you to fix that.

949
00:35:00,100 --> 00:35:01,910
The first is Google Translate.

950
00:35:01,910 --> 00:35:04,190
So you can type in some stuff
on one side, convert it the

951
00:35:04,190 --> 00:35:05,050
other language on the other.

952
00:35:05,050 --> 00:35:05,990
This is easy.

953
00:35:05,990 --> 00:35:08,650
Copy, paste, you're
good to go.

954
00:35:08,650 --> 00:35:10,780
This doesn't work in situations
though where

955
00:35:10,780 --> 00:35:12,490
there's sort of live chat.

956
00:35:12,490 --> 00:35:13,890
So let's say you've got a
chat window up and I'm

957
00:35:13,890 --> 00:35:16,170
communicating to someone
who's speaking Spanish.

958
00:35:16,170 --> 00:35:17,870
I need the ability to
take my string and

959
00:35:17,870 --> 00:35:19,520
convert it to their language.

960
00:35:19,520 --> 00:35:22,700
Google Translate provides an API
where you can put in your

961
00:35:22,700 --> 00:35:25,065
language, put in what language
you want it to go to, and

962
00:35:25,065 --> 00:35:30,560
it'll return a packet with the
proper translated strength.

963
00:35:30,560 --> 00:35:33,810
In addition to that, it also
provide a detect function.

964
00:35:33,810 --> 00:35:35,650
So let's say the user is using
a language and they haven't

965
00:35:35,650 --> 00:35:37,980
specified it properly
or whatnot.

966
00:35:37,980 --> 00:35:40,470
Let the string get passed into
Google Translate API, and

967
00:35:40,470 --> 00:35:43,080
Google Translate will sort of
parse through its massive

968
00:35:43,080 --> 00:35:45,450
database of languages and words
and return to you what

969
00:35:45,450 --> 00:35:46,940
the language is.

970
00:35:46,940 --> 00:35:49,460
Now again this is fantastic
because you can use it sort of

971
00:35:49,460 --> 00:35:50,840
at a tool level.

972
00:35:50,840 --> 00:35:53,430
You could actually say write a
little application that will

973
00:35:53,430 --> 00:35:55,710
take all of your table strings
written in your source

974
00:35:55,710 --> 00:35:59,670
language like English, and for
each string send off a query

975
00:35:59,670 --> 00:36:00,920
to Google Translate
and it'll give you

976
00:36:00,920 --> 00:36:02,450
the translated string.

977
00:36:02,450 --> 00:36:04,670
This works, although
it takes some time.

978
00:36:04,670 --> 00:36:07,700
So the better solution is
actually to use an amazing

979
00:36:07,700 --> 00:36:10,010
product called Translator
Toolkit.

980
00:36:10,010 --> 00:36:12,420
And Translator Toolkit is free
for anyone to go and use.

981
00:36:12,420 --> 00:36:15,190
Translator Toolkit allows
you to upload a file--

982
00:36:15,190 --> 00:36:19,010
XML, HTML, CSV, things like
that-- and it'll actually

983
00:36:19,010 --> 00:36:21,400
translate the whole thing for
you just in one shot go.

984
00:36:21,400 --> 00:36:23,070
So this is actually the tool
you want to be using.

985
00:36:23,070 --> 00:36:25,020
If you've got all of your
strings segmented into

986
00:36:25,020 --> 00:36:27,490
different sections, you can take
each one of those files,

987
00:36:27,490 --> 00:36:31,000
upload it to Google Translator,
the Toolkit, hit

988
00:36:31,000 --> 00:36:32,160
the button, and it'll
push it out.

989
00:36:32,160 --> 00:36:35,120
Now the cool thing is here is it
actually allows you to step

990
00:36:35,120 --> 00:36:37,990
through each one of the items
that it's translated.

991
00:36:37,990 --> 00:36:41,550
So you can actually see Hello,
world see example blahblahblah

992
00:36:41,550 --> 00:36:43,770
actually gets translated
into this over here.

993
00:36:43,770 --> 00:36:46,300
I hope the Native Client team
does not mind me using their

994
00:36:46,300 --> 00:36:47,640
page for example purposes.

995
00:36:47,640 --> 00:36:50,795
So definitely use these tools
if you're doing translation.

996
00:36:50,795 --> 00:36:52,630
Let's talk about display
and rendering.

997
00:36:52,630 --> 00:36:53,340
So we've got a game.

998
00:36:53,340 --> 00:36:54,750
We've talked about the
server side aspects.

999
00:36:54,750 --> 00:36:55,810
Let's talk about the
client side.

1000
00:36:55,810 --> 00:36:56,390
The client side.

1001
00:36:56,390 --> 00:36:57,970
You're going to display
your game.

1002
00:36:57,970 --> 00:37:00,130
Let's talk about what
that means.

1003
00:37:00,130 --> 00:37:02,220
First off is this
is a modern web.

1004
00:37:02,220 --> 00:37:03,130
We have to face it.

1005
00:37:03,130 --> 00:37:05,370
If we really want people to
take gaming on the web

1006
00:37:05,370 --> 00:37:07,910
seriously and take all of the
skill sets that we've

1007
00:37:07,910 --> 00:37:10,980
acclimated over the past 30
years of gaming on PC and

1008
00:37:10,980 --> 00:37:14,610
gaming on consoles, we have to
talk about the GPU being used

1009
00:37:14,610 --> 00:37:16,420
in a web page and in
a web browser.

1010
00:37:16,420 --> 00:37:17,860
And the good news is,
we've got this.

1011
00:37:17,860 --> 00:37:21,190
We've got technologies like
OpenGL in Native Client.

1012
00:37:21,190 --> 00:37:24,150
We've got technologies like
WebGL, and we also have

1013
00:37:24,150 --> 00:37:25,840
technologies like
Hardware-Accelerated Canvas.

1014
00:37:25,840 --> 00:37:27,490
We'll talk about that
in a minute.

1015
00:37:27,490 --> 00:37:29,260
The important thing here those
is I'm sure you've all heard

1016
00:37:29,260 --> 00:37:31,600
the news that with these
technologies, you need to be

1017
00:37:31,600 --> 00:37:34,960
aware that some of the driver
implementations may not be

1018
00:37:34,960 --> 00:37:36,630
secure, may not be safe.

1019
00:37:36,630 --> 00:37:39,340
This means that potential
malicious users can write some

1020
00:37:39,340 --> 00:37:42,490
sort of code, a GPU-specific
code, that when a user loads

1021
00:37:42,490 --> 00:37:45,700
it on the local machine does
something nasty and gnarly.

1022
00:37:45,700 --> 00:37:48,030
For the most part, the teams
work in the modern browsers to

1023
00:37:48,030 --> 00:37:50,280
fix these, update these, and
make that sure these patches

1024
00:37:50,280 --> 00:37:50,820
are proper.

1025
00:37:50,820 --> 00:37:53,000
For the stuff they just can't
fix, there's actually a

1026
00:37:53,000 --> 00:37:54,560
presented blacklisted drivers.

1027
00:37:54,560 --> 00:37:57,630
They say that if you try to load
this content and you have

1028
00:37:57,630 --> 00:37:59,640
this driver on your
machine, nah.

1029
00:37:59,640 --> 00:38:00,420
Not going to happen.

1030
00:38:00,420 --> 00:38:00,910
Why?

1031
00:38:00,910 --> 00:38:03,950
Because the security risk is
more important than the

1032
00:38:03,950 --> 00:38:04,530
content viewing.

1033
00:38:04,530 --> 00:38:06,700
Now this is really important.

1034
00:38:06,700 --> 00:38:07,640
Think of you.

1035
00:38:07,640 --> 00:38:09,820
You are a developer and you put
content on the web, and

1036
00:38:09,820 --> 00:38:13,410
you put a game on the web and
the user goes to that site and

1037
00:38:13,410 --> 00:38:15,690
potentially is available for
some sort of hack or

1038
00:38:15,690 --> 00:38:16,950
something going on.

1039
00:38:16,950 --> 00:38:18,740
That's not good, because they're
going to come back and

1040
00:38:18,740 --> 00:38:21,130
say that it's your problem, not
the web browser's problem

1041
00:38:21,130 --> 00:38:22,380
or the malicious person's
problem or

1042
00:38:22,380 --> 00:38:23,520
someone else's problem.

1043
00:38:23,520 --> 00:38:24,350
So you like this.

1044
00:38:24,350 --> 00:38:27,020
You want to make sure that you
can detect if they have a

1045
00:38:27,020 --> 00:38:29,430
blacklisted driver, respond
to it early.

1046
00:38:29,430 --> 00:38:30,980
Here's I do that.

1047
00:38:30,980 --> 00:38:32,120
It's she really simple.

1048
00:38:32,120 --> 00:38:33,300
You take this little
snippet of code.

1049
00:38:33,300 --> 00:38:36,140
Effectively all you're doing in
JavaScript is you get the

1050
00:38:36,140 --> 00:38:39,660
canvas element and you try to
create a WebGL context.

1051
00:38:39,660 --> 00:38:42,890
If the WebGL context fails,
chances are the user either

1052
00:38:42,890 --> 00:38:46,390
has inadequate resources to
run the game, which you

1053
00:38:46,390 --> 00:38:48,490
wouldn't want them to be able to
run it anyway, or they have

1054
00:38:48,490 --> 00:38:49,650
a blacklisted driver.

1055
00:38:49,650 --> 00:38:52,460
In either case, running this
little script right here

1056
00:38:52,460 --> 00:38:54,560
before you start caching
or loading or doing any

1057
00:38:54,560 --> 00:38:57,210
processing is of vital
importance because you can

1058
00:38:57,210 --> 00:38:59,390
then tell the user hey,
something's wrong.

1059
00:38:59,390 --> 00:39:00,570
Go update, go do something.

1060
00:39:00,570 --> 00:39:01,850
Does need to.

1061
00:39:01,850 --> 00:39:04,030
In addition here-- you can
actually see something else--

1062
00:39:04,030 --> 00:39:07,330
is that if this passes, you can
actually do other tests

1063
00:39:07,330 --> 00:39:12,320
here like does your hardware
support this max texture size?

1064
00:39:12,320 --> 00:39:13,930
Which is also really
important.

1065
00:39:13,930 --> 00:39:16,360
You have to scale to make sure
that the hardware which is not

1066
00:39:16,360 --> 00:39:19,160
homogeneous can play well
with your game.

1067
00:39:19,160 --> 00:39:22,330
Now most internet users aren't
going to like this because

1068
00:39:22,330 --> 00:39:24,340
this means that I have to create
different versions of

1069
00:39:24,340 --> 00:39:26,730
my product for different
tiers of performance.

1070
00:39:26,730 --> 00:39:29,300
But in reality, PC developers
have had

1071
00:39:29,300 --> 00:39:30,280
this problem for years.

1072
00:39:30,280 --> 00:39:31,390
This is nothing new to us.

1073
00:39:31,390 --> 00:39:32,950
We've been dealing with
this a long time.

1074
00:39:32,950 --> 00:39:34,980
And the same problems and
the same solutions

1075
00:39:34,980 --> 00:39:35,740
have existed there.

1076
00:39:35,740 --> 00:39:38,430
This is a well-documented thing
about how to deal with.

1077
00:39:38,430 --> 00:39:40,520
So I suggest if this is an
issue that you're worried

1078
00:39:40,520 --> 00:39:43,870
about, definitely read up
on the documentation.

1079
00:39:43,870 --> 00:39:45,060
Now the next thing you
need to be concerned

1080
00:39:45,060 --> 00:39:46,610
with is sandbox rendering.

1081
00:39:46,610 --> 00:39:50,550
Now you have to understand that
again with these drivers

1082
00:39:50,550 --> 00:39:53,350
and the security issues
involved that we don't

1083
00:39:53,350 --> 00:39:55,760
actually allow the script code
that's being executed to go

1084
00:39:55,760 --> 00:39:57,000
right to the driver
and right to the

1085
00:39:57,000 --> 00:39:57,970
graphics processing unit.

1086
00:39:57,970 --> 00:40:00,640
This could expose a whole slew
of problems. So instead what

1087
00:40:00,640 --> 00:40:04,600
occurs is we actually put all
of the processing and direct

1088
00:40:04,600 --> 00:40:07,020
correlation with the APIs in
a separate process that's

1089
00:40:07,020 --> 00:40:07,790
running somewhere else.

1090
00:40:07,790 --> 00:40:10,770
So you got your main Chrome
process and you've got a

1091
00:40:10,770 --> 00:40:11,600
rendering process.

1092
00:40:11,600 --> 00:40:15,170
All of the data is then pushed
into an RPC buffer.

1093
00:40:15,170 --> 00:40:18,030
That RPC buffer will get the
commands and then some time in

1094
00:40:18,030 --> 00:40:20,450
the future, push them to
the render process.

1095
00:40:20,450 --> 00:40:22,730
And what this means you're sort
of creating a frame of

1096
00:40:22,730 --> 00:40:24,830
buffering and a frame of latency
in getting all this

1097
00:40:24,830 --> 00:40:26,830
through the pipe.

1098
00:40:26,830 --> 00:40:29,580
To dig into this a little bit
deeper, you have to be wary

1099
00:40:29,580 --> 00:40:31,270
and the reason this is the
problem is you're got to get

1100
00:40:31,270 --> 00:40:33,280
something called
a render stall.

1101
00:40:33,280 --> 00:40:34,930
Basically what happens is you're
going to do some work.

1102
00:40:34,930 --> 00:40:36,020
You're going to draw some
objects, you're going to

1103
00:40:36,020 --> 00:40:38,660
update some vertex buffers, and
you're going to fill in

1104
00:40:38,660 --> 00:40:40,830
your entire RPC buffer.

1105
00:40:40,830 --> 00:40:43,470
So that when you go to try and
do something that pushes in

1106
00:40:43,470 --> 00:40:44,665
that RPC buffer, it's
going to block.

1107
00:40:44,665 --> 00:40:46,420
It's going to say I've
got no more room.

1108
00:40:46,420 --> 00:40:48,940
What's going to happen there is
even though you're not done

1109
00:40:48,940 --> 00:40:51,280
with your frame and you have
all this other stuff to do,

1110
00:40:51,280 --> 00:40:54,030
it's going to insert a
sync FLUSH command,

1111
00:40:54,030 --> 00:40:55,370
effectively a glFinish.

1112
00:40:55,370 --> 00:40:57,390
What a sync FLUSH command's
going to do is it's going to

1113
00:40:57,390 --> 00:40:59,560
wait for that entire buffer
to be consumed

1114
00:40:59,560 --> 00:41:00,950
by the render process.

1115
00:41:00,950 --> 00:41:03,270
And it's going to block your
calling application until that

1116
00:41:03,270 --> 00:41:04,630
work is done.

1117
00:41:04,630 --> 00:41:06,420
So what's going to happen
is you will be

1118
00:41:06,420 --> 00:41:07,450
chugging along fine.

1119
00:41:07,450 --> 00:41:10,440
You'll see that the timing
observation for draw objects

1120
00:41:10,440 --> 00:41:12,200
and update VBs is pretty
much consistent.

1121
00:41:12,200 --> 00:41:14,190
And then all of a sudden,
you're going to hit 30

1122
00:41:14,190 --> 00:41:15,860
milliseconds draw
object frame.

1123
00:41:15,860 --> 00:41:17,290
And this is not ideal, because
you're going to

1124
00:41:17,290 --> 00:41:18,010
try to drill down.

1125
00:41:18,010 --> 00:41:20,850
You're going to be like why is
this one draw object taking so

1126
00:41:20,850 --> 00:41:23,140
long, and if I move it around
it's not in the same spot and

1127
00:41:23,140 --> 00:41:23,500
oh, my God.

1128
00:41:23,500 --> 00:41:24,360
What's happening?

1129
00:41:24,360 --> 00:41:26,280
What's happening is it has
nothing to do with the way

1130
00:41:26,280 --> 00:41:27,140
you're calling the API.

1131
00:41:27,140 --> 00:41:29,380
It has everything to do with
what API's doing on the back

1132
00:41:29,380 --> 00:41:31,270
end that you have very
little control over.

1133
00:41:31,270 --> 00:41:32,945
But you do have some control.

1134
00:41:32,945 --> 00:41:35,290
And This is really important.

1135
00:41:35,290 --> 00:41:38,270
Swap buffers at the end of a
frame for rendering in WebGL

1136
00:41:38,270 --> 00:41:41,270
or OpenGL ES 2.0 in Native
Client will actually kick off

1137
00:41:41,270 --> 00:41:42,740
a glFinish call on
your behalf.

1138
00:41:42,740 --> 00:41:45,850
And what this does is it
actually force the RPC buffer

1139
00:41:45,850 --> 00:41:47,600
to get flushed for you.

1140
00:41:47,600 --> 00:41:52,180
Now the intent here is can we
insert flushes ahead of time

1141
00:41:52,180 --> 00:41:54,990
to make sure that we never hit
one of these sync flushes.

1142
00:41:54,990 --> 00:41:57,070
So to do this, effectively what
you have to do is you

1143
00:41:57,070 --> 00:42:00,240
have to figure out the optimal
places to insert a glFlush

1144
00:42:00,240 --> 00:42:02,650
command in your rendering
process.

1145
00:42:02,650 --> 00:42:05,660
This will allow you to do some
drawing, flush the buffer, do

1146
00:42:05,660 --> 00:42:08,020
some more drawing, and flush
the buffer again.

1147
00:42:08,020 --> 00:42:10,600
This will keep you from ever
hitting the sync flush if you

1148
00:42:10,600 --> 00:42:11,140
do it right.

1149
00:42:11,140 --> 00:42:14,140
You may hit it every now again
in periods of high bandwidth

1150
00:42:14,140 --> 00:42:15,920
or high amount of processing
churn.

1151
00:42:15,920 --> 00:42:18,720
But the goal is to analyze your
system, figure out where

1152
00:42:18,720 --> 00:42:22,820
the heavy points are, in insert
these manual flushes in

1153
00:42:22,820 --> 00:42:27,530
strategic positions to reduce
and keep that pipeline moving

1154
00:42:27,530 --> 00:42:28,720
as efficient as possible.

1155
00:42:28,720 --> 00:42:30,520
Think of it like a factory.

1156
00:42:30,520 --> 00:42:31,950
Like you're trying to build
cars, you're trying to keep

1157
00:42:31,950 --> 00:42:33,580
everything going through smooth
so that there's no

1158
00:42:33,580 --> 00:42:36,560
pipeline bottlenecks.

1159
00:42:36,560 --> 00:42:37,450
So canvas rendering.

1160
00:42:37,450 --> 00:42:40,170
I talked about this.

1161
00:42:40,170 --> 00:42:43,410
The latest versions of Chrome
actually have GPU accelerated

1162
00:42:43,410 --> 00:42:44,810
campus rendering.

1163
00:42:44,810 --> 00:42:48,160
I believe this is unveiled
as default in Chrome 17.

1164
00:42:48,160 --> 00:42:49,440
It might be Chrome 16.

1165
00:42:49,440 --> 00:42:51,060
Fact check me on that.

1166
00:42:51,060 --> 00:42:53,200
But what this means is that
you as a developer can

1167
00:42:53,200 --> 00:42:56,030
actually just use the same
canvas commands--

1168
00:42:56,030 --> 00:42:58,860
draw, tesselate, do all
these other things--

1169
00:42:58,860 --> 00:43:01,100
and behind the scenes Chrome
will actually go through and

1170
00:43:01,100 --> 00:43:02,710
use the GPU on your behalf.

1171
00:43:02,710 --> 00:43:05,820
This is amazing because this
means that all of the concept

1172
00:43:05,820 --> 00:43:08,690
and all of the nuances of
managing texture state,

1173
00:43:08,690 --> 00:43:10,690
setting data, and doing all this
other stuff is handled

1174
00:43:10,690 --> 00:43:11,890
behind the scenes
on your behalf.

1175
00:43:11,890 --> 00:43:12,320
That's great.

1176
00:43:12,320 --> 00:43:13,820
That means you can just make
your game and focus

1177
00:43:13,820 --> 00:43:14,750
on making your game.

1178
00:43:14,750 --> 00:43:16,210
It's definitely hand-free
usage.

1179
00:43:16,210 --> 00:43:17,280
It's behind the scenes.

1180
00:43:17,280 --> 00:43:20,110
And the user most importantly
can toggle this with a flag.

1181
00:43:20,110 --> 00:43:23,750
So if by some chance they've got
a beefier CPU than they do

1182
00:43:23,750 --> 00:43:27,580
a GPU, the user can then go in
toggle, turnoff hardware

1183
00:43:27,580 --> 00:43:30,570
accelerated canvas, and go
back to the CPU path.

1184
00:43:30,570 --> 00:43:33,290
We see this commonly in
notebooks or netbooks that may

1185
00:43:33,290 --> 00:43:35,980
have like six cores sitting
around but still have an

1186
00:43:35,980 --> 00:43:41,560
integrated graphics chip that
can't run Shader Model 1.1.

1187
00:43:41,560 --> 00:43:41,880
Cool.

1188
00:43:41,880 --> 00:43:43,780
So you've got all this stuff
working forward.

1189
00:43:43,780 --> 00:43:44,880
You've got this game
environment.

1190
00:43:44,880 --> 00:43:45,600
You've got it all set up.

1191
00:43:45,600 --> 00:43:47,080
Let's talk about the platform
environment.

1192
00:43:47,080 --> 00:43:48,920
So now that you're doing a web
game, let's talk about some

1193
00:43:48,920 --> 00:43:51,040
things you have to
be aware of.

1194
00:43:51,040 --> 00:43:53,470
Users will tab away
from your game.

1195
00:43:53,470 --> 00:43:55,780
If you're running in a browser,
users consistently

1196
00:43:55,780 --> 00:43:58,680
tab across to check their
email, during a loading

1197
00:43:58,680 --> 00:44:02,210
screen, or they get a chat, or
Groupon pops up and says, oh

1198
00:44:02,210 --> 00:44:05,260
my gosh, there's an amazing
cat for sale in Southern

1199
00:44:05,260 --> 00:44:05,860
California.

1200
00:44:05,860 --> 00:44:08,240
Like there's different reasons
for you to tab away.

1201
00:44:08,240 --> 00:44:10,160
You can detect this, and this
is an important thing.

1202
00:44:10,160 --> 00:44:12,720
You can actually listen for the
visibilitychange event in

1203
00:44:12,720 --> 00:44:13,630
JavaScript.

1204
00:44:13,630 --> 00:44:15,200
And that visibilitychange
event will give you a

1205
00:44:15,200 --> 00:44:17,490
notification when the user
has tabbed away.

1206
00:44:17,490 --> 00:44:19,590
And you need to respond
according to this so.

1207
00:44:19,590 --> 00:44:21,450
So for instance, you need to
pause the game first off.

1208
00:44:21,450 --> 00:44:23,240
If the player's in a multiplayer
match or doing

1209
00:44:23,240 --> 00:44:25,980
something important, you don't
want them tabbing away to

1210
00:44:25,980 --> 00:44:27,530
cause a problem in the game.

1211
00:44:27,530 --> 00:44:29,340
You want to make sure that you
pause properly and make sure

1212
00:44:29,340 --> 00:44:30,720
everything's kosher.

1213
00:44:30,720 --> 00:44:33,170
You can also reduce or
turn off volume.

1214
00:44:33,170 --> 00:44:34,160
This depends on your game.

1215
00:44:34,160 --> 00:44:36,580
Some people just choose to
reduce the volume so you kind

1216
00:44:36,580 --> 00:44:38,000
of notice that you're
still playing a game

1217
00:44:38,000 --> 00:44:39,290
and aware of it.

1218
00:44:39,290 --> 00:44:41,450
If you turn off the volume,
sometimes it's easy for the

1219
00:44:41,450 --> 00:44:43,910
user to forget they're
playing.

1220
00:44:43,910 --> 00:44:47,170
It's also worth noting that
setInterval during the time

1221
00:44:47,170 --> 00:44:50,260
that the user is a way will
actually slow down to about a

1222
00:44:50,260 --> 00:44:53,000
1,000 milliseconds, so about one
second pulses for anything

1223
00:44:53,000 --> 00:44:54,110
using setInterval.

1224
00:44:54,110 --> 00:44:55,880
If you're using
RequestAnimationFrame, it will

1225
00:44:55,880 --> 00:44:56,810
stop completely.

1226
00:44:56,810 --> 00:44:59,150
So make sure that you're aware
of these things in JavaScript.

1227
00:44:59,150 --> 00:45:00,610
If you're using either
setInterval or

1228
00:45:00,610 --> 00:45:03,180
RequestAnimationFrame and the
user tabs away, these things

1229
00:45:03,180 --> 00:45:03,690
will occur.

1230
00:45:03,690 --> 00:45:06,180
And you need to respond
accordingly to them.

1231
00:45:06,180 --> 00:45:07,250
Bugs in the wild.

1232
00:45:07,250 --> 00:45:10,310
So users will run your product,
and they will run

1233
00:45:10,310 --> 00:45:12,760
your product on their machine in
their environment on their

1234
00:45:12,760 --> 00:45:15,920
particular test harnesses with
their particular installation

1235
00:45:15,920 --> 00:45:18,600
configurations and extensions
and pop-ups and everything

1236
00:45:18,600 --> 00:45:19,670
else that's all there.

1237
00:45:19,670 --> 00:45:21,280
And they're going to hit
a bug sooner or later.

1238
00:45:21,280 --> 00:45:22,870
It's just the configuration
world.

1239
00:45:22,870 --> 00:45:25,780
Your job is to detect this on
their machine and get the

1240
00:45:25,780 --> 00:45:27,880
information back in an
appropriate way so that you

1241
00:45:27,880 --> 00:45:30,015
can update your product to
be a better product.

1242
00:45:30,015 --> 00:45:32,330
Again all going back to
optimizing for the end user

1243
00:45:32,330 --> 00:45:33,550
experience.

1244
00:45:33,550 --> 00:45:34,750
So you can detect this.

1245
00:45:34,750 --> 00:45:37,560
So if the user has an error
that's thrown, you can use

1246
00:45:37,560 --> 00:45:38,670
window.onerror.

1247
00:45:38,670 --> 00:45:42,310
Or if you're using any browser
that implements v8, which is

1248
00:45:42,310 --> 00:45:47,520
Chrome's JavaScript virtual
machine, you can actually use

1249
00:45:47,520 --> 00:45:49,970
Error.captureStackTrace and
this will give you a full

1250
00:45:49,970 --> 00:45:51,650
stack trace to where
the error is.

1251
00:45:51,650 --> 00:45:53,530
Once you detect this, you need
to respond accordingly.

1252
00:45:53,530 --> 00:45:55,180
You need to gather
information.

1253
00:45:55,180 --> 00:45:58,330
So it's not just enough
sometimes to get your stack.

1254
00:45:58,330 --> 00:46:00,370
You actually need to gather
other information like the

1255
00:46:00,370 --> 00:46:03,690
game specific or game
state, the operating

1256
00:46:03,690 --> 00:46:04,860
system, the player ID.

1257
00:46:04,860 --> 00:46:07,650
Maybe this one player keeps
getting crashes, and you need

1258
00:46:07,650 --> 00:46:10,700
to correlate that
with who it is.

1259
00:46:10,700 --> 00:46:13,210
In addition to that, there's two
really cool things here,

1260
00:46:13,210 --> 00:46:16,690
window.performance and
chrome.tabs.captureVisibleTab.

1261
00:46:16,690 --> 00:46:18,910
These are excellent useful
resources as well, because it

1262
00:46:18,910 --> 00:46:21,140
allows you give a
bigger picture.

1263
00:46:21,140 --> 00:46:24,270
For instance, what if the reason
that the game keeps

1264
00:46:24,270 --> 00:46:26,100
crashing on this user's machine
is because they have

1265
00:46:26,100 --> 00:46:29,350
some extension installed that
allows them to arbitrarily

1266
00:46:29,350 --> 00:46:32,520
break point JavaScript or make
everything in a floating point

1267
00:46:32,520 --> 00:46:33,020
integer or something.

1268
00:46:33,020 --> 00:46:34,750
Who knows?

1269
00:46:34,750 --> 00:46:36,710
Querying these things allow
you to get better

1270
00:46:36,710 --> 00:46:38,170
visibility in that.

1271
00:46:38,170 --> 00:46:40,380
Once you get the information--
so you detected it, you've

1272
00:46:40,380 --> 00:46:41,740
gathered your information,
and now you need to

1273
00:46:41,740 --> 00:46:42,550
get it back to you.

1274
00:46:42,550 --> 00:46:44,100
And there's two primary
ways to do this.

1275
00:46:44,100 --> 00:46:45,790
The first of course is you
just spin up a thread and

1276
00:46:45,790 --> 00:46:47,020
shoot off an email to yourself,

1277
00:46:47,020 --> 00:46:48,720
which is fine and dandy.

1278
00:46:48,720 --> 00:46:50,880
Of course, you have to worry
about what that means to send

1279
00:46:50,880 --> 00:46:52,085
an email from the user's
account and

1280
00:46:52,085 --> 00:46:53,680
all this other stuff.

1281
00:46:53,680 --> 00:46:54,860
You can also upload it.

1282
00:46:54,860 --> 00:46:58,990
And there's two nice little
software solutions called

1283
00:46:58,990 --> 00:47:00,790
jsErrLog and jdrop.

1284
00:47:00,790 --> 00:47:01,580
Click the links.

1285
00:47:01,580 --> 00:47:02,140
Check those out.

1286
00:47:02,140 --> 00:47:04,350
Basically those allow you to
sort of upload some sort of

1287
00:47:04,350 --> 00:47:07,360
JSONized string data to a server
database somewhere, and

1288
00:47:07,360 --> 00:47:10,440
then you can come back at your
convenience and scrub through

1289
00:47:10,440 --> 00:47:13,570
the number of crashes for that
day, rank them, implement them

1290
00:47:13,570 --> 00:47:18,190
into your bug system, and
respond accordingly.

1291
00:47:18,190 --> 00:47:19,730
Now here's an interesting
point.

1292
00:47:19,730 --> 00:47:21,310
And a lot of people don't--

1293
00:47:21,310 --> 00:47:22,700
they sort of understand
this, but it's a

1294
00:47:22,700 --> 00:47:23,850
nuance that they miss--

1295
00:47:23,850 --> 00:47:25,250
is that you make sure
that your error

1296
00:47:25,250 --> 00:47:26,310
reporting is stable.

1297
00:47:26,310 --> 00:47:29,410
The most annoying thing I've
ever had to debug is my

1298
00:47:29,410 --> 00:47:30,560
debugging code.

1299
00:47:30,560 --> 00:47:33,150
Like my I'm finding a crash
that's being caused by

1300
00:47:33,150 --> 00:47:36,190
something that I can't use
because my code that's trying

1301
00:47:36,190 --> 00:47:37,350
to detect the crash
is actually the

1302
00:47:37,350 --> 00:47:38,720
thing causing the crash.

1303
00:47:38,720 --> 00:47:40,960
Like it's a sort of Inception,
[UNINTELLIGIBLE]

1304
00:47:40,960 --> 00:47:42,040
all the way down.

1305
00:47:42,040 --> 00:47:43,850
So make sure your error
reporting is stable.

1306
00:47:43,850 --> 00:47:48,090
When you do detect a user, it's
sort of best practices to

1307
00:47:48,090 --> 00:47:50,640
tell the user that you've
detected this and display it

1308
00:47:50,640 --> 00:47:53,250
to the user in some very
friendly methodology.

1309
00:47:53,250 --> 00:47:56,370
Make sure that you communicate
that it's not their fault.

1310
00:47:56,370 --> 00:47:58,440
Nothing's more annoying than a
game that tells me that I'm

1311
00:47:58,440 --> 00:47:59,630
playing it wrong.

1312
00:47:59,630 --> 00:48:01,060
Your users don't like that.

1313
00:48:01,060 --> 00:48:02,540
Definitely avoid technical
language.

1314
00:48:02,540 --> 00:48:04,160
When Chrome crashes,
what do get?

1315
00:48:04,160 --> 00:48:06,140
You get a little funny
icon that kind of

1316
00:48:06,140 --> 00:48:06,865
brightens your day.

1317
00:48:06,865 --> 00:48:08,720
And it says hey, something's
crashed.

1318
00:48:08,720 --> 00:48:11,940
Sometimes it says ah, snap
or he's dead, Jim.

1319
00:48:11,940 --> 00:48:12,450
It makes humor.

1320
00:48:12,450 --> 00:48:15,600
It makes light of the fact that
your data is somehow no

1321
00:48:15,600 --> 00:48:17,860
longer there but don't worry.

1322
00:48:17,860 --> 00:48:20,360
Grass will still grow, babies
will still laugh, and we will

1323
00:48:20,360 --> 00:48:23,950
recover your data at a
point in the future.

1324
00:48:23,950 --> 00:48:25,570
Once you display it,
make sure that you

1325
00:48:25,570 --> 00:48:27,070
respect your user's privacy.

1326
00:48:27,070 --> 00:48:29,810
Ensure that the user knows what
you're gathering, what

1327
00:48:29,810 --> 00:48:32,000
you're returning as far as
your data's concern.

1328
00:48:32,000 --> 00:48:33,520
And allow the user to opt-out.

1329
00:48:33,520 --> 00:48:35,260
This is just sort of
a nice thing to do.

1330
00:48:35,260 --> 00:48:37,050
Allow the user to say
you what, I know

1331
00:48:37,050 --> 00:48:37,810
what the problem was.

1332
00:48:37,810 --> 00:48:39,020
I was trying to hack
you system.

1333
00:48:39,020 --> 00:48:40,310
Please don't use this
information.

1334
00:48:40,310 --> 00:48:41,800
Or hey, I know what
the problem is.

1335
00:48:41,800 --> 00:48:42,860
It's this other plug-in.

1336
00:48:42,860 --> 00:48:44,060
Don't send the information
around.

1337
00:48:44,060 --> 00:48:46,590
Allow them to opt-out.

1338
00:48:46,590 --> 00:48:48,090
Once you've got your JavaScript
data, it's

1339
00:48:48,090 --> 00:48:50,370
important to minify
and obfuscate it.

1340
00:48:50,370 --> 00:48:51,440
This is actually really
important.

1341
00:48:51,440 --> 00:48:54,050
So your JavaScript code will
actually take up a large chunk

1342
00:48:54,050 --> 00:48:55,180
of your memory footprint.

1343
00:48:55,180 --> 00:48:58,770
And you want to reduce sort of
duplicate characters and white

1344
00:48:58,770 --> 00:49:01,930
spaces and other things so that
it's transferred to the

1345
00:49:01,930 --> 00:49:04,410
user in the most efficient
methodology possible for

1346
00:49:04,410 --> 00:49:06,260
JavaScript.

1347
00:49:06,260 --> 00:49:09,120
The closure compile offers this
as well as obfuscation.

1348
00:49:09,120 --> 00:49:11,820
So this will actually allow your
code to be obfuscated to

1349
00:49:11,820 --> 00:49:14,330
a level that a standard human
being just taking a look at

1350
00:49:14,330 --> 00:49:16,400
the code won't be able to
actually detect what's going

1351
00:49:16,400 --> 00:49:17,620
on inside of it.

1352
00:49:17,620 --> 00:49:19,510
They'll need to spend some time

1353
00:49:19,510 --> 00:49:23,000
deobfuscating it to get there.

1354
00:49:23,000 --> 00:49:25,530
plovr, I think is the proper
way to do this is sort of a

1355
00:49:25,530 --> 00:49:27,150
front end to the closure
compiler.

1356
00:49:27,150 --> 00:49:28,270
Definitely take a
look at that.

1357
00:49:28,270 --> 00:49:31,210
And HTML5 boiler plate also
contains some really amazing

1358
00:49:31,210 --> 00:49:34,460
tools for minimization and
obfuscation that you should be

1359
00:49:34,460 --> 00:49:37,290
looking at if you're writing
content in JavaScript that is

1360
00:49:37,290 --> 00:49:40,200
performance and size heavy.

1361
00:49:40,200 --> 00:49:40,890
User metrics.

1362
00:49:40,890 --> 00:49:42,130
Now we're getting into
the cool stuff.

1363
00:49:42,130 --> 00:49:46,200
So you should know who your
players are and you should be

1364
00:49:46,200 --> 00:49:48,260
using Google Analytics
to do this.

1365
00:49:48,260 --> 00:49:51,100
Now Google Analytics as I've
said before is traditionally a

1366
00:49:51,100 --> 00:49:54,260
web service that allows you to
track who's visiting your

1367
00:49:54,260 --> 00:49:56,630
site, where they're coming from,
what pages get the most

1368
00:49:56,630 --> 00:49:58,750
traffic, et cetera, et
cetera, et cetera.

1369
00:49:58,750 --> 00:50:00,380
But you can also kickoff custom

1370
00:50:00,380 --> 00:50:01,750
events, and this is amazing.

1371
00:50:01,750 --> 00:50:04,470
This means that from JavaScript,
you can kick off

1372
00:50:04,470 --> 00:50:08,220
an event that's attached to
something going on your game.

1373
00:50:08,220 --> 00:50:11,560
So you can say every time a
user, any user finishes level

1374
00:50:11,560 --> 00:50:14,240
two I'm going to report that to
Google Analytics and keep

1375
00:50:14,240 --> 00:50:15,420
that data around.

1376
00:50:15,420 --> 00:50:18,080
Now I don't have a slide for it,
but the tools for Google

1377
00:50:18,080 --> 00:50:19,610
Analytics are actually
really amazing.

1378
00:50:19,610 --> 00:50:22,560
They're kind of from the future
in terms of ability to

1379
00:50:22,560 --> 00:50:25,370
analyze data and look at it
for specific spikes and

1380
00:50:25,370 --> 00:50:26,790
reasons that you need.

1381
00:50:26,790 --> 00:50:28,980
So if you save things like
finish level 2, finish the

1382
00:50:28,980 --> 00:50:32,560
game, how many users chatted,
how many users joined a group,

1383
00:50:32,560 --> 00:50:34,310
how many users kicked
a chicken.

1384
00:50:34,310 --> 00:50:35,400
This is important information.

1385
00:50:35,400 --> 00:50:37,440
If you put chickens and you
allow a user to kick a

1386
00:50:37,440 --> 00:50:39,510
chicken, you should probably
figure out how many users are

1387
00:50:39,510 --> 00:50:41,770
actually doing that thing so you
can figure out whether or

1388
00:50:41,770 --> 00:50:43,680
not you need to make it
a quest or an upgrade.

1389
00:50:43,680 --> 00:50:47,470
Like hey, you've kicked
a million chickens.

1390
00:50:47,470 --> 00:50:49,160
Halo 3 did a great
job of this.

1391
00:50:49,160 --> 00:50:51,620
And this is actually one of the
first documented sort of

1392
00:50:51,620 --> 00:50:52,650
in the wild publications.

1393
00:50:52,650 --> 00:50:55,140
What you're looking at
here is a heat map.

1394
00:50:55,140 --> 00:50:57,790
What happened was the designers
of Halo 3 during the

1395
00:50:57,790 --> 00:51:00,600
early testing days started
logging every

1396
00:51:00,600 --> 00:51:01,990
place that a user died.

1397
00:51:01,990 --> 00:51:05,180
So any time a player died, they
put that point in space.

1398
00:51:05,180 --> 00:51:08,350
And then they would generate
these heat maps of specific

1399
00:51:08,350 --> 00:51:10,160
multiplayer maps every day.

1400
00:51:10,160 --> 00:51:13,040
And what you see here is in the
red, that's where all the

1401
00:51:13,040 --> 00:51:14,160
deaths occur.

1402
00:51:14,160 --> 00:51:16,270
You can see in the blue,
not so many deaths.

1403
00:51:16,270 --> 00:51:18,140
Now you can take this
information and then

1404
00:51:18,140 --> 00:51:21,120
correlate, hey, see
these red areas?

1405
00:51:21,120 --> 00:51:22,530
That's where all
the action is.

1406
00:51:22,530 --> 00:51:24,280
Why is all the action there?

1407
00:51:24,280 --> 00:51:27,120
Is there some sort of power up,
or is it a choke point, or

1408
00:51:27,120 --> 00:51:29,710
is it a strategic interest You
can then take this information

1409
00:51:29,710 --> 00:51:32,170
and go back to redesign
how your game works

1410
00:51:32,170 --> 00:51:33,430
based upon this data.

1411
00:51:33,430 --> 00:51:36,760
And you can do this through
Google Analytics kicking off

1412
00:51:36,760 --> 00:51:38,480
these custom events.

1413
00:51:38,480 --> 00:51:39,220
So the high points.

1414
00:51:39,220 --> 00:51:40,100
What do you want to track?

1415
00:51:40,100 --> 00:51:40,750
So let's say cool.

1416
00:51:40,750 --> 00:51:41,360
You buy into it.

1417
00:51:41,360 --> 00:51:41,900
You're going to use it.

1418
00:51:41,900 --> 00:51:43,040
What are you going to track?

1419
00:51:43,040 --> 00:51:44,880
You should use Google Analytics
for the number of

1420
00:51:44,880 --> 00:51:46,920
daily, weekly, and monthly users
that are actually using

1421
00:51:46,920 --> 00:51:47,840
your product.

1422
00:51:47,840 --> 00:51:50,410
You should track the number of
players coming from what site.

1423
00:51:50,410 --> 00:51:52,860
You should know whether or not
you're getting more players

1424
00:51:52,860 --> 00:51:56,180
from Rock, Paper, Shotgun versus
Kotaku, and know how to

1425
00:51:56,180 --> 00:51:57,920
respond accordingly to that.

1426
00:51:57,920 --> 00:52:01,130
You should definitely know how
many players actually click

1427
00:52:01,130 --> 00:52:01,750
the buy button.

1428
00:52:01,750 --> 00:52:02,860
That's super important.

1429
00:52:02,860 --> 00:52:05,290
Because you should also know
how many players actually

1430
00:52:05,290 --> 00:52:06,510
complete the buy button.

1431
00:52:06,510 --> 00:52:07,980
This is an important metric.

1432
00:52:07,980 --> 00:52:10,580
This tells you how many people
are dropping off inside of the

1433
00:52:10,580 --> 00:52:11,650
monetization process.

1434
00:52:11,650 --> 00:52:13,590
How many do were willing to
buy the product versus how

1435
00:52:13,590 --> 00:52:16,090
many people actually do.

1436
00:52:16,090 --> 00:52:18,510
Now for some things, Google
Analytics doesn't work well.

1437
00:52:18,510 --> 00:52:20,520
And in these cases, you should
probably propagate data back

1438
00:52:20,520 --> 00:52:21,720
to your own server.

1439
00:52:21,720 --> 00:52:23,960
For some in-game events,
this is probably the

1440
00:52:23,960 --> 00:52:25,030
best way to do it.

1441
00:52:25,030 --> 00:52:28,180
Like number of crashes, bugs,
specific errors, or anything

1442
00:52:28,180 --> 00:52:30,280
that may need some specific
processing that Google

1443
00:52:30,280 --> 00:52:33,280
Analytics isn't best
suited for.

1444
00:52:33,280 --> 00:52:34,130
AB testing.

1445
00:52:34,130 --> 00:52:35,820
This is a great thing you
should all be doing.

1446
00:52:35,820 --> 00:52:37,560
Now web developers know this.

1447
00:52:37,560 --> 00:52:40,960
They know that there is a secret
sauce to a better game.

1448
00:52:40,960 --> 00:52:42,770
And it comes from the fact
that there's a direct

1449
00:52:42,770 --> 00:52:45,230
disconnect between game
developers and users.

1450
00:52:45,230 --> 00:52:46,740
This is just the
way of things.

1451
00:52:46,740 --> 00:52:51,100
As a game developer, I super
think that this amazing quest

1452
00:52:51,100 --> 00:52:53,700
where I take a chicken and wear
it as a hat for three

1453
00:52:53,700 --> 00:52:56,450
hours is the most amazing,
visceral experience that every

1454
00:52:56,450 --> 00:52:58,170
player will ever go
through ever.

1455
00:52:58,170 --> 00:53:00,540
In reality, only two people play
this game, me and my mom

1456
00:53:00,540 --> 00:53:02,090
because I told her to play
it and give me feedback.

1457
00:53:02,090 --> 00:53:04,800
Now why I'm getting feedback
from my mom on a quest, that's

1458
00:53:04,800 --> 00:53:05,330
a different talk.

1459
00:53:05,330 --> 00:53:06,510
We'll talk about that later.

1460
00:53:06,510 --> 00:53:09,740
But the important thing is that
in order to connect with

1461
00:53:09,740 --> 00:53:12,370
my user which is the person
playing the game, I need a

1462
00:53:12,370 --> 00:53:15,370
different way to get
that information.

1463
00:53:15,370 --> 00:53:19,230
AB testing is the process of
issuing a separate build to a

1464
00:53:19,230 --> 00:53:22,450
percentage of your users in such
a way that you can then

1465
00:53:22,450 --> 00:53:25,530
track the results to determine
what your proper outcome is.

1466
00:53:25,530 --> 00:53:28,700
So for instance, the most simple
version of this is

1467
00:53:28,700 --> 00:53:30,680
currently our buy button
when you want to

1468
00:53:30,680 --> 00:53:31,930
buy an item is red.

1469
00:53:31,930 --> 00:53:34,000
What if we change
it to be blue?

1470
00:53:34,000 --> 00:53:36,540
Does that have any effect on
the amount of people that

1471
00:53:36,540 --> 00:53:37,890
monetize our game?

1472
00:53:37,890 --> 00:53:38,740
Let's find out.

1473
00:53:38,740 --> 00:53:41,820
Let's make a build with a blue
button, issue it to 50% of the

1474
00:53:41,820 --> 00:53:42,540
people that log in today.

1475
00:53:42,540 --> 00:53:44,360
50% of people keep
the red button.

1476
00:53:44,360 --> 00:53:46,280
Did we see any change?

1477
00:53:46,280 --> 00:53:49,720
If not, if so what does
that mean to you?

1478
00:53:49,720 --> 00:53:50,840
This allows you to
make changes that

1479
00:53:50,840 --> 00:53:51,680
optimize your outcome.

1480
00:53:51,680 --> 00:53:54,330
Because it's not just as simple
as what kind of button

1481
00:53:54,330 --> 00:53:54,850
color it is.

1482
00:53:54,850 --> 00:53:56,540
But it's also based
upon region.

1483
00:53:56,540 --> 00:53:59,340
Like do people in Germany
buy the same way

1484
00:53:59,340 --> 00:54:00,500
as people in America?

1485
00:54:00,500 --> 00:54:02,650
Could I change my layout
to optimize

1486
00:54:02,650 --> 00:54:03,850
for that region better?

1487
00:54:03,850 --> 00:54:06,380
You can actually create multiple
versions of your game

1488
00:54:06,380 --> 00:54:08,850
and your front end effectively
based upon region.

1489
00:54:08,850 --> 00:54:12,290
Like maybe in Japan, your game
needs more happy happy fun

1490
00:54:12,290 --> 00:54:12,770
time music.

1491
00:54:12,770 --> 00:54:15,460
You don't know that until you
issue AB testing to get to

1492
00:54:15,460 --> 00:54:17,320
that information.

1493
00:54:17,320 --> 00:54:17,680
All right.

1494
00:54:17,680 --> 00:54:20,230
The thing you've all been
waiting for-- monetization.

1495
00:54:20,230 --> 00:54:23,370
Our deep dark scientists here at
Google have taken a look at

1496
00:54:23,370 --> 00:54:25,410
monetization and what's been
working for games.

1497
00:54:25,410 --> 00:54:28,380
And in an anonymous fashion,
we're going to sort of report

1498
00:54:28,380 --> 00:54:30,190
some of the things that you
should be looking at if you're

1499
00:54:30,190 --> 00:54:32,210
developing web games today.

1500
00:54:32,210 --> 00:54:34,440
So the first off is that
monetization is a dark art.

1501
00:54:34,440 --> 00:54:37,080
What works for one game does
not work for every game.

1502
00:54:37,080 --> 00:54:39,800
And you need to make sure you
understand that first off.

1503
00:54:39,800 --> 00:54:42,350
You can't just grab a game and
say I'm going to monetize like

1504
00:54:42,350 --> 00:54:42,990
they're monetizing.

1505
00:54:42,990 --> 00:54:46,120
It has a lot to do with how
integrated it is with your

1506
00:54:46,120 --> 00:54:48,930
game, with your product, and
with your environment.

1507
00:54:48,930 --> 00:54:51,470
So with that being said, you
need to make sure that you're

1508
00:54:51,470 --> 00:54:53,240
holding the user's hand.

1509
00:54:53,240 --> 00:54:55,570
For instance, we go through
this entire process of

1510
00:54:55,570 --> 00:54:57,800
teaching the user how to play
the game, and we never teach

1511
00:54:57,800 --> 00:54:59,640
them how to purchase an item.

1512
00:54:59,640 --> 00:55:03,850
We've actually seen that the
games that include purchase in

1513
00:55:03,850 --> 00:55:08,800
the tutorial monetize on average
about 30% better than

1514
00:55:08,800 --> 00:55:10,390
those who don't.

1515
00:55:10,390 --> 00:55:12,300
That's amazing.

1516
00:55:12,300 --> 00:55:14,390
Just showing the user how to--

1517
00:55:14,390 --> 00:55:15,830
give them some free credits.

1518
00:55:15,830 --> 00:55:18,960
Let them buy something during
the tutorial to show them the

1519
00:55:18,960 --> 00:55:20,950
store so that they're
not afraid of it.

1520
00:55:20,950 --> 00:55:22,150
Show them what the
benefits are.

1521
00:55:22,150 --> 00:55:23,420
Allow them to browse around.

1522
00:55:23,420 --> 00:55:25,420
We've got some other cool
statistics that show the user

1523
00:55:25,420 --> 00:55:28,280
who do buy during that process
are tons more sticky.

1524
00:55:28,280 --> 00:55:31,320
We'll share that information
at a different time.

1525
00:55:31,320 --> 00:55:34,180
Most importantly with this is
why they should purchase.

1526
00:55:34,180 --> 00:55:36,840
Getting them early in this
process and showing them how

1527
00:55:36,840 --> 00:55:38,270
they should purchase
allows them to also

1528
00:55:38,270 --> 00:55:39,800
see why it's available.

1529
00:55:39,800 --> 00:55:41,810
Most of the time users play a
game, they don't have any

1530
00:55:41,810 --> 00:55:44,150
bearing or understanding about
what's available and why they

1531
00:55:44,150 --> 00:55:44,910
care about it.

1532
00:55:44,910 --> 00:55:47,700
For instance, I never knew there
was a sword of Antioch

1533
00:55:47,700 --> 00:55:49,440
that was worth 50-50 power.

1534
00:55:49,440 --> 00:55:52,400
It allowed me to assault
chickens from here until the

1535
00:55:52,400 --> 00:55:54,370
Great Gates of Nagral.

1536
00:55:54,370 --> 00:55:56,580
But now that I do know, I
want to buy that sword.

1537
00:55:56,580 --> 00:55:58,046
Getting them in there
and showing them

1538
00:55:58,046 --> 00:56:00,270
that item is important.

1539
00:56:00,270 --> 00:56:02,180
This is a great graph.

1540
00:56:02,180 --> 00:56:03,050
This is an amazing graph.

1541
00:56:03,050 --> 00:56:05,110
And if you've been reading
anything on monetization in

1542
00:56:05,110 --> 00:56:06,740
games recently, you should
already know

1543
00:56:06,740 --> 00:56:07,710
the outcome of this.

1544
00:56:07,710 --> 00:56:10,320
What this shows is three
line points.

1545
00:56:10,320 --> 00:56:13,250
This is from a particular
product that launched a full

1546
00:56:13,250 --> 00:56:15,390
version that you could
buy up front.

1547
00:56:15,390 --> 00:56:18,390
So you pay $5.99 and you get the
full version, and a free

1548
00:56:18,390 --> 00:56:19,770
version at the same time.

1549
00:56:19,770 --> 00:56:22,490
So they said pay $5
or don't pay $5.

1550
00:56:22,490 --> 00:56:23,770
I don't really care.

1551
00:56:23,770 --> 00:56:25,950
It also provided in-app purchase
so that you can

1552
00:56:25,950 --> 00:56:28,480
actually purchase items
in the game.

1553
00:56:28,480 --> 00:56:31,350
So you're looking at this
time line here.

1554
00:56:31,350 --> 00:56:33,620
In the blue on the bottom,
you're actually looking at the

1555
00:56:33,620 --> 00:56:34,280
full purchase.

1556
00:56:34,280 --> 00:56:37,160
So this is just the amount of
money that came from buying

1557
00:56:37,160 --> 00:56:39,260
the game, just without
anything else.

1558
00:56:39,260 --> 00:56:40,270
Just buy the game up front.

1559
00:56:40,270 --> 00:56:41,670
You can see that in the blue.

1560
00:56:41,670 --> 00:56:45,910
The green is the amount of money
made from the people who

1561
00:56:45,910 --> 00:56:48,490
bought the full game--
so upfront price--

1562
00:56:48,490 --> 00:56:50,120
as well as in-app purchase.

1563
00:56:50,120 --> 00:56:52,090
So they bought the game, they
spent $5, and then they spend

1564
00:56:52,090 --> 00:56:56,370
an additional $10 or $11
buying upgraded items.

1565
00:56:56,370 --> 00:56:59,070
The pink or the orange depending
on what your monitor

1566
00:56:59,070 --> 00:57:01,990
color is and how this gets
compressed on YouTube is

1567
00:57:01,990 --> 00:57:05,630
actually the total input
from the free app

1568
00:57:05,630 --> 00:57:07,210
just for in-app purchase.

1569
00:57:07,210 --> 00:57:09,210
Which means these people didn't
buy up front version.

1570
00:57:09,210 --> 00:57:11,340
They just spent all of their
money in the game actually

1571
00:57:11,340 --> 00:57:13,670
buying items. It's through
the roof in a

1572
00:57:13,670 --> 00:57:14,400
couple different places.

1573
00:57:14,400 --> 00:57:16,840
But in general, it just
over-monetizes everything.

1574
00:57:16,840 --> 00:57:18,620
And the reason for this
can be twofold.

1575
00:57:18,620 --> 00:57:21,040
Number one, it could be that the
number of users who got in

1576
00:57:21,040 --> 00:57:23,730
the door to buy the item
were much larger.

1577
00:57:23,730 --> 00:57:27,250
So let's say that the free
version to in-app purchase had

1578
00:57:27,250 --> 00:57:29,190
3x to 4x the number of users.

1579
00:57:29,190 --> 00:57:31,720
Or the users just felt more
generous because they didn't

1580
00:57:31,720 --> 00:57:33,680
already pay $5 to get
the application.

1581
00:57:33,680 --> 00:57:36,140
But the point of this graph--
and we're seeing other results

1582
00:57:36,140 --> 00:57:36,990
show this--

1583
00:57:36,990 --> 00:57:40,120
is that making your game free to
play, some content free to

1584
00:57:40,120 --> 00:57:44,140
play with some form of in-app
purchase for content expansion

1585
00:57:44,140 --> 00:57:46,510
is definitely the way to go.

1586
00:57:46,510 --> 00:57:48,250
Now once you do this though,
you're going to ask yourself

1587
00:57:48,250 --> 00:57:51,300
what kind of virtual goods
should I be selling?

1588
00:57:51,300 --> 00:57:53,340
If we're going to embrace this
in-app purchase thing, what

1589
00:57:53,340 --> 00:57:53,870
should I be doing?

1590
00:57:53,870 --> 00:57:56,970
There's a great graph by
Flurry that's online.

1591
00:57:56,970 --> 00:57:57,450
Go grab it.

1592
00:57:57,450 --> 00:57:58,110
Take a look at it.

1593
00:57:58,110 --> 00:58:00,730
Which actually shows the
breakdown of durable goods and

1594
00:58:00,730 --> 00:58:01,830
who's buying what.

1595
00:58:01,830 --> 00:58:05,010
So first off, we notice that
personalization items through

1596
00:58:05,010 --> 00:58:06,850
in-app purchase are
only about 2%.

1597
00:58:06,850 --> 00:58:10,580
So only about 2% of transactions
in this graph are

1598
00:58:10,580 --> 00:58:14,290
for hey, I would like to buy
that shiny chicken hat that

1599
00:58:14,290 --> 00:58:16,010
clucks any time I get next
to someone else who

1600
00:58:16,010 --> 00:58:17,210
has a chicken hat.

1601
00:58:17,210 --> 00:58:18,600
Only about 2%.

1602
00:58:18,600 --> 00:58:21,900
About 30% are durable items.
These are effectively items

1603
00:58:21,900 --> 00:58:24,610
that you buy and then keep the
rest of your gaming existence.

1604
00:58:24,610 --> 00:58:28,340
So the sword of Antioch that I
then keep until I'm level 90.

1605
00:58:28,340 --> 00:58:29,950
Only about 30% buy that.

1606
00:58:29,950 --> 00:58:32,550
Where the big money is actually
in consumable goods.

1607
00:58:32,550 --> 00:58:34,730
And basically consumable
goods are goods that

1608
00:58:34,730 --> 00:58:36,690
have a limited lifespan.

1609
00:58:36,690 --> 00:58:40,890
So pay $0.99 to get a speed
boost for the next hour.

1610
00:58:40,890 --> 00:58:44,750
Or also included in this item
is virtual currency.

1611
00:58:44,750 --> 00:58:47,720
So pay $5 to get 200 coins.

1612
00:58:47,720 --> 00:58:50,120
And then the coins can then be
used to purchase other items

1613
00:58:50,120 --> 00:58:51,220
in the game.

1614
00:58:51,220 --> 00:58:53,610
Virtual currency is considered
a consumable good.

1615
00:58:53,610 --> 00:58:55,830
And as you can see, that whole
section of consumables--

1616
00:58:55,830 --> 00:58:57,540
so limited lifetime objects--

1617
00:58:57,540 --> 00:59:01,400
are actually dominating how
people are buying nowadays.

1618
00:59:01,400 --> 00:59:03,240
So let's talk about virtual
currency for a second.

1619
00:59:03,240 --> 00:59:05,840
So if you have virtual currency,
the numbers actually

1620
00:59:05,840 --> 00:59:08,350
show that you should have a
multiple currency system.

1621
00:59:08,350 --> 00:59:10,290
Not a multiple virtual currency,
but a multiple

1622
00:59:10,290 --> 00:59:11,160
currency system.

1623
00:59:11,160 --> 00:59:13,800
So you should be able to allow
your users to effectively buy

1624
00:59:13,800 --> 00:59:17,750
premium currency from in-app
purchases, and then also have

1625
00:59:17,750 --> 00:59:20,510
some sort of grind currency
from game play.

1626
00:59:20,510 --> 00:59:23,830
So I play this level, I
kick a chicken, the

1627
00:59:23,830 --> 00:59:25,550
chicken drops one bronze.

1628
00:59:25,550 --> 00:59:25,840
Cool.

1629
00:59:25,840 --> 00:59:26,680
I got a bronze.

1630
00:59:26,680 --> 00:59:31,430
But then I can go and
buy for $5 100 gold.

1631
00:59:31,430 --> 00:59:34,140
And really the metric here this
starts getting cool is

1632
00:59:34,140 --> 00:59:36,650
that you allow trading
between currencies.

1633
00:59:36,650 --> 00:59:41,380
So I can turn my 100 gold into
5,000 copper or vice-versa.

1634
00:59:41,380 --> 00:59:44,100
And this creates this really
interesting dynamic that the

1635
00:59:44,100 --> 00:59:46,720
user feels like they're smart
because they feel like they're

1636
00:59:46,720 --> 00:59:47,460
in control.

1637
00:59:47,460 --> 00:59:50,380
They can either spend $5 to get
the item or they can go

1638
00:59:50,380 --> 00:59:52,820
grind for five hours to get
the same item and the same

1639
00:59:52,820 --> 00:59:54,860
cost and then translate between
the two to buy more

1640
00:59:54,860 --> 00:59:56,570
items. This is really cool.

1641
00:59:56,570 --> 00:59:58,660
Empowering your user and letting
them know that they're

1642
00:59:58,660 --> 01:00:01,420
in control and they feel smart
is the best way to monetize

1643
01:00:01,420 --> 01:00:03,480
and keep players coming back.

1644
01:00:03,480 --> 01:00:05,500
It also enables instant
gratification.

1645
01:00:05,500 --> 01:00:09,650
So if I go to buy an item and
I don't have enough virtual

1646
01:00:09,650 --> 01:00:12,160
currency sitting around, you
should probably allow the user

1647
01:00:12,160 --> 01:00:14,280
to buy that item without
virtual currency.

1648
01:00:14,280 --> 01:00:16,370
Nothing's more annoying than
saying I want to buy this

1649
01:00:16,370 --> 01:00:18,740
sword, but before I can actually
pay you for it, I

1650
01:00:18,740 --> 01:00:22,080
have to go buy 100 coin
points and then go

1651
01:00:22,080 --> 01:00:22,920
back and buy the sword.

1652
01:00:22,920 --> 01:00:23,320
No.

1653
01:00:23,320 --> 01:00:25,850
What you should say is hey, you
don't have enough credits

1654
01:00:25,850 --> 01:00:26,750
available to you.

1655
01:00:26,750 --> 01:00:30,240
Would you like to buy this sword
for face value at $7.99.

1656
01:00:30,240 --> 01:00:32,430
And this is also a great point
that once you present this to

1657
01:00:32,430 --> 01:00:34,750
the user, you actually have
a chance to upsell.

1658
01:00:34,750 --> 01:00:36,020
You've now got their
attention.

1659
01:00:36,020 --> 01:00:38,790
Hey, you don't have enough
points to buy this.

1660
01:00:38,790 --> 01:00:42,280
You can either buy it for $7.99
or what you could do is

1661
01:00:42,280 --> 01:00:43,970
buy 1,000 credits and
we'll give you the

1662
01:00:43,970 --> 01:00:46,490
sword for 50% off.

1663
01:00:46,490 --> 01:00:48,120
That's an interesting
correlation.

1664
01:00:48,120 --> 01:00:49,820
You now have the user's
attention.

1665
01:00:49,820 --> 01:00:53,280
It's tied to an object they
want, and they see value in a

1666
01:00:53,280 --> 01:00:54,720
different proposition.

1667
01:00:54,720 --> 01:00:57,186
That's really cool and you
should take advantage of that.

1668
01:00:57,186 --> 01:01:00,150
You should also take advantage
of simplified purchase flow.

1669
01:01:00,150 --> 01:01:03,260
So when the user wants to buy
your item, you should make it

1670
01:01:03,260 --> 01:01:05,270
as easy as possible
for them to do so.

1671
01:01:05,270 --> 01:01:07,380
So leverage in-app
payment APIs.

1672
01:01:07,380 --> 01:01:09,860
Rather than directing the user
to some other site that they

1673
01:01:09,860 --> 01:01:11,640
then have to go through that
site and get through that

1674
01:01:11,640 --> 01:01:14,010
purchase flow in and then get an
item and then come back and

1675
01:01:14,010 --> 01:01:15,750
enter a key code, that
just doesn't work.

1676
01:01:15,750 --> 01:01:18,190
You should be using
in-app APIs.

1677
01:01:18,190 --> 01:01:20,460
And some of these things
have great features.

1678
01:01:20,460 --> 01:01:23,440
So for example, you get access
to millions of credit cards

1679
01:01:23,440 --> 01:01:25,180
for these APIs.

1680
01:01:25,180 --> 01:01:26,910
You have powerful fraud
engines that

1681
01:01:26,910 --> 01:01:27,960
exist on the back side.

1682
01:01:27,960 --> 01:01:29,360
Plug and play purchase
flow through

1683
01:01:29,360 --> 01:01:30,630
JavaScript and whatnot.

1684
01:01:30,630 --> 01:01:32,050
And you get to play
in a few clicks.

1685
01:01:32,050 --> 01:01:34,390
And Google Wallet provides
all of these things.

1686
01:01:34,390 --> 01:01:36,920
So with Google Wallet, you can
actually issue JavaScript

1687
01:01:36,920 --> 01:01:41,030
commands to a server, allow the
user to buy items. You get

1688
01:01:41,030 --> 01:01:43,570
access to anyone who's got
availability of a credit card

1689
01:01:43,570 --> 01:01:44,780
existing in Google Wallet.

1690
01:01:44,780 --> 01:01:47,050
We've already got fraud engines
set up, purchase flow,

1691
01:01:47,050 --> 01:01:48,340
and all this other stuff.

1692
01:01:48,340 --> 01:01:49,210
Use Google Wallet.

1693
01:01:49,210 --> 01:01:51,190
You should definitely leverage
this as opposed to forcing the

1694
01:01:51,190 --> 01:01:54,400
user to go through some
third party site.

1695
01:01:54,400 --> 01:01:57,350
So let's talk about the high
points here or the takeaways

1696
01:01:57,350 --> 01:01:58,540
or take outs.

1697
01:01:58,540 --> 01:02:01,270
So first off, bundle your assets
into segment archives.

1698
01:02:01,270 --> 01:02:02,160
Really important.

1699
01:02:02,160 --> 01:02:05,740
Set your proper caching times
for both data and query stuff

1700
01:02:05,740 --> 01:02:07,370
on Google App Engine.

1701
01:02:07,370 --> 01:02:10,070
Provide a single login for your
users so that they don't

1702
01:02:10,070 --> 01:02:12,600
have to create multiple sessions
or multiple users.

1703
01:02:12,600 --> 01:02:14,420
Localize your content
properly.

1704
01:02:14,420 --> 01:02:15,620
Super important there.

1705
01:02:15,620 --> 01:02:18,220
Be able to detect your GPU
blacklisted and performance

1706
01:02:18,220 --> 01:02:20,240
problems and alert
the user early.

1707
01:02:20,240 --> 01:02:23,130
Nothing's more annoying than a
user spending an hour trying

1708
01:02:23,130 --> 01:02:25,710
to get a game to run to finally
be told through

1709
01:02:25,710 --> 01:02:28,710
frustration that they can't
play the application.

1710
01:02:28,710 --> 01:02:31,540
Make sure that you detect and
fetch bugs in a wild.

1711
01:02:31,540 --> 01:02:33,180
You need to be able to know
what's going on in the

1712
01:02:33,180 --> 01:02:34,770
universe that you can fix
it and create a better

1713
01:02:34,770 --> 01:02:35,840
experience.

1714
01:02:35,840 --> 01:02:38,390
You should also make sure that
when the user tabs away that

1715
01:02:38,390 --> 01:02:40,150
you detect that and
respond properly.

1716
01:02:40,150 --> 01:02:43,740
You should track the data of
your users so you can optimize

1717
01:02:43,740 --> 01:02:45,470
your game for their
experience.

1718
01:02:45,470 --> 01:02:47,530
And you should choose a
monetization metric

1719
01:02:47,530 --> 01:02:48,410
that fits your game.

1720
01:02:48,410 --> 01:02:50,580
It's probably one of the most
important points there.

1721
01:02:50,580 --> 01:02:52,680
And if you do, once you have
chosen that monetization

1722
01:02:52,680 --> 01:02:55,060
method if you do you choose
a path that focuses on

1723
01:02:55,060 --> 01:02:58,110
consumable goods, make sure you
focus on consumable and

1724
01:02:58,110 --> 01:03:00,260
durable because that's where the
largest portion of the pie

1725
01:03:00,260 --> 01:03:02,150
is for in-app purchase.

1726
01:03:02,150 --> 01:03:04,230
And then finally, for in-app
purchase, definitely use the

1727
01:03:04,230 --> 01:03:05,080
Google Wallet API.

1728
01:03:05,080 --> 01:03:05,870
It's available.

1729
01:03:05,870 --> 01:03:06,620
It's usable.

1730
01:03:06,620 --> 01:03:08,740
It's quick to get started and
it's amazing what kind of

1731
01:03:08,740 --> 01:03:10,610
power it gives you.

1732
01:03:10,610 --> 01:03:13,810
So in general, it takes lots of
work to develop a game that

1733
01:03:13,810 --> 01:03:15,340
has nothing to do
with your game.

1734
01:03:15,340 --> 01:03:17,720
A lot of the things we talked
about had nothing to do with

1735
01:03:17,720 --> 01:03:21,580
path finding or play balancing
or how to properly get a sword

1736
01:03:21,580 --> 01:03:23,230
to whack a demon, like
nothing of that.

1737
01:03:23,230 --> 01:03:24,790
This is all back end stuff.

1738
01:03:24,790 --> 01:03:27,070
And because of that, you should
be leveraging services

1739
01:03:27,070 --> 01:03:27,800
that make it easy.

1740
01:03:27,800 --> 01:03:30,420
You want to be spending time
optimizing your game, not

1741
01:03:30,420 --> 01:03:32,280
spending time optimizing
these other services.

1742
01:03:32,280 --> 01:03:35,240
The fantastic thing is Google's
got a lot of services

1743
01:03:35,240 --> 01:03:37,400
that we have available for
you to get started.

1744
01:03:37,400 --> 01:03:38,110
Definitely use them.

1745
01:03:38,110 --> 01:03:40,060
Definitely take advantage of
them, and make sure you get

1746
01:03:40,060 --> 01:03:41,300
your game the best it can be.

1747
01:03:41,300 --> 01:03:45,790
So a big thanks to Pong Yang
and Fred Sauer, as well as

1748
01:03:45,790 --> 01:03:47,740
Chrome Developer Relations
for input on this talk.

1749
01:03:47,740 --> 01:03:49,630
Thank you very much.

1750
01:03:49,630 --> 01:03:51,510
Hit me up with any questions you
have. I'm available here.

1751
01:03:51,510 --> 01:03:52,760

