1
00:00:00,000 --> 00:00:00,160

2
00:00:00,160 --> 00:00:01,900
MONA VAJOLAHI: I'm
Mona Vajolahi.

3
00:00:01,900 --> 00:00:04,560
I'm a product manager
at Google.

4
00:00:04,560 --> 00:00:08,630
I work on making the web fast,
and more specifically, I work

5
00:00:08,630 --> 00:00:10,750
on [INAUDIBLE] products.

6
00:00:10,750 --> 00:00:11,910
DOANTAM PHAN: My name's
Doantam Phan.

7
00:00:11,910 --> 00:00:13,690
I'm also a product manager
working on

8
00:00:13,690 --> 00:00:16,230
making the web fast.

9
00:00:16,230 --> 00:00:17,310
BRYAN MCQUADE: And I'm
Bryan McQuade.

10
00:00:17,310 --> 00:00:20,920
I'm the technical lead of
PageSpeed Insights.

11
00:00:20,920 --> 00:00:21,370
MONA VAJOLAHI: All right.

12
00:00:21,370 --> 00:00:26,310
So I want to start by showing
you a video that would capture

13
00:00:26,310 --> 00:00:28,140
the impact of the
recommendations that we are

14
00:00:28,140 --> 00:00:30,160
going to talk to you
about today.

15
00:00:30,160 --> 00:00:32,195
So here's a sample
Wikipedia page.

16
00:00:32,195 --> 00:00:36,470
We are going to load it on a
mobile device at 3G network.

17
00:00:36,470 --> 00:00:39,590
And on the left hand side,
you'll see the Wikipedia

18
00:00:39,590 --> 00:00:40,650
page-- the original version.

19
00:00:40,650 --> 00:00:43,160
Then the right hand side, the
optimized vision is after the

20
00:00:43,160 --> 00:00:45,960
implemented best practices
that we are going

21
00:00:45,960 --> 00:00:46,480
to share with you.

22
00:00:46,480 --> 00:00:47,730
So let me play the video.

23
00:00:47,730 --> 00:00:51,430

24
00:00:51,430 --> 00:00:55,270
So as you can see, the original
one takes some time

25
00:00:55,270 --> 00:00:58,500
to show something on the page,
and overall the original

26
00:00:58,500 --> 00:01:01,050
finishes in five seconds,
whereas the optimized version

27
00:01:01,050 --> 00:01:02,450
finishes in two seconds.

28
00:01:02,450 --> 00:01:07,790
Now, let's have a closer look
at what's happening here.

29
00:01:07,790 --> 00:01:10,940
So even more interesting is
that the optimized version

30
00:01:10,940 --> 00:01:13,860
actually shows something on the
page around the one second

31
00:01:13,860 --> 00:01:17,920
mark, whereas in the original
version, we are staring at a

32
00:01:17,920 --> 00:01:20,860
blank screen for almost
three seconds.

33
00:01:20,860 --> 00:01:22,810
And here's what we are
going to do today.

34
00:01:22,810 --> 00:01:26,110
We are going to try to get
some content on the page

35
00:01:26,110 --> 00:01:27,750
around that one second mark.

36
00:01:27,750 --> 00:01:31,760
Let's see just a quick
agenda on the top.

37
00:01:31,760 --> 00:01:34,476
So we're talking about why speed
matters, and then we're

38
00:01:34,476 --> 00:01:36,470
going to share the
recommendations for creating

39
00:01:36,470 --> 00:01:37,950
an instant mobile performance.

40
00:01:37,950 --> 00:01:41,460
And also, in the end, Bryan is
going to do a deep dive in one

41
00:01:41,460 --> 00:01:45,250
example, and show you in action
how we can do that.

42
00:01:45,250 --> 00:01:50,530
So we all know that connection
speed on mobile, 3G or 4G, is

43
00:01:50,530 --> 00:01:54,190
slower than your average
connection speed on desktop.

44
00:01:54,190 --> 00:01:58,200
However, users on a mobile
device actually expect the

45
00:01:58,200 --> 00:02:02,370
sites to load as fast or even
faster as what they have on

46
00:02:02,370 --> 00:02:03,420
the desktop.

47
00:02:03,420 --> 00:02:04,580
So there's a problem.

48
00:02:04,580 --> 00:02:10,340
More than that, users of mobile
sites actually learn to

49
00:02:10,340 --> 00:02:11,510
avoid slow sites.

50
00:02:11,510 --> 00:02:13,946
And that first interaction that
they have with a site--

51
00:02:13,946 --> 00:02:16,330
the first experience they have--
is actually really,

52
00:02:16,330 --> 00:02:17,570
really important.

53
00:02:17,570 --> 00:02:22,020
In an experiment of adding one
second additional latency to a

54
00:02:22,020 --> 00:02:26,320
shopping site, it actually saw
that page views will decrease

55
00:02:26,320 --> 00:02:29,000
if you have additional latency,
conversion rates are

56
00:02:29,000 --> 00:02:31,940
going to drop, and bounce rates
are going to go up.

57
00:02:31,940 --> 00:02:35,940
More importantly, what happens
is that that experience sticks

58
00:02:35,940 --> 00:02:38,600
with the user, so they are less
likely to come back to

59
00:02:38,600 --> 00:02:44,710
the site, and less likely
to go back to the site.

60
00:02:44,710 --> 00:02:47,170
So here's what we want
to do today.

61
00:02:47,170 --> 00:02:50,270
We want to make that first
experience really fast and

62
00:02:50,270 --> 00:02:55,120
snappy, so that we actually get
the users to come back and

63
00:02:55,120 --> 00:02:56,370
visit the site more often.

64
00:02:56,370 --> 00:03:00,660

65
00:03:00,660 --> 00:03:06,950
So the topic of today's talk--
we're going to show how we can

66
00:03:06,950 --> 00:03:11,910
get the most important content
of the site to the user under

67
00:03:11,910 --> 00:03:12,970
one second.

68
00:03:12,970 --> 00:03:15,950
So that most important content
usually is what you see above

69
00:03:15,950 --> 00:03:17,380
the fold of the page.

70
00:03:17,380 --> 00:03:18,720
And why did we pick
one second?

71
00:03:18,720 --> 00:03:22,290
Because user studies show that
that is the limit that people

72
00:03:22,290 --> 00:03:24,190
are going to pay attention
to your site.

73
00:03:24,190 --> 00:03:26,870
So after that one second of
staring at a blank screen,

74
00:03:26,870 --> 00:03:30,300
users are more likely to just
step away and basically never

75
00:03:30,300 --> 00:03:31,980
come back to your site.

76
00:03:31,980 --> 00:03:35,440
And today, the average page load
time on mobile is seven

77
00:03:35,440 --> 00:03:38,860
seconds, which is a huge gap
from where we want to be

78
00:03:38,860 --> 00:03:42,930
compared to where
we are today.

79
00:03:42,930 --> 00:03:48,260
Now, we all know 4G bandwidth
is much higher than 3G, so

80
00:03:48,260 --> 00:03:51,400
that should solve all our
problems, and basically

81
00:03:51,400 --> 00:03:54,680
experience on mobile would
be very fast on 4G.

82
00:03:54,680 --> 00:03:56,500
Well, not quite.

83
00:03:56,500 --> 00:04:00,140
Let's look at the difference
between bandwidth and latency.

84
00:04:00,140 --> 00:04:02,750
Bandwidth is the amount of
data transferred over the

85
00:04:02,750 --> 00:04:04,530
network per unit of time.

86
00:04:04,530 --> 00:04:08,020
So for example, a network can
have five megabit per second

87
00:04:08,020 --> 00:04:09,330
of bandwidth.

88
00:04:09,330 --> 00:04:12,720
However, latency is the delay
in transferring the packet

89
00:04:12,720 --> 00:04:15,340
from the source to
a destination.

90
00:04:15,340 --> 00:04:19,610
So for specifying latency, we
usually use round trip times.

91
00:04:19,610 --> 00:04:22,385
Now, if I have huge amounts of
data that I want to transfer

92
00:04:22,385 --> 00:04:25,110
on a network-- like, if I'm
loading a video, obviously,

93
00:04:25,110 --> 00:04:26,480
bandwidth matters a lot.

94
00:04:26,480 --> 00:04:30,210
But when I'm loading a page,
there's a lot of small

95
00:04:30,210 --> 00:04:33,660
requests going back and forth,
and in that case, bandwidth is

96
00:04:33,660 --> 00:04:35,490
not helping me a lot.

97
00:04:35,490 --> 00:04:38,080
So what happens is that latency
in loading your page

98
00:04:38,080 --> 00:04:39,990
is dominated by round
trip times.

99
00:04:39,990 --> 00:04:42,030
And now round trip times
on mobile networks

100
00:04:42,030 --> 00:04:44,760
are especially high.

101
00:04:44,760 --> 00:04:48,030
And on an average 3G network,
for example, you have a round

102
00:04:48,030 --> 00:04:51,910
trip between 100 milliseconds
to 450 milliseconds.

103
00:04:51,910 --> 00:04:54,225
On a 4G network, you
have between 60

104
00:04:54,225 --> 00:04:55,990
milliseconds and 180.

105
00:04:55,990 --> 00:04:58,340
And as you can see, the
difference between 3G and 4G

106
00:04:58,340 --> 00:05:00,250
is not huge here.

107
00:05:00,250 --> 00:05:04,040
So in order to get that snappy
user experience, we have to

108
00:05:04,040 --> 00:05:06,620
design for this high latency
environment.

109
00:05:06,620 --> 00:05:10,070
And we have to try to reduce the
number of round trips as

110
00:05:10,070 --> 00:05:11,410
much as possible.

111
00:05:11,410 --> 00:05:14,290
And that brings us to the rules
that we are going to

112
00:05:14,290 --> 00:05:15,660
share with you today.

113
00:05:15,660 --> 00:05:19,500
These are about how to create
a fast user experience in a

114
00:05:19,500 --> 00:05:21,070
high latency environment.

115
00:05:21,070 --> 00:05:24,920
It could be when I'm using my
mobile phone to load a page.

116
00:05:24,920 --> 00:05:27,840
It could be when I'm using my
laptop and connecting to a 3G

117
00:05:27,840 --> 00:05:30,520
network to load a page.

118
00:05:30,520 --> 00:05:34,550
So the four rules are, one,
avoid landing page redirects.

119
00:05:34,550 --> 00:05:37,120
Two, minimize server
response time.

120
00:05:37,120 --> 00:05:39,840
Three, eliminate render
blocking resources.

121
00:05:39,840 --> 00:05:42,490
And four, prioritize
visible content.

122
00:05:42,490 --> 00:05:44,220
Now, what we are going to do
is that we're going through

123
00:05:44,220 --> 00:05:47,100
each one of these rules, and
tell you why we picked those,

124
00:05:47,100 --> 00:05:50,110
and why they're useful.

125
00:05:50,110 --> 00:05:53,550
So let's just start by let's see
what happens when a user

126
00:05:53,550 --> 00:05:54,870
visits a site.

127
00:05:54,870 --> 00:05:57,450
So I'll go to my mobile device--
mobile browser.

128
00:05:57,450 --> 00:06:01,050
I enter www.example.com
in the browser.

129
00:06:01,050 --> 00:06:03,702
What happens is that there's
going to be a DNS lookup to

130
00:06:03,702 --> 00:06:04,990
fetch the IP.

131
00:06:04,990 --> 00:06:08,120
Then there's going to be a TCP
connection established.

132
00:06:08,120 --> 00:06:10,180
Then the request is sent
to the server.

133
00:06:10,180 --> 00:06:13,100
Server takes the request,
processes the response,

134
00:06:13,100 --> 00:06:15,840
generates the response, and
sends it back to the user.

135
00:06:15,840 --> 00:06:18,960
So we already have three
round trips, plus

136
00:06:18,960 --> 00:06:20,350
server processing time.

137
00:06:20,350 --> 00:06:23,470
Now, if I say, on an average
network, the round trip time

138
00:06:23,470 --> 00:06:27,310
is 200 milliseconds, that brings
us to 600 millisecond

139
00:06:27,310 --> 00:06:30,500
plus server response time.

140
00:06:30,500 --> 00:06:35,120
Now, let's say www.example.com
actually has a redirect to

141
00:06:35,120 --> 00:06:37,210
m.example.com.

142
00:06:37,210 --> 00:06:38,450
What happens then?

143
00:06:38,450 --> 00:06:42,800
In that case, there is another
DNS lookup, another TCP

144
00:06:42,800 --> 00:06:46,910
connection, another sender
response, which basically

145
00:06:46,910 --> 00:06:48,110
doubles our latency.

146
00:06:48,110 --> 00:06:49,950
So there is three additional
round trips.

147
00:06:49,950 --> 00:06:53,820
If we are over SSL, it's
actually four, and brings us

148
00:06:53,820 --> 00:06:56,270
to 1.2 second total latency.

149
00:06:56,270 --> 00:06:59,170
And this is all before
any of your HTML

150
00:06:59,170 --> 00:07:01,760
content gets to the browser.

151
00:07:01,760 --> 00:07:03,660
Now, if you look at this, there
are parts of this that

152
00:07:03,660 --> 00:07:06,000
I, as a developer, have
no control over.

153
00:07:06,000 --> 00:07:09,310
I cannot do anything about DNS
lookup, TCP connection, send

154
00:07:09,310 --> 00:07:09,540
and receive.

155
00:07:09,540 --> 00:07:13,460
But what I do have control
over is the redirect and

156
00:07:13,460 --> 00:07:15,060
server response time.

157
00:07:15,060 --> 00:07:22,250
And that brings us to the first
two rules that says,

158
00:07:22,250 --> 00:07:25,550
avoid any landing page redirects
and minimize server

159
00:07:25,550 --> 00:07:28,320
processing time as much as
possible to reduce that

160
00:07:28,320 --> 00:07:30,650
latency and to minimize
the RTT time.

161
00:07:30,650 --> 00:07:33,120
Now, Doantam is going to tell
you more about these next two

162
00:07:33,120 --> 00:07:35,966
rules, and why they are
really important.

163
00:07:35,966 --> 00:07:37,480
DOANTAM PHAN: Thanks, Mona.

164
00:07:37,480 --> 00:07:42,340
So we've seen that there are
various things that you can do

165
00:07:42,340 --> 00:07:45,050
to your network by adding extra
redirects, by having a

166
00:07:45,050 --> 00:07:48,160
high server response time, that
really slow down the user

167
00:07:48,160 --> 00:07:51,430
perceived latency
of your site.

168
00:07:51,430 --> 00:07:55,030
What I'm going to talk about now
is actually the way that

169
00:07:55,030 --> 00:07:56,530
the structure of your page--

170
00:07:56,530 --> 00:07:59,080
the HTML that you use and how
you organize it-- can actually

171
00:07:59,080 --> 00:08:02,640
also lead to a huge increase
in user perceived latency.

172
00:08:02,640 --> 00:08:04,060
And the way that we're going to
do this is we're going to

173
00:08:04,060 --> 00:08:07,000
look a little bit into the
browser rendering pipeline.

174
00:08:07,000 --> 00:08:11,180
So what I have here is a
simplified diagram, and you

175
00:08:11,180 --> 00:08:14,490
can see that to paint anything
to the screen, we both need a

176
00:08:14,490 --> 00:08:17,250
document object model to be
ready, and the CSS object

177
00:08:17,250 --> 00:08:18,620
model to be ready.

178
00:08:18,620 --> 00:08:21,230
And it turns out that both of
these things are going to

179
00:08:21,230 --> 00:08:24,470
depend heavily on having the
presence of external scripts

180
00:08:24,470 --> 00:08:26,500
and stylesheets.

181
00:08:26,500 --> 00:08:29,310
To see how this actually
affects user perceived

182
00:08:29,310 --> 00:08:33,090
latency, we'll go through
this brief example.

183
00:08:33,090 --> 00:08:35,830
So here I have a very simple
HTML web page.

184
00:08:35,830 --> 00:08:38,100
I've grayed out all the text,
because I want to indicate

185
00:08:38,100 --> 00:08:39,419
that the parser hasn't actually

186
00:08:39,419 --> 00:08:43,020
gotten to the HTML yet.

187
00:08:43,020 --> 00:08:45,140
On the right hand side, I have
a representation of what the

188
00:08:45,140 --> 00:08:46,430
user sees--

189
00:08:46,430 --> 00:08:47,420
a smartphone--

190
00:08:47,420 --> 00:08:50,260
and at the bottom of the page,
I have some representation of

191
00:08:50,260 --> 00:08:52,180
the internal state of
the browser, right?

192
00:08:52,180 --> 00:08:56,030
So I have the pipeline, and I
also have the various external

193
00:08:56,030 --> 00:09:00,020
files that the HTML
references.

194
00:09:00,020 --> 00:09:02,650
So from our perspective, the
first interesting event is

195
00:09:02,650 --> 00:09:04,880
when we discover example.css.

196
00:09:04,880 --> 00:09:06,920
So at that point, you can see
the progress bars on the

197
00:09:06,920 --> 00:09:09,900
bottom are indicating that I've
started parsing the HTML,

198
00:09:09,900 --> 00:09:12,750
I've started constructing the
DOM, and I've initiated a

199
00:09:12,750 --> 00:09:14,000
fetch for the CSS.

200
00:09:14,000 --> 00:09:16,240

201
00:09:16,240 --> 00:09:18,695
The next interesting event from
the perspective of user

202
00:09:18,695 --> 00:09:20,540
latency is when I encounter
this div--

203
00:09:20,540 --> 00:09:23,750
this div that presents some
text to the user.

204
00:09:23,750 --> 00:09:26,800
Now, ideally, at this point in
our rendering pipeline, we'd

205
00:09:26,800 --> 00:09:28,930
want to show this text to the
user immediately, right?

206
00:09:28,930 --> 00:09:31,540
Because the user has clicked
on our site, and they're

207
00:09:31,540 --> 00:09:34,110
waiting, staring at a blank
page and a progress bar.

208
00:09:34,110 --> 00:09:37,760
But due to the way that this
div depends on the styling

209
00:09:37,760 --> 00:09:41,100
information inside external.css,
that's going to

210
00:09:41,100 --> 00:09:43,390
cause the browser to not
know what to do.

211
00:09:43,390 --> 00:09:45,470
And so it's just going to
continue parsing the file.

212
00:09:45,470 --> 00:09:47,830
And so this is where you can see
that the latency is going

213
00:09:47,830 --> 00:09:50,320
to creep in.

214
00:09:50,320 --> 00:09:55,030
So similarly, as I encounter the
image, as I encounter the

215
00:09:55,030 --> 00:09:57,430
JavaScript file, I'm also going
to have to initiate

216
00:09:57,430 --> 00:09:58,030
fetches for them.

217
00:09:58,030 --> 00:10:00,240
But I still can't show anything,
because the CSS file

218
00:10:00,240 --> 00:10:02,860
hasn't yet loaded.

219
00:10:02,860 --> 00:10:06,240
And so it's only finally when
the CSS file is loaded off the

220
00:10:06,240 --> 00:10:08,490
network and memory that I can
actually pop something up on

221
00:10:08,490 --> 00:10:09,600
the screen to the user.

222
00:10:09,600 --> 00:10:11,780
At that point, the user
is finally engaged.

223
00:10:11,780 --> 00:10:15,690
Up to that point, they're just
staring at a blank screen.

224
00:10:15,690 --> 00:10:18,140
And so an important thing to
note here is that the DOM can

225
00:10:18,140 --> 00:10:20,520
be constructed iteratively
as you're

226
00:10:20,520 --> 00:10:21,850
parsing through the file.

227
00:10:21,850 --> 00:10:24,480
But the CSS object model is only
constructed once all the

228
00:10:24,480 --> 00:10:26,390
CSS is in place.

229
00:10:26,390 --> 00:10:29,510
And this is really the reason
why a lot of webpages feel

230
00:10:29,510 --> 00:10:32,490
slow on a mobile device, or
really, on any device.

231
00:10:32,490 --> 00:10:36,060
It's just not as noticeable on a
desktop, due to the way that

232
00:10:36,060 --> 00:10:37,310
latency works.

233
00:10:37,310 --> 00:10:40,660

234
00:10:40,660 --> 00:10:42,980
And so as we continue parsing
through the file, we're going

235
00:10:42,980 --> 00:10:44,630
to finish loading
the JavaScript.

236
00:10:44,630 --> 00:10:45,740
We're going to finish
loading the image.

237
00:10:45,740 --> 00:10:49,240
And at that point, the page
is ready, and sort of

238
00:10:49,240 --> 00:10:50,990
consumed by the user.

239
00:10:50,990 --> 00:10:52,760
But at that point, they've been
waiting quite some time

240
00:10:52,760 --> 00:10:55,990
to get this information.

241
00:10:55,990 --> 00:11:00,690
So to summarize, the issue is
that these external scripts

242
00:11:00,690 --> 00:11:02,750
and stylesheets are going to
block the painting of content

243
00:11:02,750 --> 00:11:04,000
in the body, right?

244
00:11:04,000 --> 00:11:06,670
And we're not saying that
external resources are bad.

245
00:11:06,670 --> 00:11:09,360
In fact, it's generally a very
reasonable practice on desktop

246
00:11:09,360 --> 00:11:12,950
to have these resources for
cacheability, and for easy

247
00:11:12,950 --> 00:11:14,450
composition of HTML.

248
00:11:14,450 --> 00:11:17,470
But on a mobile device, if you
assume 200 millisecond

249
00:11:17,470 --> 00:11:20,490
latency, maybe 300 millisecond,
these extra round

250
00:11:20,490 --> 00:11:22,610
trips to fetch every additional
resource is going

251
00:11:22,610 --> 00:11:24,020
to be very costly.

252
00:11:24,020 --> 00:11:26,920
And so what you really want to
do is be able to avoid these

253
00:11:26,920 --> 00:11:28,940
blocking external scripts
and stylesheets.

254
00:11:28,940 --> 00:11:31,690

255
00:11:31,690 --> 00:11:34,750
So generally speaking, when you
do this, the way that you

256
00:11:34,750 --> 00:11:37,730
can get around this is you can
be smart about the CSS.

257
00:11:37,730 --> 00:11:41,390
You can inline parts of the CSS
that are responsible for

258
00:11:41,390 --> 00:11:44,890
the above the fold content in
the header of your HTML file.

259
00:11:44,890 --> 00:11:48,240
And so, then when the browser
is parsing through the file,

260
00:11:48,240 --> 00:11:50,830
at the point that it encounters
that div, it knows

261
00:11:50,830 --> 00:11:52,650
how to style it and paint
it to the screen.

262
00:11:52,650 --> 00:11:55,320

263
00:11:55,320 --> 00:11:57,210
And that's really where this
third rule comes from-- this

264
00:11:57,210 --> 00:12:00,800
notion of eliminating render
blocking resources.

265
00:12:00,800 --> 00:12:02,530
Understanding that there's
certain things in the

266
00:12:02,530 --> 00:12:05,080
rendering pipeline that will
block, because they don't have

267
00:12:05,080 --> 00:12:07,030
the right information, and
making that information

268
00:12:07,030 --> 00:12:11,340
available to the browser
at the right moment.

269
00:12:11,340 --> 00:12:14,080
So let's say that I attended
this talk, and I saw these

270
00:12:14,080 --> 00:12:16,750
three rules, and I think to
myself, hey, I'm done.

271
00:12:16,750 --> 00:12:20,100
I can just inline everything,
and everything will be great.

272
00:12:20,100 --> 00:12:22,050
And I just want to add an
additional caveat, which is

273
00:12:22,050 --> 00:12:24,840
where this fourth rule comes
into play, which is this

274
00:12:24,840 --> 00:12:28,580
notion of the additional latency
that comes due to the

275
00:12:28,580 --> 00:12:30,130
slow start of TCP.

276
00:12:30,130 --> 00:12:33,880
So in this example, I've
actually inlined all the CSS

277
00:12:33,880 --> 00:12:34,360
that I have.

278
00:12:34,360 --> 00:12:36,410
I've put all the styling
information there.

279
00:12:36,410 --> 00:12:39,320
In fact, I've gone the extra
step where I've added in the

280
00:12:39,320 --> 00:12:43,980
icons as data image URLs in
the header of the CSS.

281
00:12:43,980 --> 00:12:47,840
Now, the problem is going
to come up that--

282
00:12:47,840 --> 00:12:49,200
keep in mind that we want
to reduce these

283
00:12:49,200 --> 00:12:50,090
round trips, right?

284
00:12:50,090 --> 00:12:53,370
And so if the initial above the
fold content of your page

285
00:12:53,370 --> 00:12:57,660
is over 14K over that initial
TCP congestion window, that's

286
00:12:57,660 --> 00:12:59,990
actually going to incur an
additional round trip.

287
00:12:59,990 --> 00:13:02,430
And so, you need to be
really careful about

288
00:13:02,430 --> 00:13:03,540
how you inline something.

289
00:13:03,540 --> 00:13:06,710
You can't just blindly inline a
file, unless, of course, the

290
00:13:06,710 --> 00:13:08,320
file is below that cutoff.

291
00:13:08,320 --> 00:13:11,560
But if a file's above that
cutoff, you're going to need

292
00:13:11,560 --> 00:13:14,340
to figure out what are the
critical parts of CSS, and

293
00:13:14,340 --> 00:13:16,710
what are the noncritical
parts of CSS?

294
00:13:16,710 --> 00:13:19,550
And then you should use delay
loading and asynchronous stuff

295
00:13:19,550 --> 00:13:21,740
for the parts that are not
necessary for that initial

296
00:13:21,740 --> 00:13:24,420
user experience to really get
to something in one second.

297
00:13:24,420 --> 00:13:28,770

298
00:13:28,770 --> 00:13:31,830
And I want to emphasize that
we're not saying that you

299
00:13:31,830 --> 00:13:35,890
should only make your whole page
fit in 14 kilobytes or 15

300
00:13:35,890 --> 00:13:38,410
kilobytes, because that is kind
of really stringent, and

301
00:13:38,410 --> 00:13:40,300
actually fairly difficult
to do.

302
00:13:40,300 --> 00:13:42,240
You only need to make sure
that the above the fold

303
00:13:42,240 --> 00:13:43,920
portion of your page fits.

304
00:13:43,920 --> 00:13:46,590
And actually keep in mind that
with compression, that's

305
00:13:46,590 --> 00:13:49,110
actually going to cause us
to get a lot more space.

306
00:13:49,110 --> 00:13:54,470
Maybe up to 45K of text.

307
00:13:54,470 --> 00:13:56,620
And so that's where this is
final rule comes from-- this

308
00:13:56,620 --> 00:13:59,200
notion of prioritizing
the visible content.

309
00:13:59,200 --> 00:14:03,220
So be smart about what you're
inlining, and make sure that

310
00:14:03,220 --> 00:14:05,780
it fits within this congestion
window so that the user can

311
00:14:05,780 --> 00:14:07,820
get that content right away.

312
00:14:07,820 --> 00:14:11,160
So now Brian is going to go into
an example about how you

313
00:14:11,160 --> 00:14:12,410
apply these rules
to a real site.

314
00:14:12,410 --> 00:14:15,210

315
00:14:15,210 --> 00:14:16,970
BRYAN MCQUADE: Thanks,
Doantam.

316
00:14:16,970 --> 00:14:17,780
So I'm Bryan McQuaid.

317
00:14:17,780 --> 00:14:19,680
I'm the tech lead of
PageSpeed Insights.

318
00:14:19,680 --> 00:14:22,440
And I'm going to take what we
just learned from Mona and

319
00:14:22,440 --> 00:14:26,790
Doantam and apply that to an
actual website that we created

320
00:14:26,790 --> 00:14:29,000
to work through and see how much
faster we can make that

321
00:14:29,000 --> 00:14:30,970
website load on mobile.

322
00:14:30,970 --> 00:14:32,700
So we have this demo website,

323
00:14:32,700 --> 00:14:34,450
demo.modspdy.com, that we put together.

324
00:14:34,450 --> 00:14:36,205
It's a simple mobile page.

325
00:14:36,205 --> 00:14:39,810
It sort of has characteristics
of standard mobile websites.

326
00:14:39,810 --> 00:14:42,650
It redirects to an m.site, it
has a little bit of server

327
00:14:42,650 --> 00:14:45,310
processing time, it's reasonably
small, and it has

328
00:14:45,310 --> 00:14:48,590
just one stylesheet in the
head with some data URIs.

329
00:14:48,590 --> 00:14:50,580
The page looks like
this on the right.

330
00:14:50,580 --> 00:14:52,050
And it's a simple page, right?

331
00:14:52,050 --> 00:14:54,240
We would expect a page like
this to load quickly.

332
00:14:54,240 --> 00:14:56,610
We would hope, anyway, right?

333
00:14:56,610 --> 00:14:59,610
It turns out--

334
00:14:59,610 --> 00:15:02,040
and I suppose I should
clarify.

335
00:15:02,040 --> 00:15:03,650
Modspdy.com was a domain we had

336
00:15:03,650 --> 00:15:05,060
available to create a demo.

337
00:15:05,060 --> 00:15:06,430
It has nothing to
do with SPDY.

338
00:15:06,430 --> 00:15:09,082
It just happened to
be on that domain.

339
00:15:09,082 --> 00:15:12,440

340
00:15:12,440 --> 00:15:14,710
So now we'll sort of dive in,
and we'll look at this page,

341
00:15:14,710 --> 00:15:17,520
figure out where the performance
bottlenecks are,

342
00:15:17,520 --> 00:15:20,500
apply these optimizations one
at a time, and then observe

343
00:15:20,500 --> 00:15:22,720
the improvement in load time
that we get as result of

344
00:15:22,720 --> 00:15:23,660
applying those.

345
00:15:23,660 --> 00:15:26,400
So to start, we have this
unoptimized page here which

346
00:15:26,400 --> 00:15:27,840
literally just has
three resources.

347
00:15:27,840 --> 00:15:31,060
We've got demo.modspdy.com,
which redirects to

348
00:15:31,060 --> 00:15:33,930
m.modspdy.com, which
then loads a

349
00:15:33,930 --> 00:15:36,410
single static CSS resource.

350
00:15:36,410 --> 00:15:42,410
And what we see is that
unfortunately, the load of

351
00:15:42,410 --> 00:15:46,380
these resources is completely
serialized, and we essentially

352
00:15:46,380 --> 00:15:48,790
incur-- because it's on HTTPS
as well, we've got a fourth

353
00:15:48,790 --> 00:15:50,491
round trip in there--

354
00:15:50,491 --> 00:15:53,630
and the end result is that we're
looking at about 6.6

355
00:15:53,630 --> 00:15:55,710
seconds of latency before we
see anything on the screen,

356
00:15:55,710 --> 00:15:58,460
even for a simple
page like this.

357
00:15:58,460 --> 00:16:02,305
So let's go ahead and look
a little further.

358
00:16:02,305 --> 00:16:05,380

359
00:16:05,380 --> 00:16:08,180
So to start, we've got this
redirect, demo.modspdy.com,

360
00:16:08,180 --> 00:16:10,970
which redirects to
m.modspdy.com.

361
00:16:10,970 --> 00:16:12,060
And we know that's costly.

362
00:16:12,060 --> 00:16:13,360
Mona has showed us.

363
00:16:13,360 --> 00:16:15,670
In fact, in this particular
environment, we're using web

364
00:16:15,670 --> 00:16:18,800
page tests' 3G modeling.

365
00:16:18,800 --> 00:16:20,560
Round trips are actually
300 milliseconds.

366
00:16:20,560 --> 00:16:23,370
So we've talked about 200 being
a good general target to

367
00:16:23,370 --> 00:16:26,450
be in between 3G and 4G.

368
00:16:26,450 --> 00:16:28,130
But for 200 milliseconds,
that is.

369
00:16:28,130 --> 00:16:30,930
For this particular demo, we're
using a 300 millisecond

370
00:16:30,930 --> 00:16:32,150
round trip time.

371
00:16:32,150 --> 00:16:34,720
And on top of that, because it's
on HTTPS, we're looking

372
00:16:34,720 --> 00:16:36,520
at four round trips.

373
00:16:36,520 --> 00:16:39,540
So that redirect ends up costing
us, by itself, 4 times

374
00:16:39,540 --> 00:16:42,470
300, 1.2 seconds.

375
00:16:42,470 --> 00:16:43,950
So the question becomes,
how do we avoid that?

376
00:16:43,950 --> 00:16:45,760
How do we avoid that cost?

377
00:16:45,760 --> 00:16:47,790
There are really two good
ways to approach this.

378
00:16:47,790 --> 00:16:50,200
At a high level, we have to make
sure that we serve the

379
00:16:50,200 --> 00:16:53,530
user content at the URL they
request initially, right?

380
00:16:53,530 --> 00:16:57,050
If we redirect them from
demo.modspdy.com to

381
00:16:57,050 --> 00:17:01,660
m.modspdy.com, we saw we're
inherently going to experience

382
00:17:01,660 --> 00:17:03,580
that additional latency.

383
00:17:03,580 --> 00:17:05,180
So what we have to do is
instead serve the right

384
00:17:05,180 --> 00:17:08,470
content to the right users
at the URL they request.

385
00:17:08,470 --> 00:17:09,730
So what that means is
one of two things.

386
00:17:09,730 --> 00:17:12,500
Either user responsive design,
which allows you to serve the

387
00:17:12,500 --> 00:17:15,200
same HTML to all your users,
be it mobile users, desktop

388
00:17:15,200 --> 00:17:18,400
users, and the page will render
differently depending

389
00:17:18,400 --> 00:17:20,780
on the device characteristics.

390
00:17:20,780 --> 00:17:22,990
And I should say, that's a
great approach if you're

391
00:17:22,990 --> 00:17:24,109
building a site from scratch.

392
00:17:24,109 --> 00:17:25,710
I think that's the
right way to go.

393
00:17:25,710 --> 00:17:28,730
But if you've got an existing
mobile website and desktop

394
00:17:28,730 --> 00:17:31,280
website, and you're just trying
to figure out, well,

395
00:17:31,280 --> 00:17:35,620
how do I move from having this
redirect to not, then what you

396
00:17:35,620 --> 00:17:39,500
want to do is make sure that you
vary the HTML content that

397
00:17:39,500 --> 00:17:42,820
you serve to your users based on
the user agent coming in at

398
00:17:42,820 --> 00:17:43,870
the web server.

399
00:17:43,870 --> 00:17:46,420
And so if you're getting a
request from a mobile user

400
00:17:46,420 --> 00:17:50,530
agent, you serve the mobile HTML
directly, and if you get

401
00:17:50,530 --> 00:17:54,660
a request from a desktop user,
you serve the desktop HTML for

402
00:17:54,660 --> 00:17:55,910
them as well.

403
00:17:55,910 --> 00:17:58,040

404
00:17:58,040 --> 00:18:00,000
So it's easy enough to
sort of say, just go

405
00:18:00,000 --> 00:18:00,990
ahead and do that.

406
00:18:00,990 --> 00:18:03,690
Let's go ahead and do
a quick example.

407
00:18:03,690 --> 00:18:06,750
I'm actually on the web server
for modspdy.com now.

408
00:18:06,750 --> 00:18:11,720
And we can take a look in
the demo directory.

409
00:18:11,720 --> 00:18:13,330
We've got a couple files.

410
00:18:13,330 --> 00:18:15,210
This is an Apache web server.

411
00:18:15,210 --> 00:18:17,530
So I'm going to go ahead and
actually bring up the

412
00:18:17,530 --> 00:18:21,290
.htaccess file for
demo.modspdy.com,

413
00:18:21,290 --> 00:18:22,300
and we'll see that--

414
00:18:22,300 --> 00:18:25,260
so .htaccess file is an Apache
file that lets you specify

415
00:18:25,260 --> 00:18:29,390
additional information about how
content should be served.

416
00:18:29,390 --> 00:18:33,980
And what we've done here is we
have this rewrite rule that

417
00:18:33,980 --> 00:18:37,900
basically says, conditionally
apply the following rule if

418
00:18:37,900 --> 00:18:40,400
the HTTP user agent matches
either iPhone or Android.

419
00:18:40,400 --> 00:18:43,210
So basically, a very simple
mobile user agent matcher.

420
00:18:43,210 --> 00:18:44,920
You could expand on this.

421
00:18:44,920 --> 00:18:47,660
And then if that matched,
go ahead and

422
00:18:47,660 --> 00:18:49,600
rewrite the empty URL--

423
00:18:49,600 --> 00:18:53,150
so that is the URL with just a
slash, essentially-- no URL,

424
00:18:53,150 --> 00:18:54,240
just the host name--

425
00:18:54,240 --> 00:18:56,950
to HTTPS://m.modspdy.com.

426
00:18:56,950 --> 00:18:59,480
So that's the costly one that
we just looked at that

427
00:18:59,480 --> 00:19:01,770
incurred that 1.2 seconds
of latency.

428
00:19:01,770 --> 00:19:08,630
So if, instead, we tell Apache
to rewrite that URL to a local

429
00:19:08,630 --> 00:19:13,730
file, then what we'll get--

430
00:19:13,730 --> 00:19:15,930
so let me do this, actually.

431
00:19:15,930 --> 00:19:23,490
Let me go ahead and put
demo.modspdy.com on there, and

432
00:19:23,490 --> 00:19:26,420
we can see it redirect.

433
00:19:26,420 --> 00:19:27,815
So that was before.

434
00:19:27,815 --> 00:19:29,450
And if we just switch those--

435
00:19:29,450 --> 00:19:32,450

436
00:19:32,450 --> 00:19:33,700
so now I'll go ahead
and do that again.

437
00:19:33,700 --> 00:19:38,590

438
00:19:38,590 --> 00:19:41,110
And now we can see that the
content that we had been re

439
00:19:41,110 --> 00:19:44,780
directing users to on m dot is
now served directly from

440
00:19:44,780 --> 00:19:46,020
demo.modspdy.com.

441
00:19:46,020 --> 00:19:48,090
And just to sort
of close that--

442
00:19:48,090 --> 00:19:50,240
so it's a pretty simple thing
to configure, right?

443
00:19:50,240 --> 00:19:52,430
This is the Apache variant, but
if you use a different web

444
00:19:52,430 --> 00:19:55,630
server, they all support
this in different ways.

445
00:19:55,630 --> 00:19:56,840
And then just to look--

446
00:19:56,840 --> 00:20:01,846
so we're saying, basically,
serve up mobile.php instead.

447
00:20:01,846 --> 00:20:03,970
Why don't we look at what
that file looks like?

448
00:20:03,970 --> 00:20:11,270

449
00:20:11,270 --> 00:20:16,420
So that's just a sim link over
to the m.modspdy.com index

450
00:20:16,420 --> 00:20:16,830
file, right?

451
00:20:16,830 --> 00:20:17,680
Which is exactly what we were

452
00:20:17,680 --> 00:20:19,660
redirecting the user to before.

453
00:20:19,660 --> 00:20:22,670
And so now we're able to
avoid that redirect.

454
00:20:22,670 --> 00:20:27,690
And let's see the effect
of doing that on

455
00:20:27,690 --> 00:20:30,770
the page load time.

456
00:20:30,770 --> 00:20:34,890
So if we think about what we
expect to happen here, we're

457
00:20:34,890 --> 00:20:37,080
removing, as we talked about,
four round trips--

458
00:20:37,080 --> 00:20:41,620
DNS, TCP, SSL, and request and
response, each of which cost

459
00:20:41,620 --> 00:20:44,240
300 millis from the
time to display.

460
00:20:44,240 --> 00:20:49,440
We were at 6.6 seconds before,
and as a result of removing

461
00:20:49,440 --> 00:20:52,080
that redirect, indeed, we see
the load time of the page drop

462
00:20:52,080 --> 00:20:54,460
to 5.4 seconds, which is
exactly what we expect.

463
00:20:54,460 --> 00:20:58,550
So we've sort of confirmed
through our test environment

464
00:20:58,550 --> 00:21:03,740
here the result that we
would expect to see.

465
00:21:03,740 --> 00:21:05,040
And by the way, did
I mention--

466
00:21:05,040 --> 00:21:06,460
so I don't know, how many
people are familiar

467
00:21:06,460 --> 00:21:08,950
with Web Page Test?

468
00:21:08,950 --> 00:21:10,200
OK, so not most.

469
00:21:10,200 --> 00:21:13,530
So we've used Web Page Test to
both produce these videos and

470
00:21:13,530 --> 00:21:16,100
the waterfall underneath, which
shows the resources that

471
00:21:16,100 --> 00:21:18,240
are loaded and the time that
each one is loaded at.

472
00:21:18,240 --> 00:21:21,110
It's a really great resource,
webpagetest.org.

473
00:21:21,110 --> 00:21:24,170
You can tell it, show me what
my page looks like over a 3G

474
00:21:24,170 --> 00:21:27,020
connection from various
locations around the world

475
00:21:27,020 --> 00:21:30,080
using different kinds of
devices, get these videos,

476
00:21:30,080 --> 00:21:31,640
look at still frames.

477
00:21:31,640 --> 00:21:35,080
It's a really rich tool to
understand what the experience

478
00:21:35,080 --> 00:21:37,660
your users are seeing is.

479
00:21:37,660 --> 00:21:39,620
And so we've use that to
create these here.

480
00:21:39,620 --> 00:21:42,530

481
00:21:42,530 --> 00:21:44,420
OK, so let's go ahead and
dive into the next.

482
00:21:44,420 --> 00:21:45,460
So we've improved
the page, right?

483
00:21:45,460 --> 00:21:49,390
We've gone from 6.6 seconds to
5.4 seconds, but it's still by

484
00:21:49,390 --> 00:21:50,350
no means fast.

485
00:21:50,350 --> 00:21:52,230
So let's go ahead and dive
in and talk about server

486
00:21:52,230 --> 00:21:53,480
processing time.

487
00:21:53,480 --> 00:21:58,520

488
00:21:58,520 --> 00:22:00,850
So there's sort of two things
you want to think about when

489
00:22:00,850 --> 00:22:02,190
you think about server
processing time.

490
00:22:02,190 --> 00:22:04,160
One is, what is your server
processing time?

491
00:22:04,160 --> 00:22:04,900
How do you measure that?

492
00:22:04,900 --> 00:22:08,340
And two, if it's high, why is
it high, and what can you do

493
00:22:08,340 --> 00:22:09,920
to reduce that?

494
00:22:09,920 --> 00:22:12,700
And so we can go ahead and take
a look at that actual

495
00:22:12,700 --> 00:22:14,720
page we have.

496
00:22:14,720 --> 00:22:18,730
I'll bring up Chrome Dev Tools,
bring up the network

497
00:22:18,730 --> 00:22:21,550
tab, and then I'm going to
go ahead and reload.

498
00:22:21,550 --> 00:22:27,870

499
00:22:27,870 --> 00:22:30,640
And so we can see here that
the waiting time, when we

500
00:22:30,640 --> 00:22:33,050
click on the resource for
demo.modspdy.com and the

501
00:22:33,050 --> 00:22:34,590
timing, the waiting time--

502
00:22:34,590 --> 00:22:36,100
I don't know if you can read
that, it's pretty small--

503
00:22:36,100 --> 00:22:37,420
is 1.6 seconds.

504
00:22:37,420 --> 00:22:40,860
So we've got 1.6 seconds of time
between the time we sent

505
00:22:40,860 --> 00:22:42,580
the request and the time
the first bytes of the

506
00:22:42,580 --> 00:22:43,250
response came back.

507
00:22:43,250 --> 00:22:44,390
So it's quite high.

508
00:22:44,390 --> 00:22:46,685
We'd expect to see maybe one
network round trip there, but

509
00:22:46,685 --> 00:22:48,410
1.6 seconds is way above
that, right?

510
00:22:48,410 --> 00:22:50,020
And so then the question
becomes, well, why?

511
00:22:50,020 --> 00:22:50,790
What's going on there?

512
00:22:50,790 --> 00:22:52,740
Why is it so high?

513
00:22:52,740 --> 00:22:55,460
And so it's a little bit outside
the scope of the talk

514
00:22:55,460 --> 00:22:58,830
to sort of figure out and
understand server processing

515
00:22:58,830 --> 00:23:01,750
time deeply, but at a high
level, what you need to do is

516
00:23:01,750 --> 00:23:03,240
essentially measure
this server side.

517
00:23:03,240 --> 00:23:04,630
So what are those times?

518
00:23:04,630 --> 00:23:07,100
And then, ideally, have some
monitoring infrastructure in

519
00:23:07,100 --> 00:23:09,730
place that helps you understand
if it's high, where

520
00:23:09,730 --> 00:23:10,880
that time is going.

521
00:23:10,880 --> 00:23:13,480
And so one of the tools
we like for this

522
00:23:13,480 --> 00:23:14,650
is called New Relic.

523
00:23:14,650 --> 00:23:19,200
They have a free offering that
you can use, and it lets you

524
00:23:19,200 --> 00:23:21,360
see at a high level where time
is going within your

525
00:23:21,360 --> 00:23:21,640
application.

526
00:23:21,640 --> 00:23:23,910
So I'll go ahead and just bring
up the New Relic view

527
00:23:23,910 --> 00:23:27,930
for this webpage.

528
00:23:27,930 --> 00:23:29,960
And so this graph in the middle
here is showing us over

529
00:23:29,960 --> 00:23:33,250
time how long the server took to
generate various responses

530
00:23:33,250 --> 00:23:35,860
that were requested for
the particular URL

531
00:23:35,860 --> 00:23:36,810
we're looking at.

532
00:23:36,810 --> 00:23:40,050
And so we've got a breakdown by
database time and PHP time,

533
00:23:40,050 --> 00:23:45,010
and so we can see that, by and
large, recently, anyway--

534
00:23:45,010 --> 00:23:47,510
and so I should say these pits
are just places where there

535
00:23:47,510 --> 00:23:49,280
were no requests.

536
00:23:49,280 --> 00:23:50,560
It's a demo page, so
there's not a whole

537
00:23:50,560 --> 00:23:52,790
lot of activity here.

538
00:23:52,790 --> 00:23:56,010
But by and large, we're seeing
pretty substantial time spent

539
00:23:56,010 --> 00:24:00,340
in the database querying, and
a little bit of time in that

540
00:24:00,340 --> 00:24:03,200
blue, though nonzero
time, right?

541
00:24:03,200 --> 00:24:07,220
A couple hundred mills in the
PHP execution environment.

542
00:24:07,220 --> 00:24:08,460
And so then the question
becomes why?

543
00:24:08,460 --> 00:24:10,480
What are we doing?

544
00:24:10,480 --> 00:24:13,570
And what can we do to sort
of address those?

545
00:24:13,570 --> 00:24:19,090
So I'll just look really
quickly at our page.

546
00:24:19,090 --> 00:24:20,940
And this is just
a simple demo.

547
00:24:20,940 --> 00:24:23,380
But sure enough, we've
got two things.

548
00:24:23,380 --> 00:24:26,180
Get data from database, and then
render the HTML with that

549
00:24:26,180 --> 00:24:28,060
data, right?

550
00:24:28,060 --> 00:24:31,280
And I've sort of created the
queries in such a way that

551
00:24:31,280 --> 00:24:33,950
they're intentionally slow for
the purpose of this demo, but

552
00:24:33,950 --> 00:24:37,890
this is something we see pretty
often is that pages

553
00:24:37,890 --> 00:24:41,350
will have multiple second for
spike times as a result of

554
00:24:41,350 --> 00:24:43,890
spending a lot of time either
in the database or executing

555
00:24:43,890 --> 00:24:46,560
PHP, or possibly some
other reason.

556
00:24:46,560 --> 00:24:48,570
But in any case, now that we
know that, the question

557
00:24:48,570 --> 00:24:55,760
becomes what can we do
to reduce this time?

558
00:24:55,760 --> 00:25:00,330
And our options are really
remove, defer, or optimize.

559
00:25:00,330 --> 00:25:06,660
And in this case, I observe
the page is generated

560
00:25:06,660 --> 00:25:09,670
dynamically, but it's really
static content, right?

561
00:25:09,670 --> 00:25:11,220
And this is a common pattern
you see, too, right?

562
00:25:11,220 --> 00:25:13,800
You've got a page that's mostly
static or it might

563
00:25:13,800 --> 00:25:16,260
change periodically, but
fundamentally, it doesn't

564
00:25:16,260 --> 00:25:18,620
change on every request, but
it's still generated

565
00:25:18,620 --> 00:25:21,090
dynamically from the database
on every request, and that

566
00:25:21,090 --> 00:25:24,550
ends up, in some cases, adding
a good bit of latency.

567
00:25:24,550 --> 00:25:28,120
So in this case, because it's
mostly static, we can simply

568
00:25:28,120 --> 00:25:30,630
just whenever we update the
database to have a new product

569
00:25:30,630 --> 00:25:33,230
or whatever it may be, just
render that to HTML, right?

570
00:25:33,230 --> 00:25:36,020
Dump that to a static HTML file
on the web server, and

571
00:25:36,020 --> 00:25:37,410
then just serve that instead.

572
00:25:37,410 --> 00:25:38,660
And so I've done that.

573
00:25:38,660 --> 00:25:41,270

574
00:25:41,270 --> 00:25:43,820
Or I thought I did that.

575
00:25:43,820 --> 00:25:45,840
I did do that.

576
00:25:45,840 --> 00:25:47,330
It's over here.

577
00:25:47,330 --> 00:25:51,050
And we can see now, we'll
go ahead and reload

578
00:25:51,050 --> 00:25:54,300
it and take a look--

579
00:25:54,300 --> 00:25:57,070
that our waiting time has gone
from that 1.6 seconds down to

580
00:25:57,070 --> 00:26:00,380
84 milliseconds, because we're
not invoking the database and

581
00:26:00,380 --> 00:26:02,330
running the PHP engine
on every request now.

582
00:26:02,330 --> 00:26:03,860
We just rendered this to static
content, and we're

583
00:26:03,860 --> 00:26:05,170
serving that instead.

584
00:26:05,170 --> 00:26:07,985
And so, in general, as much as
you can precompute ideally all

585
00:26:07,985 --> 00:26:10,660
of the content, if your pages
doesn't have any dynamic

586
00:26:10,660 --> 00:26:12,960
pieces-- many pages do have a
little bit that's dynamic, but

587
00:26:12,960 --> 00:26:15,630
if you can precompute the
majority of it to minimize the

588
00:26:15,630 --> 00:26:18,960
work in the request path of
the user, you'll create a

589
00:26:18,960 --> 00:26:21,420
better experience
for your users.

590
00:26:21,420 --> 00:26:26,550
So that's server processing
time.

591
00:26:26,550 --> 00:26:28,313
And so now we can see--
that was about 1.5,

592
00:26:28,313 --> 00:26:29,610
1.6 seconds we saw.

593
00:26:29,610 --> 00:26:34,070
And indeed, again, we were
at-- what was it?

594
00:26:34,070 --> 00:26:35,210
5.4 seconds?

595
00:26:35,210 --> 00:26:36,600
And now we're down
to 3.8 seconds.

596
00:26:36,600 --> 00:26:40,300
So we've reduced render time,
again, by another 1.6 seconds.

597
00:26:40,300 --> 00:26:49,620
And you can see that if we go
backwards a little bit, this

598
00:26:49,620 --> 00:26:52,220
sort of green region right here
in the old version was

599
00:26:52,220 --> 00:26:52,800
quite long.

600
00:26:52,800 --> 00:26:54,820
That was that server
processing time.

601
00:26:54,820 --> 00:27:00,290
And we can see now that that
green region is much shorter.

602
00:27:00,290 --> 00:27:02,620
And that's where we've pulled
in time, and that's resulted

603
00:27:02,620 --> 00:27:04,760
in a faster render
on the screen.

604
00:27:04,760 --> 00:27:06,000
So let's keep going.

605
00:27:06,000 --> 00:27:08,150
We're doing well, but
we're not to our one

606
00:27:08,150 --> 00:27:09,050
second target yet.

607
00:27:09,050 --> 00:27:09,490
And I should--

608
00:27:09,490 --> 00:27:10,690
I guess a spoiler alert.

609
00:27:10,690 --> 00:27:12,550
It's physically impossible to
get to one second in this

610
00:27:12,550 --> 00:27:13,290
configuration.

611
00:27:13,290 --> 00:27:15,170
So we're not going to get there,
but we're going to get

612
00:27:15,170 --> 00:27:16,380
as close as we can get.

613
00:27:16,380 --> 00:27:17,920
We're going to get
quite close.

614
00:27:17,920 --> 00:27:20,320
So let's see how close
we can get.

615
00:27:20,320 --> 00:27:24,720
So as Doantam talked about, the
load of our external CSS

616
00:27:24,720 --> 00:27:27,510
resource blocks rendering
of page content.

617
00:27:27,510 --> 00:27:30,060
So that actually ends up
incurring seven round trips on

618
00:27:30,060 --> 00:27:32,520
the network, and at 300
milliseconds, that's a very

619
00:27:32,520 --> 00:27:34,250
substantial cost.

620
00:27:34,250 --> 00:27:36,450
So that's the first thing we can
do-- a very simple, very

621
00:27:36,450 --> 00:27:38,720
easy thing-- is just simply
experiment with inlining all

622
00:27:38,720 --> 00:27:39,640
that content.

623
00:27:39,640 --> 00:27:40,810
And people do this
a lot on mobile.

624
00:27:40,810 --> 00:27:42,150
It's a pretty common
technique, right?

625
00:27:42,150 --> 00:27:43,740
Just inline, inline, inline.

626
00:27:43,740 --> 00:27:46,150
As Doantam talked about, there
are some drawbacks to that.

627
00:27:46,150 --> 00:27:47,460
So we'll start with that.

628
00:27:47,460 --> 00:27:52,660
We'll start with inlining, and
then we'll iterate from there.

629
00:27:52,660 --> 00:27:57,906
So if this is our first page,
with the external stylesheet,

630
00:27:57,906 --> 00:28:03,150
then we can simply, as Doantam
showed, inline all the styles

631
00:28:03,150 --> 00:28:04,800
and serve it up.

632
00:28:04,800 --> 00:28:06,790
And so what does this actually
do in terms of load time

633
00:28:06,790 --> 00:28:08,040
performance?

634
00:28:08,040 --> 00:28:10,160

635
00:28:10,160 --> 00:28:12,130
And so what we see is we're down
from, I believe it was

636
00:28:12,130 --> 00:28:15,360
3.6 seconds before, now
down to 2.4 seconds.

637
00:28:15,360 --> 00:28:18,520
So we've removed 1.2 seconds,
which, interestingly, is the

638
00:28:18,520 --> 00:28:23,680
four round trips from the DNS,
TCP, SSL and request response

639
00:28:23,680 --> 00:28:24,970
of that external stylesheet.

640
00:28:24,970 --> 00:28:26,700
We've essentially eliminated
those.

641
00:28:26,700 --> 00:28:29,340
We still have the round trips
for fetching the stylesheet,

642
00:28:29,340 --> 00:28:30,270
though, right?

643
00:28:30,270 --> 00:28:32,930
They've just moved
to be inline.

644
00:28:32,930 --> 00:28:34,410
And we're still paying
that cost.

645
00:28:34,410 --> 00:28:38,890
And worse than that, we've
moved those assets from a

646
00:28:38,890 --> 00:28:41,670
cacheable resource--
a CSS file--

647
00:28:41,670 --> 00:28:44,640
into sort of a non-cacheable
HTML payload.

648
00:28:44,640 --> 00:28:46,800
So repeat visitors to our
site are going to end up

649
00:28:46,800 --> 00:28:49,350
downloading that content on
every visit, which is pretty

650
00:28:49,350 --> 00:28:50,930
undesirable, right?

651
00:28:50,930 --> 00:28:55,090
And so let's see as a final sort
of optimization if we can

652
00:28:55,090 --> 00:28:56,270
go ahead and address
that issue and

653
00:28:56,270 --> 00:28:58,390
make the page faster.

654
00:28:58,390 --> 00:29:01,740
So the only issue we're faced
with now is that we've got

655
00:29:01,740 --> 00:29:04,900
this large blob of CSS in the
head, and as Doantam talked

656
00:29:04,900 --> 00:29:08,760
about, that ends up delaying
render of the page due to the

657
00:29:08,760 --> 00:29:11,750
TCP congestion window growth.

658
00:29:11,750 --> 00:29:14,820
And so what we want to do is
essentially identify the

659
00:29:14,820 --> 00:29:15,980
critical CSS--

660
00:29:15,980 --> 00:29:18,240
that CSS that's needed
to style and position

661
00:29:18,240 --> 00:29:19,970
content on the page--

662
00:29:19,970 --> 00:29:22,340
and load that inline
in the head.

663
00:29:22,340 --> 00:29:24,200
And ideally, that's small.

664
00:29:24,200 --> 00:29:27,500
And then defer the
non-critical CSS.

665
00:29:27,500 --> 00:29:30,900
So let's see what that
might look like.

666
00:29:30,900 --> 00:29:35,980
So if we take note of the fact
that the CSS is largely data

667
00:29:35,980 --> 00:29:37,260
URIs, right?

668
00:29:37,260 --> 00:29:38,310
And those data URIs are big.

669
00:29:38,310 --> 00:29:42,300
They also don't compress very
well, so they end up taking a

670
00:29:42,300 --> 00:29:46,160
lot of time on the network.

671
00:29:46,160 --> 00:29:49,020
If we say, well, we'll reserve
this space for those

672
00:29:49,020 --> 00:29:50,420
images in the HTML--

673
00:29:50,420 --> 00:29:53,150
we'll carve out that 100 by
100 pixel block, and we'll

674
00:29:53,150 --> 00:29:55,190
make sure to put that style in
early so things don't move

675
00:29:55,190 --> 00:29:58,210
around when the stylesheet
loads, but then we'll load the

676
00:29:58,210 --> 00:30:00,540
remaining content in a deferred
stylesheet in a way

677
00:30:00,540 --> 00:30:03,390
that doesn't block render,
then we can make the page

678
00:30:03,390 --> 00:30:06,540
faster and recover a lot of
the caching benefits of

679
00:30:06,540 --> 00:30:08,460
externalizing that content
in the CSS resource.

680
00:30:08,460 --> 00:30:11,880

681
00:30:11,880 --> 00:30:17,270
So let's go ahead and take a
look at the effect of that.

682
00:30:17,270 --> 00:30:21,820
And so here we've achieved an
even more dramatic speedup of

683
00:30:21,820 --> 00:30:22,700
the first paint time.

684
00:30:22,700 --> 00:30:24,940
Now we're at 1.5 seconds
to display

685
00:30:24,940 --> 00:30:26,440
almost all the content.

686
00:30:26,440 --> 00:30:29,850
You can see that the Chrome
icon comes in a bit later.

687
00:30:29,850 --> 00:30:32,270
And so it's interesting to
look at the waterfall.

688
00:30:32,270 --> 00:30:34,910
For the first time, we've
actually moved the paint line

689
00:30:34,910 --> 00:30:38,320
from the end in, and then we can
see the first paint line

690
00:30:38,320 --> 00:30:39,880
here-- this green line--

691
00:30:39,880 --> 00:30:44,420
actually happens, essentially,
before the deferred stylesheet

692
00:30:44,420 --> 00:30:45,270
has to load.

693
00:30:45,270 --> 00:30:49,050
So we've basically achieved a
render very shortly after the

694
00:30:49,050 --> 00:30:51,400
four round trips we incur for
the network cost, which is

695
00:30:51,400 --> 00:30:53,530
about as good as we can
do on this page.

696
00:30:53,530 --> 00:30:56,540
And then the remaining deferred
styles come in later,

697
00:30:56,540 --> 00:30:58,760
and they automatically kind of--
we'll watch it again just

698
00:30:58,760 --> 00:30:59,330
to see it, right?

699
00:30:59,330 --> 00:31:00,820
The Chrome icon comes
in a slightly

700
00:31:00,820 --> 00:31:02,260
later time at the end.

701
00:31:02,260 --> 00:31:05,380

702
00:31:05,380 --> 00:31:07,250
So one other thing I did just
as a kind of advanced

703
00:31:07,250 --> 00:31:08,990
optimization--

704
00:31:08,990 --> 00:31:11,250
if some of the icons on your
page are really high priority,

705
00:31:11,250 --> 00:31:13,800
you can inline low resolution
previews of those, and that's

706
00:31:13,800 --> 00:31:15,520
what I've done with the
PageSpeed icon.

707
00:31:15,520 --> 00:31:17,860
And that causes that content to
show up a little sooner so

708
00:31:17,860 --> 00:31:21,390
the user can see it, but doesn't
have the cost of

709
00:31:21,390 --> 00:31:24,010
downloading the full
image asset inline

710
00:31:24,010 --> 00:31:25,350
in a blocking manner.

711
00:31:25,350 --> 00:31:29,440
So just real quickly to close,
let's go ahead and look at

712
00:31:29,440 --> 00:31:30,850
where we were and where
we ended up.

713
00:31:30,850 --> 00:31:36,050

714
00:31:36,050 --> 00:31:39,180
So we went from a the first ping
time of 6.6 seconds to

715
00:31:39,180 --> 00:31:42,790
about 1.5 seconds, which is just
about as low as we can

716
00:31:42,790 --> 00:31:43,080
get, right?

717
00:31:43,080 --> 00:31:45,583
That's the sort of absolute
minimum is the four round trip

718
00:31:45,583 --> 00:31:46,620
times of 1.2.

719
00:31:46,620 --> 00:31:48,410
So we've got a little bit of
browser processing time in

720
00:31:48,410 --> 00:31:50,120
there, and we've basically
streamlined

721
00:31:50,120 --> 00:31:51,370
this as much as possible.

722
00:31:51,370 --> 00:31:57,050

723
00:31:57,050 --> 00:31:58,080
So that's it.

724
00:31:58,080 --> 00:32:00,580
So at a high level, designing
for high latency means

725
00:32:00,580 --> 00:32:02,090
following these four
best practices.

726
00:32:02,090 --> 00:32:04,530
Avoiding landing page redirects,
minimizing server

727
00:32:04,530 --> 00:32:07,550
processing time, eliminating
render blocking round trips,

728
00:32:07,550 --> 00:32:10,850
and prioritizing visible
content.

729
00:32:10,850 --> 00:32:12,100
Any questions?

730
00:32:12,100 --> 00:32:21,720

731
00:32:21,720 --> 00:32:27,150
AUDIENCE: So, several of the
tricks that you proposed here

732
00:32:27,150 --> 00:32:33,030
would cause the same URL to
serve both mobile and

733
00:32:33,030 --> 00:32:35,690
non-mobile content.

734
00:32:35,690 --> 00:32:37,760
I think that's still
considered a

735
00:32:37,760 --> 00:32:39,870
no-no by search engines.

736
00:32:39,870 --> 00:32:41,110
Is that--

737
00:32:41,110 --> 00:32:42,390
BRYAN MCQUADE: No.

738
00:32:42,390 --> 00:32:44,690
So I'm not a search expert,
but there's a good bit of

739
00:32:44,690 --> 00:32:49,030
content on the webmaster site
for Google specifically that

740
00:32:49,030 --> 00:32:51,760
talks about the different ways
you can address this issue.

741
00:32:51,760 --> 00:32:55,150
One of them is to have separate
URLs, but we actually

742
00:32:55,150 --> 00:32:57,370
show how you can support
both responsive design

743
00:32:57,370 --> 00:32:58,870
and varying the HTML.

744
00:32:58,870 --> 00:33:03,160
So both those techniques are
supported, at least by Google,

745
00:33:03,160 --> 00:33:04,440
and really should be by
all search engines.

746
00:33:04,440 --> 00:33:08,010
If they're not, then--

747
00:33:08,010 --> 00:33:09,350
Does that--

748
00:33:09,350 --> 00:33:09,580
AUDIENCE: Yeah.

749
00:33:09,580 --> 00:33:13,220
I mean, in this specific
example, the site was very

750
00:33:13,220 --> 00:33:14,610
clearly mobile.

751
00:33:14,610 --> 00:33:16,710
Like, I wouldn't want to
see that on a browser.

752
00:33:16,710 --> 00:33:17,270
BRYAN MCQUADE: Oh, I see.

753
00:33:17,270 --> 00:33:19,300
So what I didn't actually
do there--

754
00:33:19,300 --> 00:33:21,140
there was a line in my .htaccess
that actually

755
00:33:21,140 --> 00:33:24,190
allowed it to conditionally
execute that redirect to the

756
00:33:24,190 --> 00:33:26,110
mobile thing, depending
on the user agent.

757
00:33:26,110 --> 00:33:27,360
So we would still send--

758
00:33:27,360 --> 00:33:34,240
I can actually really quickly
just-- right.

759
00:33:34,240 --> 00:33:35,260
So if I actually enable this--

760
00:33:35,260 --> 00:33:38,230
I didn't, because it made it
hard to actually use the demo

761
00:33:38,230 --> 00:33:38,860
on a desktop.

762
00:33:38,860 --> 00:33:42,390
But now if I re-enable that
rewrite [INAUDIBLE], if you

763
00:33:42,390 --> 00:33:46,800
now go to demo.modspdy.com,
well--

764
00:33:46,800 --> 00:33:49,530

765
00:33:49,530 --> 00:33:51,030
I don't have an index.html
now.

766
00:33:51,030 --> 00:33:51,860
AUDIENCE: Yeah.

767
00:33:51,860 --> 00:33:54,490
Because it's a back end
redirect, though, if you go to

768
00:33:54,490 --> 00:33:58,680
that same URL on a mobile
site, you might

769
00:33:58,680 --> 00:34:00,430
get something different.

770
00:34:00,430 --> 00:34:03,870
So that's why I kind of--

771
00:34:03,870 --> 00:34:06,200
I assume that this was not
intended to change the

772
00:34:06,200 --> 00:34:08,020
recommendation from Google.

773
00:34:08,020 --> 00:34:10,380
This was just an example.

774
00:34:10,380 --> 00:34:10,810
BRYAN MCQUADE: So yeah.

775
00:34:10,810 --> 00:34:12,750
So at a high level,
you should-- and I

776
00:34:12,750 --> 00:34:13,360
apologize for this.

777
00:34:13,360 --> 00:34:14,610
I'm not actually sure
what's going on.

778
00:34:14,610 --> 00:34:16,020
I can debug it in a moment.

779
00:34:16,020 --> 00:34:19,380
At a high level, it's totally
fine to vary the HTML you send

780
00:34:19,380 --> 00:34:20,960
as a function of user agent.

781
00:34:20,960 --> 00:34:22,989
We say you should include the
vary user agent header in the

782
00:34:22,989 --> 00:34:25,970
response as well to give us a
heads up that it does vary as

783
00:34:25,970 --> 00:34:29,020
a function of user agent.

784
00:34:29,020 --> 00:34:29,329
AUDIENCE: Thanks.

785
00:34:29,329 --> 00:34:30,106
BRYAN MCQUADE: Yep.

786
00:34:30,106 --> 00:34:31,480
AUDIENCE: I have a question.

787
00:34:31,480 --> 00:34:33,000
This is kind of a throwback.

788
00:34:33,000 --> 00:34:37,199
Have you played around with
using progressive images?

789
00:34:37,199 --> 00:34:39,790
BRYAN MCQUADE: I think that's
another talk in itself.

790
00:34:39,790 --> 00:34:42,409
So we're looking at that now,
and we're thinking about what

791
00:34:42,409 --> 00:34:46,005
is optimal there, but it's
definitely a big challenge, I

792
00:34:46,005 --> 00:34:49,340
think, to do optimally
and efficiently.

793
00:34:49,340 --> 00:34:51,080
I'd be happy to-- maybe we
can chat afterwards.

794
00:34:51,080 --> 00:34:53,730
AUDIENCE: OK.

795
00:34:53,730 --> 00:34:54,800
AUDIENCE: Hi.

796
00:34:54,800 --> 00:34:57,575
I'm a user of page speed
services, and I

797
00:34:57,575 --> 00:34:58,920
find this very cool.

798
00:34:58,920 --> 00:35:03,260
And I have a question about
how to reduce the latency

799
00:35:03,260 --> 00:35:08,670
about subs request, since we
know that in order for page

800
00:35:08,670 --> 00:35:13,980
speed service to optimize a
page, it will fetch the page

801
00:35:13,980 --> 00:35:18,175
first, and then make several
sample requests.

802
00:35:18,175 --> 00:35:23,310
Could you share a bit about
your consideration about

803
00:35:23,310 --> 00:35:29,140
deploying processing centers
for page speed services in

804
00:35:29,140 --> 00:35:32,235
order to make a great
global product?

805
00:35:32,235 --> 00:35:35,570
BRYAN MCQUADE: So I think Elia,
another person on our

806
00:35:35,570 --> 00:35:37,510
team, will be giving a talk
about PageSpeed products later

807
00:35:37,510 --> 00:35:39,900
today, and that might
be a better question

808
00:35:39,900 --> 00:35:42,010
just to ask to him.

809
00:35:42,010 --> 00:35:44,030
Or we could maybe
chat afterwards.

810
00:35:44,030 --> 00:35:44,340
AUDIENCE: OK.

811
00:35:44,340 --> 00:35:47,140
Thank you.

812
00:35:47,140 --> 00:35:48,390
BRYAN MCQUADE: Any
other questions?

813
00:35:48,390 --> 00:35:50,440

814
00:35:50,440 --> 00:35:51,340
OK.

815
00:35:51,340 --> 00:35:51,940
Thank you.

816
00:35:51,940 --> 00:35:54,220
Oh, we'll do one more.

817
00:35:54,220 --> 00:35:55,710
AUDIENCE: OK, so I noticed you
used some JavaScript magic

818
00:35:55,710 --> 00:35:59,260
there to make the CSS load
in a deferred matter.

819
00:35:59,260 --> 00:36:02,290
Is there any techniques that are
maybe coming to tell the

820
00:36:02,290 --> 00:36:06,040
browser in the style tag to
say, defer this later?

821
00:36:06,040 --> 00:36:07,140
I don't need to do that.

822
00:36:07,140 --> 00:36:08,430
BRYAN MCQUADE: I wish that
existed, and that's something

823
00:36:08,430 --> 00:36:09,960
that, I think, is talked
about a little bit.

824
00:36:09,960 --> 00:36:11,070
I think it's needed.

825
00:36:11,070 --> 00:36:13,930
Anytime you have to use a little
JavaScript snippet, it

826
00:36:13,930 --> 00:36:15,980
feels a little wrong, right?

827
00:36:15,980 --> 00:36:17,940
AUDIENCE: Well, it's really
verbose, and you can't really

828
00:36:17,940 --> 00:36:19,630
know what's going
on unless you--

829
00:36:19,630 --> 00:36:20,100
BRYAN MCQUADE: Right, right.

830
00:36:20,100 --> 00:36:20,430
Yeah.

831
00:36:20,430 --> 00:36:21,720
So I think that's where
we want to be.

832
00:36:21,720 --> 00:36:24,730
There's no mechanism to express,
basically, I want to

833
00:36:24,730 --> 00:36:26,410
load this stylesheet, but don't
have [? a ?] block the

834
00:36:26,410 --> 00:36:28,420
render today, and so you
have to do it in

835
00:36:28,420 --> 00:36:29,520
that mechanism currently.

836
00:36:29,520 --> 00:36:30,976
But I think that's where
we should be moving.

837
00:36:30,976 --> 00:36:31,670
AUDIENCE: Thank you.

838
00:36:31,670 --> 00:36:32,920
BRYAN MCQUADE: Yep.

839
00:36:32,920 --> 00:36:34,790

840
00:36:34,790 --> 00:36:37,290
AUDIENCE: So I had a question
about putting an upstream

841
00:36:37,290 --> 00:36:40,200
cache in front of these
web servers.

842
00:36:40,200 --> 00:36:43,770
And your recommendation is to
vary on the user agent, which

843
00:36:43,770 --> 00:36:45,220
means the cache is basically
made ineffective.

844
00:36:45,220 --> 00:36:48,610

845
00:36:48,610 --> 00:36:49,530
BRYAN MCQUADE: So that's a
good question, actually.

846
00:36:49,530 --> 00:36:55,450
I don't know if there was a
video from the webmaster team

847
00:36:55,450 --> 00:36:58,250
recently about this.

848
00:36:58,250 --> 00:37:03,410
So we talked to some
of the big CDNs--

849
00:37:03,410 --> 00:37:04,860
someone at Akamai, for
instance-- and they actually

850
00:37:04,860 --> 00:37:07,030
walked us through basically how
you would enable this use

851
00:37:07,030 --> 00:37:08,160
case using their system
specifically.

852
00:37:08,160 --> 00:37:10,290
I can point you at that if
that would be helpful.

853
00:37:10,290 --> 00:37:12,530
Basically, it is a solvable
problem that requires a little

854
00:37:12,530 --> 00:37:15,268
bit of additional configuration
on the CDN side.

855
00:37:15,268 --> 00:37:18,450

856
00:37:18,450 --> 00:37:19,420
OK.

857
00:37:19,420 --> 00:37:20,670
Thank you.

858
00:37:20,670 --> 00:37:24,115

