1
00:00:00,000 --> 00:00:01,740

2
00:00:01,740 --> 00:00:03,610
PAUL KINLAN: Hi, everyone.

3
00:00:03,610 --> 00:00:04,760
Welcome to our talk.

4
00:00:04,760 --> 00:00:05,940
There's a lot of
people in here.

5
00:00:05,940 --> 00:00:08,197
We didn't actually expect this
many people, did we?

6
00:00:08,197 --> 00:00:09,510
No.

7
00:00:09,510 --> 00:00:10,650
So hello everyone.

8
00:00:10,650 --> 00:00:15,224
Welcome to Mobile HTML, the
Future of Your Sites.

9
00:00:15,224 --> 00:00:17,530
PETER BEVERLOO: My name is--

10
00:00:17,530 --> 00:00:18,802
PAUL KINLAN: You on?

11
00:00:18,802 --> 00:00:19,258
PETER BEVERLOO: No.

12
00:00:19,258 --> 00:00:22,450
I think it's not.

13
00:00:22,450 --> 00:00:24,450
My name is Peter Beverloo.

14
00:00:24,450 --> 00:00:26,535
I'm a software engineer
at Google.

15
00:00:26,535 --> 00:00:28,275
I work with Chrome
for Android.

16
00:00:28,275 --> 00:00:32,470
And I mostly specialize in--

17
00:00:32,470 --> 00:00:33,720
PAUL KINLAN: Yay.

18
00:00:33,720 --> 00:00:44,250

19
00:00:44,250 --> 00:00:44,420
PETER BEVERLOO: Hello?

20
00:00:44,420 --> 00:00:45,390
Yeah, this sounds better.

21
00:00:45,390 --> 00:00:48,060
PAUL KINLAN: Yay.

22
00:00:48,060 --> 00:00:50,410
[APPLAUSE]

23
00:00:50,410 --> 00:00:51,950
PETER BEVERLOO: So my name
is Peter Beverloo.

24
00:00:51,950 --> 00:00:53,450
I'm a software engineer
at Google.

25
00:00:53,450 --> 00:00:55,180
I work on the Chrome
for Android team.

26
00:00:55,180 --> 00:00:56,820
And I mostly specialize
in pushing the

27
00:00:56,820 --> 00:00:58,950
web platform forwards.

28
00:00:58,950 --> 00:01:00,180
PAUL KINLAN: I'm Paul Kinlan, a

29
00:01:00,180 --> 00:01:02,115
developer advocate on Chrome.

30
00:01:02,115 --> 00:01:03,610
I specialize in the
mobile web.

31
00:01:03,610 --> 00:01:07,076
And you can catch me at all
these normal places.

32
00:01:07,076 --> 00:01:08,360
So should we get started?

33
00:01:08,360 --> 00:01:09,515
PETER BEVERLOO: Sounds good.

34
00:01:09,515 --> 00:01:10,850
PAUL KINLAN: We should
get into it.

35
00:01:10,850 --> 00:01:13,500
So it's always good to start
with a survey, and kind of

36
00:01:13,500 --> 00:01:16,820
understand how everyone in this
room deals with mobile.

37
00:01:16,820 --> 00:01:19,620
So I want everyone to put your
hand up if you have a

38
00:01:19,620 --> 00:01:21,232
smartphone.

39
00:01:21,232 --> 00:01:23,110
Pretty sure that's--

40
00:01:23,110 --> 00:01:24,420
yeah, keep it up, keep it up.

41
00:01:24,420 --> 00:01:26,050
You've got to keep it up.

42
00:01:26,050 --> 00:01:26,450
Right.

43
00:01:26,450 --> 00:01:28,330
So who has a 24 inch
smartphone?

44
00:01:28,330 --> 00:01:31,490

45
00:01:31,490 --> 00:01:33,640
One person has got a 24 inch?

46
00:01:33,640 --> 00:01:33,880
How big?

47
00:01:33,880 --> 00:01:34,810
Come on, show it please.

48
00:01:34,810 --> 00:01:36,060
Have you got it?

49
00:01:36,060 --> 00:01:39,900

50
00:01:39,900 --> 00:01:42,660
I actually, the reason why I'm
kind of looking dumbfounded is

51
00:01:42,660 --> 00:01:44,530
because I actually realized
I'd forgotten to enter the

52
00:01:44,530 --> 00:01:47,090
number of the person
I'm calling.

53
00:01:47,090 --> 00:01:52,040
So who has a dual
24 inch screen?

54
00:01:52,040 --> 00:01:53,886
OK.

55
00:01:53,886 --> 00:01:55,380
I've actually designed
all these slides

56
00:01:55,380 --> 00:01:56,960
for a 24 inch screen.

57
00:01:56,960 --> 00:01:58,690
PETER BEVERLOO: It's a little
bit of a bummer.

58
00:01:58,690 --> 00:02:00,170
PAUL KINLAN: Man.

59
00:02:00,170 --> 00:02:03,542
So who loves typing
on a phone?

60
00:02:03,542 --> 00:02:05,005
OK, no one.

61
00:02:05,005 --> 00:02:06,550
That's cool.

62
00:02:06,550 --> 00:02:09,800
Who has a gigabit ethernet
connected phone?

63
00:02:09,800 --> 00:02:10,539
No?

64
00:02:10,539 --> 00:02:13,456
Who's got like a
5G, a 4G phone?

65
00:02:13,456 --> 00:02:15,560
A couple of people are getting
really fast phones now.

66
00:02:15,560 --> 00:02:18,310
It's kind of interesting.

67
00:02:18,310 --> 00:02:20,850
And who uses their phone
as their primary

68
00:02:20,850 --> 00:02:23,590
desktop type of device?

69
00:02:23,590 --> 00:02:25,050
You know, this is a kind of
interesting one, this one.

70
00:02:25,050 --> 00:02:28,020
Because if you're kind of
working out and about and not

71
00:02:28,020 --> 00:02:30,500
a developer, this actually is
going to be one of those

72
00:02:30,500 --> 00:02:31,680
things that happens in
the near future.

73
00:02:31,680 --> 00:02:34,690
Where your primary machine
actually is your phone.

74
00:02:34,690 --> 00:02:37,280
So I know I'm being a bit kind
of like facetious with the

75
00:02:37,280 --> 00:02:38,620
photos and all this
type of stuff.

76
00:02:38,620 --> 00:02:40,980
But what we're trying to say is
that mobile is different.

77
00:02:40,980 --> 00:02:42,240
And the way that we're building
our sites and

78
00:02:42,240 --> 00:02:44,690
application at the moment, we're
still not targeting this

79
00:02:44,690 --> 00:02:47,470
mobile web, which is, if you
look at India, for instance,

80
00:02:47,470 --> 00:02:50,290
like 60% of the traffic
is mobile based.

81
00:02:50,290 --> 00:02:52,290
And we're still not building
applications and sites that

82
00:02:52,290 --> 00:02:53,480
cater for that.

83
00:02:53,480 --> 00:02:55,490
PETER BEVERLOO: So probably the
most obvious difference

84
00:02:55,490 --> 00:02:58,150
between desktop machines and
mobile devices is that the

85
00:02:58,150 --> 00:02:59,660
screen is significantly
smaller.

86
00:02:59,660 --> 00:03:03,730
So as developers, we've got
less space to play with.

87
00:03:03,730 --> 00:03:04,000
PAUL KINLAN: Yeah.

88
00:03:04,000 --> 00:03:05,250
And I use the mobile, right?

89
00:03:05,250 --> 00:03:07,520
I know the word is mobile when
we're talking about mobile web

90
00:03:07,520 --> 00:03:07,970
development.

91
00:03:07,970 --> 00:03:09,810
But our users are
out and about.

92
00:03:09,810 --> 00:03:12,660
And can we take advantage of the
fact that they might be in

93
00:03:12,660 --> 00:03:14,450
a shopping mall, they might be
on the street, they might be

94
00:03:14,450 --> 00:03:15,895
driving down the road.

95
00:03:15,895 --> 00:03:17,760
They might actually have this
thing where they don't have a

96
00:03:17,760 --> 00:03:18,760
great internet connection.

97
00:03:18,760 --> 00:03:21,070
And can we build applications
and sites which are

98
00:03:21,070 --> 00:03:22,810
responsive to this?

99
00:03:22,810 --> 00:03:24,590
PETER BEVERLOO: And even though
you are the kind of

100
00:03:24,590 --> 00:03:27,660
person who likes writing an
essay on a mobile phone, I

101
00:03:27,660 --> 00:03:30,920
absolutely hate typing
on these devices.

102
00:03:30,920 --> 00:03:33,450
PAUL KINLAN: And most of our
sites also, or most of our

103
00:03:33,450 --> 00:03:35,460
apps, at least, or devices
have unique hardware

104
00:03:35,460 --> 00:03:36,480
capabilities.

105
00:03:36,480 --> 00:03:39,650
Everyone phone has a GPS
receiver, a camera, and a

106
00:03:39,650 --> 00:03:41,910
whole host of other kind of
really interesting features

107
00:03:41,910 --> 00:03:44,940
that we just don't get
on the desktop web.

108
00:03:44,940 --> 00:03:48,220
And what can we do to take
advantage of that today?

109
00:03:48,220 --> 00:03:49,980
PETER BEVERLOO: And then of
course, everything is slower

110
00:03:49,980 --> 00:03:50,830
on a mobile device.

111
00:03:50,830 --> 00:03:53,000
It's not just the screen
which is slower.

112
00:03:53,000 --> 00:03:55,400
But because the whole device is
slower, we actually don't

113
00:03:55,400 --> 00:03:58,630
have the space available to
put in a big ass GPU so to

114
00:03:58,630 --> 00:04:02,480
speak on a desktop machine.

115
00:04:02,480 --> 00:04:05,330
So in this presentation today,
we're going to talk a little

116
00:04:05,330 --> 00:04:08,130
bit about features which are
available on the web today

117
00:04:08,130 --> 00:04:12,020
which are being developed, and a
few features which are still

118
00:04:12,020 --> 00:04:13,790
being under development
by the [INAUDIBLE]

119
00:04:13,790 --> 00:04:14,900
institutes.

120
00:04:14,900 --> 00:04:17,390
But which are still quite
interesting to talk about, and

121
00:04:17,390 --> 00:04:21,550
we expect them to be available
in the near future.

122
00:04:21,550 --> 00:04:26,820
Then we're going to look at six
decent mobile browsers,

123
00:04:26,820 --> 00:04:30,230
notably Opera for Android,
the beta expression.

124
00:04:30,230 --> 00:04:32,990
And these icons will be
displayed on most of the

125
00:04:32,990 --> 00:04:35,130
slides, most of the
feature slides.

126
00:04:35,130 --> 00:04:37,430
And if the logo is colored, then
the feature is available.

127
00:04:37,430 --> 00:04:43,070
If it's grey and kind of light,
then clearly it's not.

128
00:04:43,070 --> 00:04:45,200
So the screens on a mobile
device are smaller.

129
00:04:45,200 --> 00:04:46,830
And this has a number
of constraints

130
00:04:46,830 --> 00:04:48,060
which have put us--

131
00:04:48,060 --> 00:04:50,010
well, not just on
us developers.

132
00:04:50,010 --> 00:04:52,470
But it has constraints on
the end user, as well.

133
00:04:52,470 --> 00:04:56,330
We're used to developing sites
from a desktop perspective.

134
00:04:56,330 --> 00:04:58,910
And we've got all this screen
estate to play with.

135
00:04:58,910 --> 00:05:01,390
And on a mobile device,
clearly, we

136
00:05:01,390 --> 00:05:03,360
need to be more careful.

137
00:05:03,360 --> 00:05:06,420
So the first thing to keep in
mind is that a browser by

138
00:05:06,420 --> 00:05:10,830
default, mobile browser by
default, will assume that the

139
00:05:10,830 --> 00:05:14,370
website you're visiting
is a desktop website.

140
00:05:14,370 --> 00:05:16,830
This means that it will assume
that the width of the web page

141
00:05:16,830 --> 00:05:19,620
will be equal to 980 pixels.

142
00:05:19,620 --> 00:05:21,810
This kind of varies
per browser.

143
00:05:21,810 --> 00:05:24,980
But for Chrome for Android,
it's 980 pixels.

144
00:05:24,980 --> 00:05:27,620
The browser does this because
desktop websites have been

145
00:05:27,620 --> 00:05:29,450
made with a decent
width in mind.

146
00:05:29,450 --> 00:05:31,700
And if you suddenly decrease
the width of the page to be

147
00:05:31,700 --> 00:05:34,440
much smaller than it originally
was, then the

148
00:05:34,440 --> 00:05:37,860
website can completely
look distorted.

149
00:05:37,860 --> 00:05:39,100
Text becomes unreadable.

150
00:05:39,100 --> 00:05:41,870
And functionality becomes
unavailable.

151
00:05:41,870 --> 00:05:44,670
So that's kind of an act we have
to do in order to make

152
00:05:44,670 --> 00:05:47,200
the mobile web usable for
the vast majority

153
00:05:47,200 --> 00:05:49,950
of the website today.

154
00:05:49,950 --> 00:05:51,750
Of course, when you're
developing a mobile website,

155
00:05:51,750 --> 00:05:53,620
this is not what you want.

156
00:05:53,620 --> 00:05:56,520
You want a website to have the
width of the screen itself, so

157
00:05:56,520 --> 00:05:58,460
you don't have horizontal
scrolling.

158
00:05:58,460 --> 00:06:00,520
And the first thing you
should do is add a

159
00:06:00,520 --> 00:06:02,185
meta viewport element.

160
00:06:02,185 --> 00:06:04,980
The third example shows the
complete entry which you

161
00:06:04,980 --> 00:06:06,860
should add to the pages.

162
00:06:06,860 --> 00:06:07,890
It's actually quite simple.

163
00:06:07,890 --> 00:06:10,510
You specify that the width of
your viewport should be equal

164
00:06:10,510 --> 00:06:11,830
to the width of the device.

165
00:06:11,830 --> 00:06:14,690
And you say that the initial
scales should be equal to one,

166
00:06:14,690 --> 00:06:16,900
so that the user doesn't have
to zoom in before they can

167
00:06:16,900 --> 00:06:19,000
read your content.

168
00:06:19,000 --> 00:06:21,920
Now, editing a meta deck can
be a little bit awkward.

169
00:06:21,920 --> 00:06:24,360
And especially if you want to
have several meta decks,

170
00:06:24,360 --> 00:06:27,510
because your viewport has to
be slightly different for a

171
00:06:27,510 --> 00:06:30,060
mobile phone or a
tablet device.

172
00:06:30,060 --> 00:06:33,210
Then you probably have to resort
to either server side

173
00:06:33,210 --> 00:06:35,027
detection of the device
or to JavaScript to

174
00:06:35,027 --> 00:06:36,730
change it on the fly.

175
00:06:36,730 --> 00:06:38,420
And that's just not cool.

176
00:06:38,420 --> 00:06:40,470
So a feature which is currently
being developed is

177
00:06:40,470 --> 00:06:42,480
called CSS Device Adaptation.

178
00:06:42,480 --> 00:06:46,140
And this adds the Add Viewport
rule to CSS.

179
00:06:46,140 --> 00:06:49,240
That viewport rule exposes
exactly the same information

180
00:06:49,240 --> 00:06:50,800
as the meta element.

181
00:06:50,800 --> 00:06:53,370
But it also allows you to change
that information using

182
00:06:53,370 --> 00:06:56,760
the declaratives index, which
you're used to from CSS.

183
00:06:56,760 --> 00:06:58,980
After all, the viewport
itself, it's more

184
00:06:58,980 --> 00:07:00,770
presentational than
it is based on the

185
00:07:00,770 --> 00:07:02,390
semantics of your page.

186
00:07:02,390 --> 00:07:05,430
So it should be better
in CSS anyway.

187
00:07:05,430 --> 00:07:08,550
Now, when you combine this with
Media Queries, which is a

188
00:07:08,550 --> 00:07:11,850
cool trick allowing you to
have different sets of

189
00:07:11,850 --> 00:07:15,150
styling, basic constraints after
the device user is using

190
00:07:15,150 --> 00:07:17,640
to look at your website.

191
00:07:17,640 --> 00:07:20,140
You can actually use Media
Queries to have several Add

192
00:07:20,140 --> 00:07:23,120
Viewport rules based on, for
example, the width of the

193
00:07:23,120 --> 00:07:26,360
device which is being used.

194
00:07:26,360 --> 00:07:29,190
Let's look a little bit more
about these Media Queries.

195
00:07:29,190 --> 00:07:30,880
They are kind of
an old feature.

196
00:07:30,880 --> 00:07:33,810
Most of you will probably
already have used them in one

197
00:07:33,810 --> 00:07:35,060
way or another.

198
00:07:35,060 --> 00:07:39,460
But especially for mobile,
they're quite important.

199
00:07:39,460 --> 00:07:42,750
Now the most basic example
probably is to have different

200
00:07:42,750 --> 00:07:44,250
styling rules based
on the width and

201
00:07:44,250 --> 00:07:45,900
the height of a device.

202
00:07:45,900 --> 00:07:47,775
And you can have as many
constraints in

203
00:07:47,775 --> 00:07:48,930
there as you want.

204
00:07:48,930 --> 00:07:51,700
So you can have different
styling rules for tablets and

205
00:07:51,700 --> 00:07:54,020
phones in its most basic uses.

206
00:07:54,020 --> 00:07:57,160
You can select based on the
aspect ratio of a device.

207
00:07:57,160 --> 00:08:02,130
In a television era, we all
remember the change from

208
00:08:02,130 --> 00:08:05,120
normal 4 by 3 televisions
to 16 by 9 widescreen

209
00:08:05,120 --> 00:08:06,370
televisions.

210
00:08:06,370 --> 00:08:08,720

211
00:08:08,720 --> 00:08:11,960
You still have an old TV.

212
00:08:11,960 --> 00:08:15,010
And because of that, we want
to do this by black bars on

213
00:08:15,010 --> 00:08:16,110
the television itself.

214
00:08:16,110 --> 00:08:18,460
Now, if you have video content
on your page, you actually

215
00:08:18,460 --> 00:08:20,650
might want to do exactly
the same.

216
00:08:20,650 --> 00:08:23,460
And probably, the most
interesting one for today's

217
00:08:23,460 --> 00:08:26,730
mobile devices is the resolution
directive.

218
00:08:26,730 --> 00:08:28,920
The resolution directive allows
you to select based on

219
00:08:28,920 --> 00:08:31,180
the pixel density
of the device.

220
00:08:31,180 --> 00:08:33,610
You may already notice, using
the proprietary, WebKit

221
00:08:33,610 --> 00:08:35,870
defines pixel ratio.

222
00:08:35,870 --> 00:08:38,169
And based on that, you can have
different-- well, a good

223
00:08:38,169 --> 00:08:40,659
use case for that could be to
have different images for high

224
00:08:40,659 --> 00:08:44,390
resolution images such as Apple
retina screens, or the

225
00:08:44,390 --> 00:08:47,690
newer Galaxy Nexus devices,
or for example, the

226
00:08:47,690 --> 00:08:48,940
Galaxy Nexus S4.

227
00:08:48,940 --> 00:08:50,680

228
00:08:50,680 --> 00:08:53,900
A small note about the
resolution Media Query.

229
00:08:53,900 --> 00:08:56,600
While it's upcoming, it's not
yet completely available in

230
00:08:56,600 --> 00:08:57,710
all browsers.

231
00:08:57,710 --> 00:09:01,230
But this index is way less
awkward than the old WebKit

232
00:09:01,230 --> 00:09:04,120
device pixel ratio.

233
00:09:04,120 --> 00:09:07,550
Now, all of these can probably
be used on desktop as well.

234
00:09:07,550 --> 00:09:11,030
And this presentation, after
all, is about mobile.

235
00:09:11,030 --> 00:09:13,470
So one directive which is
especially interesting for

236
00:09:13,470 --> 00:09:17,310
mobile devices is the
orientation Media Query.

237
00:09:17,310 --> 00:09:19,410
This allows you to have
different styling of the page

238
00:09:19,410 --> 00:09:22,165
based on how the user is holding
the device, which can

239
00:09:22,165 --> 00:09:24,380
change while they're watching
your website.

240
00:09:24,380 --> 00:09:27,700

241
00:09:27,700 --> 00:09:30,100
Of course, selecting based
on the viewport itself is

242
00:09:30,100 --> 00:09:31,140
interesting.

243
00:09:31,140 --> 00:09:34,300
But it would also be nice if you
can size elements or fonts

244
00:09:34,300 --> 00:09:36,890
based on the width, the height
of the viewport.

245
00:09:36,890 --> 00:09:38,640
Because of that, four
new units are being

246
00:09:38,640 --> 00:09:40,460
introduced to CSS.

247
00:09:40,460 --> 00:09:41,720
They're called the
viewport units.

248
00:09:41,720 --> 00:09:44,300
There's VW for the width
of the viewports.

249
00:09:44,300 --> 00:09:46,860
There's VH for the height
of the viewports.

250
00:09:46,860 --> 00:09:50,300
And then VMIN and VMAX which
respectively map to the

251
00:09:50,300 --> 00:09:52,920
smallest and the largest
value of the two.

252
00:09:52,920 --> 00:09:55,150
They work a little bit
like percentages.

253
00:09:55,150 --> 00:09:58,700
So 100 VW will be equal
to the complete

254
00:09:58,700 --> 00:09:59,950
width of the viewports.

255
00:09:59,950 --> 00:10:04,140

256
00:10:04,140 --> 00:10:05,910
Now, the viewport itself
is smaller.

257
00:10:05,910 --> 00:10:07,280
We know about that.

258
00:10:07,280 --> 00:10:11,470
And on a desktop machine, we
probably do have two 24 inch

259
00:10:11,470 --> 00:10:13,520
monitors, at least we do.

260
00:10:13,520 --> 00:10:15,700
But you'll at least have one.

261
00:10:15,700 --> 00:10:19,490
And it's quite likely that
content on websites is being

262
00:10:19,490 --> 00:10:23,300
displayed next to each other, or
often in multiple columns.

263
00:10:23,300 --> 00:10:25,630
Just because all this screen
estate is available.

264
00:10:25,630 --> 00:10:28,935
And it's really a shame if
you let it go to waste.

265
00:10:28,935 --> 00:10:31,420
On a mobile device, this
is quite different.

266
00:10:31,420 --> 00:10:32,720
You have a lot less space.

267
00:10:32,720 --> 00:10:35,500
And content which can be
displayed next to each other

268
00:10:35,500 --> 00:10:37,590
might actually be more
convenient if you display it

269
00:10:37,590 --> 00:10:39,970
on top of each other
on a mobile device.

270
00:10:39,970 --> 00:10:42,590
And the CSS Flexible Box
Module allows you to do

271
00:10:42,590 --> 00:10:43,785
exactly this.

272
00:10:43,785 --> 00:10:49,050
It allows you to reorder the
content on the fly, reorder it

273
00:10:49,050 --> 00:10:53,070
based on putting an element
above the other using CSS, or

274
00:10:53,070 --> 00:10:55,750
even changing the entire
flow of your content.

275
00:10:55,750 --> 00:10:58,300
Now, one thing to keep in mind
is that the syntax of the

276
00:10:58,300 --> 00:11:01,010
Flexible Box Module
changed recently.

277
00:11:01,010 --> 00:11:04,260
And it's a little bit awkward,
but you may have to support

278
00:11:04,260 --> 00:11:07,190
both the old and the new syntax
until enough browsers

279
00:11:07,190 --> 00:11:10,330
hit the new syntax.

280
00:11:10,330 --> 00:11:12,855
And we all know fixed
position elements.

281
00:11:12,855 --> 00:11:14,450
They stick around on
your viewport.

282
00:11:14,450 --> 00:11:17,110
Could be useful for like
a navigation bar.

283
00:11:17,110 --> 00:11:20,160
But fixed position elements
have got a little brother

284
00:11:20,160 --> 00:11:22,860
called sticky position
elements.

285
00:11:22,860 --> 00:11:26,350
These behave like inline inflow
elements, just as if

286
00:11:26,350 --> 00:11:29,210
they're relatively positioned,
unless the parent element

287
00:11:29,210 --> 00:11:31,050
partially moves out of view.

288
00:11:31,050 --> 00:11:33,510
In that case, the browser will
make sure that the sticky

289
00:11:33,510 --> 00:11:37,160
positioned element kind of
sticks around in a few parts,

290
00:11:37,160 --> 00:11:40,650
which is quite a cool feature
which is really useful for, as

291
00:11:40,650 --> 00:11:44,990
an example, the address book
showed on the slide.

292
00:11:44,990 --> 00:11:45,420
PAUL KINLAN: Cool.

293
00:11:45,420 --> 00:11:48,010
So we said earlier on that
users are mobile.

294
00:11:48,010 --> 00:11:49,990
And we're trying to talk about
the idea that they might not

295
00:11:49,990 --> 00:11:51,190
always have an Internet
connection.

296
00:11:51,190 --> 00:11:54,220
They might be in a place where
maybe they're on a train for

297
00:11:54,220 --> 00:11:56,130
instance, where they go
through a tunnel.

298
00:11:56,130 --> 00:11:57,750
And the Internet connection
dies.

299
00:11:57,750 --> 00:12:00,220
And on the mobile web, just
generally that experience is

300
00:12:00,220 --> 00:12:01,390
pretty bad.

301
00:12:01,390 --> 00:12:02,800
So we're going to look at
a couple of different

302
00:12:02,800 --> 00:12:06,460
technologies that you can use
today pretty much across all

303
00:12:06,460 --> 00:12:09,360
of the mobile web to actually
accommodate the fact that your

304
00:12:09,360 --> 00:12:11,170
users are mobile.

305
00:12:11,170 --> 00:12:12,425
Now, I want to do
a little survey.

306
00:12:12,425 --> 00:12:15,850
Who knows the Geolocation API?

307
00:12:15,850 --> 00:12:16,980
OK, not actually--

308
00:12:16,980 --> 00:12:18,430
I was expecting more people.

309
00:12:18,430 --> 00:12:21,160
So anyway, the Geolocation API,
it's been around on the

310
00:12:21,160 --> 00:12:23,080
web for quite a long time now.

311
00:12:23,080 --> 00:12:25,580
And it's really good for
specializing content, for

312
00:12:25,580 --> 00:12:28,450
instance, on new sites where
you'll say, where is the user?

313
00:12:28,450 --> 00:12:29,450
Oh, they're based in the UK.

314
00:12:29,450 --> 00:12:31,610
We're going to give them
UK based news.

315
00:12:31,610 --> 00:12:35,325
Now, users, developers in
fact, always used to use

316
00:12:35,325 --> 00:12:36,930
reverse IP look up.

317
00:12:36,930 --> 00:12:38,930
On mobile, that's not as
applicable anymore.

318
00:12:38,930 --> 00:12:41,260
And especially if you want to
get fine grained control of

319
00:12:41,260 --> 00:12:43,810
where the user is and understand
where they are, you

320
00:12:43,810 --> 00:12:45,995
need an API like the
Geolocation API.

321
00:12:45,995 --> 00:12:47,490
And it's a pretty simple API.

322
00:12:47,490 --> 00:12:48,750
You get Chrome composition.

323
00:12:48,750 --> 00:12:51,050
And after a short time, it will
basically tell you the

324
00:12:51,050 --> 00:12:52,630
users' code and location.

325
00:12:52,630 --> 00:12:54,860
There's actually an accuracy
level, as well.

326
00:12:54,860 --> 00:12:57,210
And kind of what Android does
as well at the moment is it

327
00:12:57,210 --> 00:12:59,810
will give you that location
pretty quickly, but it's not

328
00:12:59,810 --> 00:13:00,600
hugely accurate.

329
00:13:00,600 --> 00:13:03,530
It might be within, say, 100
meters of where the user is.

330
00:13:03,530 --> 00:13:05,450
If you want to get a more
accurate look on the user,

331
00:13:05,450 --> 00:13:08,680
there's another API called Watch
Position, which actually

332
00:13:08,680 --> 00:13:10,100
it does exactly what it says.

333
00:13:10,100 --> 00:13:13,240
It watches the user's position
whilst they're on that page.

334
00:13:13,240 --> 00:13:15,090
And it could be used for
situations where you're trying

335
00:13:15,090 --> 00:13:17,110
to track the user when they're
walking down the street.

336
00:13:17,110 --> 00:13:18,950
And you can update a map.

337
00:13:18,950 --> 00:13:21,910
Or it could just be used
to get a final lock on

338
00:13:21,910 --> 00:13:23,050
where the user is.

339
00:13:23,050 --> 00:13:26,260
So you for instance could say,
well, the first request is

340
00:13:26,260 --> 00:13:27,180
within 100 meters.

341
00:13:27,180 --> 00:13:28,770
And then after a couple
of seconds--

342
00:13:28,770 --> 00:13:29,940
and you'll probably
see from this demo

343
00:13:29,940 --> 00:13:32,280
if it actually works--

344
00:13:32,280 --> 00:13:33,650
the accuracy level changes.

345
00:13:33,650 --> 00:13:35,790
So it goes from say an
accuracy level of 11

346
00:13:35,790 --> 00:13:37,640
to 10 to 9 to 8.

347
00:13:37,640 --> 00:13:39,980
And as it gets more accurate,
your position gets more and

348
00:13:39,980 --> 00:13:42,470
more close to where
the user is.

349
00:13:42,470 --> 00:13:44,660
PETER BEVERLOO: So if you saw
the keynote yesterday morning,

350
00:13:44,660 --> 00:13:47,170
in the Android parts, they
introduced a new version of

351
00:13:47,170 --> 00:13:48,770
the Google Play surfaces.

352
00:13:48,770 --> 00:13:53,030
And this has a feature called
the User Location Profiler.

353
00:13:53,030 --> 00:13:55,290
And the User Location Profiler
will actually mean that the

354
00:13:55,290 --> 00:13:58,270
phone has a guessed position
of where the user is.

355
00:13:58,270 --> 00:14:01,850
So Get Current Position will be
able to more quickly return

356
00:14:01,850 --> 00:14:05,770
a more accurate position if you
use this new version of

357
00:14:05,770 --> 00:14:08,970
the Android place of this.

358
00:14:08,970 --> 00:14:09,750
PAUL KINLAN: So you know
where the user is.

359
00:14:09,750 --> 00:14:11,620
And you're trying to not
necessarily track them but

360
00:14:11,620 --> 00:14:13,350
understand where they are
so you can adapt your

361
00:14:13,350 --> 00:14:14,750
application.

362
00:14:14,750 --> 00:14:17,140
Device Orientation is another
feature that is available

363
00:14:17,140 --> 00:14:19,210
pretty much across most
of the mobile web.

364
00:14:19,210 --> 00:14:21,580
And device orientation, it's
a pretty simple API.

365
00:14:21,580 --> 00:14:23,890
We saw the CSS before where you
could understand whether

366
00:14:23,890 --> 00:14:26,390
the user was in portrait
or landscape mode.

367
00:14:26,390 --> 00:14:28,800
The orientation events basically
fire whenever the

368
00:14:28,800 --> 00:14:30,130
user moves their phone.

369
00:14:30,130 --> 00:14:31,870
So if they're holding the
phone this way, you can

370
00:14:31,870 --> 00:14:33,660
understand the angle, the
pitch, which is the beta

371
00:14:33,660 --> 00:14:36,040
properly of how they're
holding their phone.

372
00:14:36,040 --> 00:14:38,990
And you can also understand with
a relatively decent level

373
00:14:38,990 --> 00:14:40,990
of accuracy their compass
location, which

374
00:14:40,990 --> 00:14:42,020
is the alpha property.

375
00:14:42,020 --> 00:14:44,540
And I think technically
it's called your.

376
00:14:44,540 --> 00:14:46,820
It's pretty well supported
across the mobile web.

377
00:14:46,820 --> 00:14:48,150
And you can use it today.

378
00:14:48,150 --> 00:14:50,390
It's been around for about at
least a year and a half.

379
00:14:50,390 --> 00:14:51,950
So we know where the user is.

380
00:14:51,950 --> 00:14:54,490
And we're trying to help you
build applications which are

381
00:14:54,490 --> 00:14:57,160
responsible to how they're
holding their phone.

382
00:14:57,160 --> 00:14:59,800
The biggest problem that we face
in the mobile web with

383
00:14:59,800 --> 00:15:02,570
regards to users on the
move is offline.

384
00:15:02,570 --> 00:15:04,120
Now offline is super
important.

385
00:15:04,120 --> 00:15:05,610
And if you're an application
developer, a native

386
00:15:05,610 --> 00:15:08,320
application developer, you've
already got offline supported.

387
00:15:08,320 --> 00:15:10,590
You build your applications to
work offline straight away.

388
00:15:10,590 --> 00:15:12,830
And then integrate online
functionality in.

389
00:15:12,830 --> 00:15:15,310
We as web developers, like,
everything is always online.

390
00:15:15,310 --> 00:15:16,120
We go to a URL.

391
00:15:16,120 --> 00:15:17,310
We always get it.

392
00:15:17,310 --> 00:15:19,450
And it actually is pretty hard
to integrate offline

393
00:15:19,450 --> 00:15:21,660
functionality into
our applications.

394
00:15:21,660 --> 00:15:23,840
The first thing that we can do
though is we can look and

395
00:15:23,840 --> 00:15:27,290
understand when the user is
either online or offline.

396
00:15:27,290 --> 00:15:29,300
Now it's not entirely
accurate.

397
00:15:29,300 --> 00:15:30,960
And you can understand exactly
when they're offline.

398
00:15:30,960 --> 00:15:33,360
Because they have no network
connection, basically.

399
00:15:33,360 --> 00:15:34,860
But the online state
is a little bit

400
00:15:34,860 --> 00:15:35,940
more awkward, right?

401
00:15:35,940 --> 00:15:37,140
You could be online.

402
00:15:37,140 --> 00:15:39,860
You could be on a local network,
a Wi-Fi connection

403
00:15:39,860 --> 00:15:41,580
but have no Internet
connection.

404
00:15:41,580 --> 00:15:44,430
So the online event really just
basically means that you

405
00:15:44,430 --> 00:15:45,760
have a connection
to a network.

406
00:15:45,760 --> 00:15:47,870
It might not be a connection
to the Internet.

407
00:15:47,870 --> 00:15:49,810
And there's a property that you
can want to see whether

408
00:15:49,810 --> 00:15:51,210
you are online or not.

409
00:15:51,210 --> 00:15:53,470
And this is great for when you
are building an application,

410
00:15:53,470 --> 00:15:55,560
and the users going to
submit the form.

411
00:15:55,560 --> 00:15:56,830
You can just basically
say, hey, you

412
00:15:56,830 --> 00:15:57,930
can't submit this form.

413
00:15:57,930 --> 00:15:58,550
You're offline.

414
00:15:58,550 --> 00:16:01,390
So you can provide a nice little
bit of feedback there.

415
00:16:01,390 --> 00:16:02,560
You go one step further.

416
00:16:02,560 --> 00:16:05,850
You understand when the user
is online or offline.

417
00:16:05,850 --> 00:16:07,130
They go to the URL bar.

418
00:16:07,130 --> 00:16:08,220
They press Refresh.

419
00:16:08,220 --> 00:16:10,610
And then they get this really
horrible gateway error or a

420
00:16:10,610 --> 00:16:13,910
Chrome error that says like,
hey, no Internet connection.

421
00:16:13,910 --> 00:16:15,030
You can't do anything.

422
00:16:15,030 --> 00:16:16,270
That's a really bad
experience.

423
00:16:16,270 --> 00:16:17,600
And that's one of the things
that's holding

424
00:16:17,600 --> 00:16:19,070
the mobile web back.

425
00:16:19,070 --> 00:16:22,530
Well, this application, or
Application Cache, this API

426
00:16:22,530 --> 00:16:24,850
has been around for quite
a long time now.

427
00:16:24,850 --> 00:16:26,100
And a lot of people
don't like it.

428
00:16:26,100 --> 00:16:27,460
It's got a bit of a bad press.

429
00:16:27,460 --> 00:16:29,640
But if you're building an
application which is like a

430
00:16:29,640 --> 00:16:33,160
single page application, this
API will help you easily make

431
00:16:33,160 --> 00:16:34,880
your application work offline.

432
00:16:34,880 --> 00:16:37,470
And it does so by basically
listing a whole series of

433
00:16:37,470 --> 00:16:39,540
files which encompass
your application.

434
00:16:39,540 --> 00:16:41,530
It's called the application
manifest.

435
00:16:41,530 --> 00:16:43,930
And in your HTML, you point
to the manifest using the

436
00:16:43,930 --> 00:16:44,735
manifest attribute.

437
00:16:44,735 --> 00:16:48,060
And the browser will then go
off, make sure all the assets

438
00:16:48,060 --> 00:16:49,240
are available for offline use.

439
00:16:49,240 --> 00:16:51,720
So when you press Refresh,
you'll still be able to get

440
00:16:51,720 --> 00:16:52,810
your application.

441
00:16:52,810 --> 00:16:55,660
And I must warn you, there's a
whole lot of photos of my face

442
00:16:55,660 --> 00:16:58,280
entirely through this
presentation.

443
00:16:58,280 --> 00:16:59,580
I guess it's the only one
we had rights to.

444
00:16:59,580 --> 00:17:03,010
And he didn't want me to
do anything with his.

445
00:17:03,010 --> 00:17:04,780
So anyway, so that's the
Application Cache.

446
00:17:04,780 --> 00:17:07,050
There are a couple of
little caveats.

447
00:17:07,050 --> 00:17:09,740
If you update any of your
assets, and then you expect

448
00:17:09,740 --> 00:17:11,329
the user to be able to
get them, they won't.

449
00:17:11,329 --> 00:17:12,770
They need to update the
manifest, or you need to

450
00:17:12,770 --> 00:17:15,329
update the manifest for them
to go and get that data.

451
00:17:15,329 --> 00:17:17,410
And if you cache the manifest
itself, you're just into a

452
00:17:17,410 --> 00:17:18,750
whole heap of pain.

453
00:17:18,750 --> 00:17:20,420
Because you'll never be able
to update the manifest,

454
00:17:20,420 --> 00:17:21,850
because everyone will always
have the manifest--

455
00:17:21,850 --> 00:17:23,630
oh, it's a nightmare.

456
00:17:23,630 --> 00:17:25,869
Anyway, we have storage
APIs, right?

457
00:17:25,869 --> 00:17:27,700
We have this idea that
our applications are

458
00:17:27,700 --> 00:17:29,040
going to work offline.

459
00:17:29,040 --> 00:17:31,150
And for them to work offline, we
need to make sure our data

460
00:17:31,150 --> 00:17:32,190
is offline.

461
00:17:32,190 --> 00:17:34,610
And you know, we're not actually
in a great position,

462
00:17:34,610 --> 00:17:37,030
are we, on the mobile
web at the moment?

463
00:17:37,030 --> 00:17:38,060
We have local storage.

464
00:17:38,060 --> 00:17:41,120
Local storage, key value pair
system-- you can blobs of data

465
00:17:41,120 --> 00:17:44,020
and strings of data and get
them out and fire a key.

466
00:17:44,020 --> 00:17:45,070
And it's ubiquitous.

467
00:17:45,070 --> 00:17:47,550
It's on every single
platform available.

468
00:17:47,550 --> 00:17:49,930
However, you can't really do
any rich, powerful querying

469
00:17:49,930 --> 00:17:51,320
semantics with it.

470
00:17:51,320 --> 00:17:52,850
We have two other APIs, Web SQL

471
00:17:52,850 --> 00:17:55,590
Database and Indexed Database.

472
00:17:55,590 --> 00:17:57,040
Web SQL, it's kind of cool.

473
00:17:57,040 --> 00:17:57,815
Everyone knows SQL.

474
00:17:57,815 --> 00:17:59,984
Hands up if you know SQL?

475
00:17:59,984 --> 00:18:00,432
See.

476
00:18:00,432 --> 00:18:02,290
Are there any browser
vendors in here who

477
00:18:02,290 --> 00:18:04,650
said, Web SQL's rubbish?

478
00:18:04,650 --> 00:18:06,780
Everyone said it's cool.

479
00:18:06,780 --> 00:18:09,180
So anyway, so Web SQL,
everyone knows SQL.

480
00:18:09,180 --> 00:18:11,830
It's got rich querying
semantics.

481
00:18:11,830 --> 00:18:13,420
However, it's not broadly
supported.

482
00:18:13,420 --> 00:18:15,110
It's not yet--

483
00:18:15,110 --> 00:18:16,720
it's in iOS, Android,
and Chrome.

484
00:18:16,720 --> 00:18:19,100
But it's not in Firefox.

485
00:18:19,100 --> 00:18:19,820
And it's not in Internet
Explorer.

486
00:18:19,820 --> 00:18:21,090
And it's no plans
to be in there.

487
00:18:21,090 --> 00:18:22,790
It's a deprecated API.

488
00:18:22,790 --> 00:18:24,090
We have Indexed Database.

489
00:18:24,090 --> 00:18:25,640
index Database is the way
that we're going to

490
00:18:25,640 --> 00:18:26,870
store data in the web.

491
00:18:26,870 --> 00:18:29,995
But it's not really
broadly supported.

492
00:18:29,995 --> 00:18:31,440
It's not on iOS.

493
00:18:31,440 --> 00:18:33,520
It's not on Android,
I think Chrome and

494
00:18:33,520 --> 00:18:35,010
the rest of the browsers.

495
00:18:35,010 --> 00:18:37,140
So what are you going to
do as a developer?

496
00:18:37,140 --> 00:18:40,220
Well, the only sane solution
that we've got is to use

497
00:18:40,220 --> 00:18:41,800
abstractions and use shims.

498
00:18:41,800 --> 00:18:43,180
There are a couple of
shims out there.

499
00:18:43,180 --> 00:18:45,110
Lawn Chair has been around
for a long, long time.

500
00:18:45,110 --> 00:18:48,090
And it's basically a key value
pair system with some query

501
00:18:48,090 --> 00:18:51,230
semantics, where you can plug
in your own custom providers

502
00:18:51,230 --> 00:18:53,400
to say, hey, I want to
use Web SQL database.

503
00:18:53,400 --> 00:18:55,200
Or hey, I'm going to use
Indexed Database.

504
00:18:55,200 --> 00:18:57,500
And then there's two others,
asyncStorage, which is similar

505
00:18:57,500 --> 00:19:00,000
to Lawn Chair, and then the
Indexed Database shim.

506
00:19:00,000 --> 00:19:02,590
And the Indexed Database shim
basically says, you know what?

507
00:19:02,590 --> 00:19:05,190
We're going to use the Indexed
Database API if it's there.

508
00:19:05,190 --> 00:19:07,540
If it's not there, we're just
going to fall back to Web SQL.

509
00:19:07,540 --> 00:19:09,990
And if you have that method,
where you can fall back from

510
00:19:09,990 --> 00:19:12,920
Indexed Database to Web SQL, you
can cover pretty much all

511
00:19:12,920 --> 00:19:15,110
the mobile web for
storing offline.

512
00:19:15,110 --> 00:19:17,980

513
00:19:17,980 --> 00:19:20,000
PETER BEVERLOO: So input on
a mobile device is harder.

514
00:19:20,000 --> 00:19:20,670
We notice.

515
00:19:20,670 --> 00:19:22,590
We don't write essays
on a mobile device.

516
00:19:22,590 --> 00:19:24,760
And for the major share, they're
actually used for

517
00:19:24,760 --> 00:19:27,590
consumption of data rather
than producing data.

518
00:19:27,590 --> 00:19:30,360
Now, this shows when you have
a form on your website, even

519
00:19:30,360 --> 00:19:32,620
if it's just a login form
or a form where a user

520
00:19:32,620 --> 00:19:33,810
has to enter a number.

521
00:19:33,810 --> 00:19:35,280
It's just awkward to enter it.

522
00:19:35,280 --> 00:19:38,280
Especially on a mobile device
like a phone, you look at this

523
00:19:38,280 --> 00:19:42,910
on screen keyboards, and it's
just basically awkward to use.

524
00:19:42,910 --> 00:19:44,570
I often click on the
wrong letter.

525
00:19:44,570 --> 00:19:47,350
And I've learned to rely on the
auto correction feature,

526
00:19:47,350 --> 00:19:50,070
or even on the suggestions,
which can be displayed above

527
00:19:50,070 --> 00:19:54,310
the keyboard itself, which is
something Android does.

528
00:19:54,310 --> 00:19:57,970
Now, you've probably heard this
a million times already.

529
00:19:57,970 --> 00:20:00,250
Use semantical input types.

530
00:20:00,250 --> 00:20:01,050
It's quite simple.

531
00:20:01,050 --> 00:20:04,360
Instead of using input type as
text, you use input type with

532
00:20:04,360 --> 00:20:06,920
a more specialized type.

533
00:20:06,920 --> 00:20:09,960
A good example of this is using
input types number.

534
00:20:09,960 --> 00:20:12,160
If you want the user to enter
a number, which could be a

535
00:20:12,160 --> 00:20:15,090
telephone number or a price or
anything else, you really

536
00:20:15,090 --> 00:20:18,310
don't want to have them go
through the hassle of seeing

537
00:20:18,310 --> 00:20:21,150
letters, chapters on their
keyboards, having to click on

538
00:20:21,150 --> 00:20:23,980
shift, and then finding really
small buttons of the numbers.

539
00:20:23,980 --> 00:20:26,520
Well, the phone has a perfectly
optimized keyboard

540
00:20:26,520 --> 00:20:28,940
just showing numbers.

541
00:20:28,940 --> 00:20:33,880
Now, a more extreme example
probably is data time input.

542
00:20:33,880 --> 00:20:36,760
I'm from the UK, as is Paul.

543
00:20:36,760 --> 00:20:40,480
And date and time, I believe
here you write month first and

544
00:20:40,480 --> 00:20:42,250
then the day and
then the year.

545
00:20:42,250 --> 00:20:43,160
For us, it's different.

546
00:20:43,160 --> 00:20:44,620
From other countries, it's
different again.

547
00:20:44,620 --> 00:20:46,398
PAUL KINLAN: I believe the UK
has the correct format.

548
00:20:46,398 --> 00:20:50,390

549
00:20:50,390 --> 00:20:51,810
PETER BEVERLOO: D is, that's
just to separate the

550
00:20:51,810 --> 00:20:54,730
components of a date,
or D is slashes.

551
00:20:54,730 --> 00:20:55,990
And really, it's just awkward.

552
00:20:55,990 --> 00:20:59,130
And it's not just difficult for
the end user using your

553
00:20:59,130 --> 00:21:00,580
website, but it's
also difficult

554
00:21:00,580 --> 00:21:01,900
for you as a developer.

555
00:21:01,900 --> 00:21:04,650
Because users give all these
days in random input types.

556
00:21:04,650 --> 00:21:06,750
And you have to write
complicated procedures in your

557
00:21:06,750 --> 00:21:08,750
back end to handle
all of them.

558
00:21:08,750 --> 00:21:11,710
Now if you would just change
that input type as text to

559
00:21:11,710 --> 00:21:15,220
input type as date or even input
type data and local.

560
00:21:15,220 --> 00:21:17,170
Then the phone will be
able to do something

561
00:21:17,170 --> 00:21:19,050
really smart and simple.

562
00:21:19,050 --> 00:21:20,290
It's actually a no brainer.

563
00:21:20,290 --> 00:21:23,030
It will show you a date
and time picker.

564
00:21:23,030 --> 00:21:25,880
And by a date and time picker,
that makes it infinitely

565
00:21:25,880 --> 00:21:30,160
easier to enter a data or time
for a site, and will give you

566
00:21:30,160 --> 00:21:32,860
as a developer a more consistent
result when a user

567
00:21:32,860 --> 00:21:35,780
submits that form
to the website.

568
00:21:35,780 --> 00:21:40,510
Now, this doesn't just
result in more

569
00:21:40,510 --> 00:21:42,210
convenience for the user.

570
00:21:42,210 --> 00:21:45,080
Another additional benefit you
get from this is validation,

571
00:21:45,080 --> 00:21:48,180
client side validation of
the input type itself.

572
00:21:48,180 --> 00:21:52,720
But if a user somehow manages to
enter rubbish, the browser

573
00:21:52,720 --> 00:21:55,420
will show a dialogue about, I
don't know what you're doing.

574
00:21:55,420 --> 00:21:58,230
But this is not quite what the
website will be expecting.

575
00:21:58,230 --> 00:21:59,910
You want to correct this.

576
00:21:59,910 --> 00:22:02,980
And you can use attributes,
that's just min and max, to

577
00:22:02,980 --> 00:22:07,690
actually impose a range based on
which number or which date

578
00:22:07,690 --> 00:22:11,010
can be entered by
the end user.

579
00:22:11,010 --> 00:22:13,665
Now, when I use my desktop
computer, I have this small

580
00:22:13,665 --> 00:22:15,620
device next to me, a mouse.

581
00:22:15,620 --> 00:22:18,620
And this gives me a cursor on
the screen itself, which is

582
00:22:18,620 --> 00:22:20,210
incredibly accurate.

583
00:22:20,210 --> 00:22:21,730
It's really convenient to use.

584
00:22:21,730 --> 00:22:24,200
It allows me to select any
element or any position on my

585
00:22:24,200 --> 00:22:26,950
screen with really
high accuracy,

586
00:22:26,950 --> 00:22:29,530
Now, I don't know about you
guys, but in comparison to

587
00:22:29,530 --> 00:22:32,420
that mouse pointer,
my finger is fat.

588
00:22:32,420 --> 00:22:33,510
It's really fat.

589
00:22:33,510 --> 00:22:37,400
It's inaccurate and it becomes
infinitely harder to click on

590
00:22:37,400 --> 00:22:39,780
exactly the point on the
screen where I want.

591
00:22:39,780 --> 00:22:41,930
And this has forced browsers
to implement alternative

592
00:22:41,930 --> 00:22:46,370
solutions such as Chrome's
disambiguation pop up, which

593
00:22:46,370 --> 00:22:49,470
basically zooms in on part of
the page, allowing you to

594
00:22:49,470 --> 00:22:50,990
clarify what you mean.

595
00:22:50,990 --> 00:22:54,300
Or for Safari, to have a number
of heuristics available

596
00:22:54,300 --> 00:22:57,170
to think what you might want
to have clicked on.

597
00:22:57,170 --> 00:22:59,440
Now, you can optimize
for this.

598
00:22:59,440 --> 00:23:01,405
There are three primary
events available.

599
00:23:01,405 --> 00:23:03,930
And that's Start, which will
be called when you put a

600
00:23:03,930 --> 00:23:06,780
finger on the screen, On Touch
Move, when you actually move

601
00:23:06,780 --> 00:23:10,700
on a screen, and On Touch End,
when you remove the finger

602
00:23:10,700 --> 00:23:12,180
from the screen again.

603
00:23:12,180 --> 00:23:15,060
And this allows you to optimize
your application for

604
00:23:15,060 --> 00:23:16,080
touch inputs.

605
00:23:16,080 --> 00:23:19,360
And maybe have a slightly bigger
error margins, because

606
00:23:19,360 --> 00:23:21,200
it's more inaccurate.

607
00:23:21,200 --> 00:23:23,390
Or have a different UI,
different handling all

608
00:23:23,390 --> 00:23:26,910
together based on what a user
does with their fingers.

609
00:23:26,910 --> 00:23:29,750
Now, there's one thing
to keep in mind here.

610
00:23:29,750 --> 00:23:32,940
There is a small click delay
imposed by the browser.

611
00:23:32,940 --> 00:23:36,190
When you tap on the screen
itself and remove your finger

612
00:23:36,190 --> 00:23:37,440
again, that's a tap.

613
00:23:37,440 --> 00:23:40,710
But there is this gesture
available in Chrome called

614
00:23:40,710 --> 00:23:42,200
double tap to zoom.

615
00:23:42,200 --> 00:23:45,290
Now, if you double tap on the
screen, it will zoom in to

616
00:23:45,290 --> 00:23:45,880
that element.

617
00:23:45,880 --> 00:23:48,360
And the page will not receive
a click element.

618
00:23:48,360 --> 00:23:51,010
The browser needs a little bit
of time to actually figure out

619
00:23:51,010 --> 00:23:53,460
whether you want to tap
once or tap twice.

620
00:23:53,460 --> 00:23:56,240
And before it knows that,
it will wait.

621
00:23:56,240 --> 00:23:59,622
And after that wait, it will
send to click event.

622
00:23:59,622 --> 00:24:03,590
Now, 300 milliseconds is quite
a long time if you want to

623
00:24:03,590 --> 00:24:06,420
have a responsive
user interface.

624
00:24:06,420 --> 00:24:08,410
It's a number of frames.

625
00:24:08,410 --> 00:24:10,380
It's actually 20 frames.

626
00:24:10,380 --> 00:24:12,690
That's quite a lot.

627
00:24:12,690 --> 00:24:18,270
So you should be really careful
with, well, you can

628
00:24:18,270 --> 00:24:21,430
avoid it if you set a viewport
rule on your page.

629
00:24:21,430 --> 00:24:24,350
And the next feature, Pointer
Events, also provides a

630
00:24:24,350 --> 00:24:26,500
solution to this.

631
00:24:26,500 --> 00:24:28,740
Pointer Events is a
specification which is still

632
00:24:28,740 --> 00:24:32,150
in development, which unifies
certain concepts.

633
00:24:32,150 --> 00:24:35,610
It unifies a concept of a mouse
pointer and touch inputs

634
00:24:35,610 --> 00:24:38,950
and, for example, a stylus into
the concept of a pointer,

635
00:24:38,950 --> 00:24:41,220
which really could be anything,
without losing too

636
00:24:41,220 --> 00:24:46,200
much of the pointer specific
information or constraints.

637
00:24:46,200 --> 00:24:49,720
The JavaScript imperative event
API is quite similar to

638
00:24:49,720 --> 00:24:51,490
what we're used to from
mouse events.

639
00:24:51,490 --> 00:24:54,690
Instead of mouse in the name,
you'll have pointer.

640
00:24:54,690 --> 00:24:57,970
And it will allow you to
create a flow in your

641
00:24:57,970 --> 00:25:00,750
application to handle both touch
inputs and mouse input

642
00:25:00,750 --> 00:25:03,050
using the same code.

643
00:25:03,050 --> 00:25:06,350
Now, this specification also
comes with a simple CSS

644
00:25:06,350 --> 00:25:08,100
property called .action.

645
00:25:08,100 --> 00:25:11,420
And if you specify .action as
none on any element, you will

646
00:25:11,420 --> 00:25:13,965
actually tell the browser that
if the user taps on exactly

647
00:25:13,965 --> 00:25:17,760
that element, that the
browser shouldn't

648
00:25:17,760 --> 00:25:19,350
do any default action.

649
00:25:19,350 --> 00:25:22,680
And thereby, the double click to
zoom just here won't work.

650
00:25:22,680 --> 00:25:24,870
And because it won't work, the
browser doesn't have to wait

651
00:25:24,870 --> 00:25:26,180
300 milliseconds.

652
00:25:26,180 --> 00:25:28,340
And can immediately forward
to defend that click

653
00:25:28,340 --> 00:25:30,580
event to the browser.

654
00:25:30,580 --> 00:25:33,540
Quite related but not
specifically part of the

655
00:25:33,540 --> 00:25:37,040
Pointer Event specification
are the pointer directives

656
00:25:37,040 --> 00:25:39,130
available from Media Queries.

657
00:25:39,130 --> 00:25:42,070
And by specifying point of
course for fingers or pointer

658
00:25:42,070 --> 00:25:44,970
find from mouse pointers, you
can actually have different

659
00:25:44,970 --> 00:25:47,360
sets of styling based on whether
the device the user is

660
00:25:47,360 --> 00:25:49,980
viewing your websites
with is capable of a

661
00:25:49,980 --> 00:25:51,230
certain kind of input.

662
00:25:51,230 --> 00:25:53,560

663
00:25:53,560 --> 00:25:55,080
Pixel supports both.

664
00:25:55,080 --> 00:25:57,280
So there is a little bit
of trickery you have to

665
00:25:57,280 --> 00:25:58,930
keep in mind here.

666
00:25:58,930 --> 00:25:59,740
PAUL KINLAN: One quick point.

667
00:25:59,740 --> 00:26:03,140
Are we actually implementing
this in Chrome?

668
00:26:03,140 --> 00:26:04,860
PETER BEVERLOO: There was an
intent to implement which we

669
00:26:04,860 --> 00:26:06,790
received from Microsoft.

670
00:26:06,790 --> 00:26:07,480
PAUL KINLAN: But that
doesn't mean we're

671
00:26:07,480 --> 00:26:09,130
implementing it just yet.

672
00:26:09,130 --> 00:26:09,860
PETER BEVERLOO: We're
implementing parts of it.

673
00:26:09,860 --> 00:26:10,260
PAUL KINLAN: Oh.

674
00:26:10,260 --> 00:26:10,660
OK.

675
00:26:10,660 --> 00:26:11,460
Cool.

676
00:26:11,460 --> 00:26:14,610
So each of our devices has
unique capabilities such as

677
00:26:14,610 --> 00:26:17,790
GPS, a location which we saw
earlier for the Geolocation

678
00:26:17,790 --> 00:26:20,940
API, and cameras, and a whole
host of other things.

679
00:26:20,940 --> 00:26:22,800
What can we take advantage
of on the web today?

680
00:26:22,800 --> 00:26:25,160
And what is pretty ubiquitous?

681
00:26:25,160 --> 00:26:27,910
Well, like two years ago, we
also spoke about this.

682
00:26:27,910 --> 00:26:29,150
And no one seems
to be using it.

683
00:26:29,150 --> 00:26:31,980
But you can actually take
pictures used from the user's

684
00:26:31,980 --> 00:26:36,150
phone using the simple input
type equals file, and put the

685
00:26:36,150 --> 00:26:38,030
capture attribute at
the top there.

686
00:26:38,030 --> 00:26:40,440
And what that essentially
indicates to the browser or

687
00:26:40,440 --> 00:26:43,500
the user agent is that you
should be able to pick whether

688
00:26:43,500 --> 00:26:45,060
you're going to take a
picture or something

689
00:26:45,060 --> 00:26:46,340
from the user's gallery.

690
00:26:46,340 --> 00:26:48,240
And I've actually set up
my Android device here.

691
00:26:48,240 --> 00:26:49,260
Like I said, I'm vain.

692
00:26:49,260 --> 00:26:51,320
So there's obviously lots
of pictures of me.

693
00:26:51,320 --> 00:26:53,790
My Android device, you have to
automatically use the camera.

694
00:26:53,790 --> 00:26:54,970
But it's really cool,
this API.

695
00:26:54,970 --> 00:26:57,010
Because it's like a
normal input type.

696
00:26:57,010 --> 00:26:59,270
If there's no support for the
camera there, it'll just let

697
00:26:59,270 --> 00:27:01,125
you pick just from
the gallery.

698
00:27:01,125 --> 00:27:04,040
Now, the really cool, cool
thing about this is that

699
00:27:04,040 --> 00:27:06,270
because it's a dom element,
there's an on change event

700
00:27:06,270 --> 00:27:09,150
which happens which allows you
to get access to the raw data

701
00:27:09,150 --> 00:27:11,380
that was delivered from the
file system into your

702
00:27:11,380 --> 00:27:11,695
application.

703
00:27:11,695 --> 00:27:14,200
And then you can manipulate it
however you want using the

704
00:27:14,200 --> 00:27:17,090
file reader and file
writer APIs.

705
00:27:17,090 --> 00:27:19,160
The logical extension to this,
and the thing that we found

706
00:27:19,160 --> 00:27:21,540
from native applications at
least anyway, is that

707
00:27:21,540 --> 00:27:23,710
developers don't really want
to have their applications,

708
00:27:23,710 --> 00:27:26,145
and users don't want them
either, to have to go out from

709
00:27:26,145 --> 00:27:28,590
one application and jump into
another application just to

710
00:27:28,590 --> 00:27:29,060
take a picture.

711
00:27:29,060 --> 00:27:32,010
They want this nice, seamless,
integrated experience.

712
00:27:32,010 --> 00:27:35,300
Well, part of the WebRTC
specification is getUserMedia.

713
00:27:35,300 --> 00:27:38,580
And getUserMedia delivers you
basically video and audio

714
00:27:38,580 --> 00:27:40,410
streams from the
user's webcam.

715
00:27:40,410 --> 00:27:42,045
Now, the really nice thing about
this is you're sitting

716
00:27:42,045 --> 00:27:43,210
there going, it's the
video stream.

717
00:27:43,210 --> 00:27:44,910
It's not really a picture.

718
00:27:44,910 --> 00:27:46,090
Well, the code's not in here.

719
00:27:46,090 --> 00:27:48,810
And it's inside the demo, but
you'll basically be able to

720
00:27:48,810 --> 00:27:52,400
take a picture from the video
stream by just attaching it to

721
00:27:52,400 --> 00:27:53,150
a canvas element.

722
00:27:53,150 --> 00:27:54,700
And you can take it
out from there.

723
00:27:54,700 --> 00:27:57,740
So you have integrated access
to the user's web cam inside

724
00:27:57,740 --> 00:28:00,810
their phone just by using
this simple API.

725
00:28:00,810 --> 00:28:02,090
It's kind of in Chrome.

726
00:28:02,090 --> 00:28:03,350
It's actually in Chrome 5.

727
00:28:03,350 --> 00:28:05,380
So hopefully it will be
enabled pretty soon.

728
00:28:05,380 --> 00:28:07,490
But it's actually supported
across Firefox and other

729
00:28:07,490 --> 00:28:08,190
browsers, as well.

730
00:28:08,190 --> 00:28:09,370
So it's getting there.

731
00:28:09,370 --> 00:28:09,780
It's pretty nice.

732
00:28:09,780 --> 00:28:12,760
You can always fall back
to the other API.

733
00:28:12,760 --> 00:28:14,390
The other one is Android
Intents.

734
00:28:14,390 --> 00:28:16,525
If you're building an
application for Android, you

735
00:28:16,525 --> 00:28:19,340
normally know the Android
Intents system pretty well.

736
00:28:19,340 --> 00:28:21,660
Now, what you normally do is
you can communicate between

737
00:28:21,660 --> 00:28:24,600
apps by asking for an action
that says, I need an app that

738
00:28:24,600 --> 00:28:25,965
supports sharing.

739
00:28:25,965 --> 00:28:27,390
And that's cool.

740
00:28:27,390 --> 00:28:29,960
Now, the common thing is we
don't really have that on the

741
00:28:29,960 --> 00:28:31,340
web anymore.

742
00:28:31,340 --> 00:28:34,460
But we have this idea of,
well, my Android device

743
00:28:34,460 --> 00:28:35,550
supports intents.

744
00:28:35,550 --> 00:28:37,190
Can I invoke an intent
from the web?

745
00:28:37,190 --> 00:28:37,870
Well, you can.

746
00:28:37,870 --> 00:28:39,820
And it's supported in
the Android browser

747
00:28:39,820 --> 00:28:40,620
and the Chrome browser.

748
00:28:40,620 --> 00:28:43,580
And it allows us to open
applications from our site.

749
00:28:43,580 --> 00:28:45,550
So if you've built a native
application, you can just

750
00:28:45,550 --> 00:28:48,930
basically encode a special
URI, which is the intent

751
00:28:48,930 --> 00:28:51,790
call-on sequence, make sure your
application supports the

752
00:28:51,790 --> 00:28:54,070
browsable category, which
basically means, my

753
00:28:54,070 --> 00:28:56,820
application's allowed to be
opened by the browser.

754
00:28:56,820 --> 00:28:59,350
And any link that has this
scheme will be able to open up

755
00:28:59,350 --> 00:29:02,660
an application directly inside
the user's machine or inside

756
00:29:02,660 --> 00:29:03,470
their device.

757
00:29:03,470 --> 00:29:05,480
The really cool thing for me on
this side of things is the

758
00:29:05,480 --> 00:29:06,780
application isn't installed.

759
00:29:06,780 --> 00:29:09,670
Because you have to include
the package name of your

760
00:29:09,670 --> 00:29:10,200
application.

761
00:29:10,200 --> 00:29:12,980
You can actually direct the
user automatically to the

762
00:29:12,980 --> 00:29:13,830
Android store.

763
00:29:13,830 --> 00:29:16,720
And that's a pretty cool, pretty
powerful API to have

764
00:29:16,720 --> 00:29:18,570
when you want to get the user
to install your native

765
00:29:18,570 --> 00:29:21,260
application as well, by the
site of your web based

766
00:29:21,260 --> 00:29:22,170
application.

767
00:29:22,170 --> 00:29:23,970
And this demo is just
the QR code app.

768
00:29:23,970 --> 00:29:25,460
It's not just a normal camera.

769
00:29:25,460 --> 00:29:27,805
It's an application that
obviously uses the camera, but

770
00:29:27,805 --> 00:29:29,670
is dedicated to taking
QR codes.

771
00:29:29,670 --> 00:29:32,080
And we've integrated with that
with just that one line of

772
00:29:32,080 --> 00:29:36,000
code inside the Android
browser in Chrome.

773
00:29:36,000 --> 00:29:38,160
Now one of the cool things about
native applications is

774
00:29:38,160 --> 00:29:40,320
that your application
like basically takes

775
00:29:40,320 --> 00:29:41,510
up the entire screen.

776
00:29:41,510 --> 00:29:42,900
You don't have this horrible,
well it's not

777
00:29:42,900 --> 00:29:45,040
horrible URL bar.

778
00:29:45,040 --> 00:29:46,260
That's the wrong thing to say.

779
00:29:46,260 --> 00:29:48,810
It's like this awkward little
URL bar for your applications,

780
00:29:48,810 --> 00:29:50,775
normally with a forward and
backwards button and a refresh

781
00:29:50,775 --> 00:29:51,950
and all this type of stuff.

782
00:29:51,950 --> 00:29:54,680
Your application or game takes
up the entire screen.

783
00:29:54,680 --> 00:29:56,140
Well, this is coming
to Chrome as well.

784
00:29:56,140 --> 00:29:58,840
But basically, we have the
actual WebKit request full

785
00:29:58,840 --> 00:30:01,920
screen API implemented in
Chrome, which allows you to

786
00:30:01,920 --> 00:30:04,320
take any DOM element and
make it full screen.

787
00:30:04,320 --> 00:30:06,470
And this demo here, I've got
the ability to take the

788
00:30:06,470 --> 00:30:08,900
document, the entire page, or a
single element, which is an

789
00:30:08,900 --> 00:30:10,520
image, and make it
full screen.

790
00:30:10,520 --> 00:30:12,560
And there's an API which
actually cancels that out.

791
00:30:12,560 --> 00:30:15,090
So you can actually back
it up pretty easy.

792
00:30:15,090 --> 00:30:16,850
The other thing you'll notice
on the Chrome browser for

793
00:30:16,850 --> 00:30:19,930
Android is that we don't
actually yet support Scroll2,

794
00:30:19,930 --> 00:30:23,030
which is an iOS idiom basically
where you can push

795
00:30:23,030 --> 00:30:24,430
the address bar out the way.

796
00:30:24,430 --> 00:30:26,560
We don't support it yet, we
will do soon in some later

797
00:30:26,560 --> 00:30:27,100
builds, at least.

798
00:30:27,100 --> 00:30:28,160
That's right, isn't it?

799
00:30:28,160 --> 00:30:30,070
Yeah, we will definitely
support it.

800
00:30:30,070 --> 00:30:31,860
Which means that if you've got
an application which tries to

801
00:30:31,860 --> 00:30:32,930
push it out the way,
it'll work.

802
00:30:32,930 --> 00:30:34,980
And you'll have the same
experience inside the Chrome

803
00:30:34,980 --> 00:30:36,230
for Android browser.

804
00:30:36,230 --> 00:30:38,850

805
00:30:38,850 --> 00:30:42,440
PETER BEVERLOO: So a biggest
mobile device is much smaller

806
00:30:42,440 --> 00:30:43,780
just in its physical size.

807
00:30:43,780 --> 00:30:47,200
And we can't put in all these
fancy GPUs and big components

808
00:30:47,200 --> 00:30:49,540
which are actually quite fast.

809
00:30:49,540 --> 00:30:51,420
There are a number
of limitations.

810
00:30:51,420 --> 00:30:53,400
Now, if you've been to the
Chrome stand upstairs, we

811
00:30:53,400 --> 00:30:56,230
categorize these limitations
in three categories.

812
00:30:56,230 --> 00:30:58,960
Firstly, computational
limitations.

813
00:30:58,960 --> 00:31:01,500
For example, in JavaScript,
execution speed.

814
00:31:01,500 --> 00:31:04,610
Rendering limitations in fast
scrolling or displaying your

815
00:31:04,610 --> 00:31:06,080
website in a quick way.

816
00:31:06,080 --> 00:31:08,380
But both of these have been
covered by a number of other

817
00:31:08,380 --> 00:31:09,930
presentations already.

818
00:31:09,930 --> 00:31:13,580
And you can definitely go back
to YouTube after Google I/O

819
00:31:13,580 --> 00:31:15,610
and watch these presentations.

820
00:31:15,610 --> 00:31:19,250
We want to look at two APIs
which are quite relevant to

821
00:31:19,250 --> 00:31:21,630
the network aspect
of limitations.

822
00:31:21,630 --> 00:31:24,620
Because the user can be on
the move at all times.

823
00:31:24,620 --> 00:31:26,150
Let's look at what happens
when a user

824
00:31:26,150 --> 00:31:27,520
navigates to a new page.

825
00:31:27,520 --> 00:31:30,010
Now, this could be because
they enter a URL in their

826
00:31:30,010 --> 00:31:30,780
address bar.

827
00:31:30,780 --> 00:31:33,880
Or this could be because
they click on a link.

828
00:31:33,880 --> 00:31:35,800
When a navigation
start, the first

829
00:31:35,800 --> 00:31:37,425
part will be the network.

830
00:31:37,425 --> 00:31:39,680
During this network phase, the
browser will have to figure

831
00:31:39,680 --> 00:31:41,640
out the DNS of your
web server.

832
00:31:41,640 --> 00:31:44,990
So it will have to change to a
domain name and an IP address.

833
00:31:44,990 --> 00:31:47,870
It will have to say hello
to the server.

834
00:31:47,870 --> 00:31:49,330
Basically, I want resources.

835
00:31:49,330 --> 00:31:50,640
Are you ready for me?

836
00:31:50,640 --> 00:31:52,200
And this takes some time.

837
00:31:52,200 --> 00:31:54,660
Now after this, it will start
loading the page.

838
00:31:54,660 --> 00:31:57,380
It will start sending messages
to the server about exactly

839
00:31:57,380 --> 00:31:59,250
which resources it wants.

840
00:31:59,250 --> 00:32:01,530
Unless of course, it finds
a redirection.

841
00:32:01,530 --> 00:32:06,470
When it does so, it restarts
the navigation based on

842
00:32:06,470 --> 00:32:09,590
exactly the URL, which is
one to redirect to.

843
00:32:09,590 --> 00:32:12,230
And that's valuable time
which is lost.

844
00:32:12,230 --> 00:32:15,450
And after it's loading and it
got the code of the research

845
00:32:15,450 --> 00:32:18,120
itself, it will start
to process the data.

846
00:32:18,120 --> 00:32:20,430
And for an HTML file, this
could, for example, means that

847
00:32:20,430 --> 00:32:22,490
it starts to build a dom.

848
00:32:22,490 --> 00:32:23,840
Now, there are a number
of things which

849
00:32:23,840 --> 00:32:25,050
could be slow here.

850
00:32:25,050 --> 00:32:27,460
And the only way to really
be sure of what

851
00:32:27,460 --> 00:32:30,180
is slow is to measure.

852
00:32:30,180 --> 00:32:33,930
So the Navigation Timing API
exposes a lot of data on all

853
00:32:33,930 --> 00:32:38,730
these items which allow you to,
with great accuracy, see

854
00:32:38,730 --> 00:32:42,860
what parts of loading the page
are taking out a lot of time.

855
00:32:42,860 --> 00:32:45,690
And this is actually reflected
in dev tools, as well.

856
00:32:45,690 --> 00:32:49,020
You can open dev tools in any
page, and it allows you to see

857
00:32:49,020 --> 00:32:52,650
the same in the Timeline
panel.

858
00:32:52,650 --> 00:32:56,220
Now, when I create a website,
it's not just a page of HTML

859
00:32:56,220 --> 00:32:58,350
which I will be delivering
to my users.

860
00:32:58,350 --> 00:32:59,200
I will have images.

861
00:32:59,200 --> 00:33:01,270
I will have style sheets.

862
00:33:01,270 --> 00:33:06,130
I'll probably have JavaScript
files as well, in some cases.

863
00:33:06,130 --> 00:33:10,865
And the resource timing API is
quite complementary to the

864
00:33:10,865 --> 00:33:14,050
Navigation Timing API, except
that it contains information

865
00:33:14,050 --> 00:33:16,805
about the timing of several
resources being load by the

866
00:33:16,805 --> 00:33:19,480
page instead of just
the page itself.

867
00:33:19,480 --> 00:33:22,390
This gets you much more high
fidelity information about

868
00:33:22,390 --> 00:33:23,770
each resource.

869
00:33:23,770 --> 00:33:27,260
And it will allow you to quickly
identify scripts or

870
00:33:27,260 --> 00:33:29,310
just allows you to file switcher
blocking the loading

871
00:33:29,310 --> 00:33:30,560
of your page.

872
00:33:30,560 --> 00:33:33,390

873
00:33:33,390 --> 00:33:34,870
PAUL KINLAN: So we've seen some
amazing pictures of my

874
00:33:34,870 --> 00:33:37,010
face throughout this entire
presentation.

875
00:33:37,010 --> 00:33:38,530
And I really do apologize
for that.

876
00:33:38,530 --> 00:33:42,020
But I want to kind of highlight
some of the newer

877
00:33:42,020 --> 00:33:43,560
features that are coming
to the web platform.

878
00:33:43,560 --> 00:33:45,770
We've seen a lot of things
which, basically we've tried

879
00:33:45,770 --> 00:33:48,900
to say that the web platform on
mobile is just as competent

880
00:33:48,900 --> 00:33:50,240
as the desktop platform.

881
00:33:50,240 --> 00:33:52,140
But there are a couple of areas
where we've been kind of

882
00:33:52,140 --> 00:33:52,940
a little bit behind.

883
00:33:52,940 --> 00:33:54,820
And we're going to show you
some of these, which are

884
00:33:54,820 --> 00:33:57,870
experiment with features that
are available inside Chrome.

885
00:33:57,870 --> 00:34:01,430
The first is obviously the
extension to getUserMedia

886
00:34:01,430 --> 00:34:03,040
called WebRTC.

887
00:34:03,040 --> 00:34:05,000
Now, a lot of people have heard
about this in the sense

888
00:34:05,000 --> 00:34:08,743
that you can take one video
stream, audio stream, and pass

889
00:34:08,743 --> 00:34:12,020
it directly to another phone or
another device or another

890
00:34:12,020 --> 00:34:14,329
desktop machine without
having to proxy it

891
00:34:14,329 --> 00:34:15,650
through your own service.

892
00:34:15,650 --> 00:34:16,100
That's cool.

893
00:34:16,100 --> 00:34:17,389
That's like the peer
connection stuff.

894
00:34:17,389 --> 00:34:19,870
That's always, well, that's been
on the desktop side of

895
00:34:19,870 --> 00:34:21,120
things for a little while.

896
00:34:21,120 --> 00:34:23,420
One area that we don't really
talk about but it's actually

897
00:34:23,420 --> 00:34:25,139
landed in Chrome and
a couple of other

898
00:34:25,139 --> 00:34:26,810
browsers is the data channel.

899
00:34:26,810 --> 00:34:29,320
And the data channel allows you
to send data directly from

900
00:34:29,320 --> 00:34:31,110
one application to another.

901
00:34:31,110 --> 00:34:33,449
And there's a talk tomorrow by
Sam Dutton which is going to

902
00:34:33,449 --> 00:34:36,030
cover a lot of this area
around WebRTC.

903
00:34:36,030 --> 00:34:37,449
We can't do it justice today.

904
00:34:37,449 --> 00:34:38,830
But it is coming.

905
00:34:38,830 --> 00:34:41,150
And you can try it inside Chrome
flags today, inside

906
00:34:41,150 --> 00:34:42,480
Chrome already.

907
00:34:42,480 --> 00:34:45,040
If you're a developer, my
recommendation is, I don't

908
00:34:45,040 --> 00:34:48,420
really like the API that much,
but WebRTC to IO and EasyRTC.

909
00:34:48,420 --> 00:34:51,219
These APIs, these abstractions
on top of it, they work really

910
00:34:51,219 --> 00:34:53,750
well, and allow you to build
these type of applications in

911
00:34:53,750 --> 00:34:55,760
just a couple of
lines of code.

912
00:34:55,760 --> 00:34:56,949
The next is Web Audio.

913
00:34:56,949 --> 00:34:58,780
Games developers have been
wanting this for ages.

914
00:34:58,780 --> 00:35:02,110
Because they want to build real
time kind of low latency

915
00:35:02,110 --> 00:35:03,950
audio into their platform.

916
00:35:03,950 --> 00:35:06,110
And I'm not going to go into too
much again because it's a

917
00:35:06,110 --> 00:35:07,790
very long and complex subject.

918
00:35:07,790 --> 00:35:10,400
But it gives you near real
time access to the audio

919
00:35:10,400 --> 00:35:12,820
streams and the audio data that
you can manipulate inside

920
00:35:12,820 --> 00:35:13,900
the JavaScript.

921
00:35:13,900 --> 00:35:16,360
And this is coming to
the mobile platform.

922
00:35:16,360 --> 00:35:17,940
Right now, it's only
available on--

923
00:35:17,940 --> 00:35:20,410
I need to get this right-- on
devices supporting the neon

924
00:35:20,410 --> 00:35:23,160
chipset, which just kind of
luckily happens to be a large

925
00:35:23,160 --> 00:35:25,010
number of devices
at the moment.

926
00:35:25,010 --> 00:35:26,730
And that's one of the reasons
why we're still keeping it

927
00:35:26,730 --> 00:35:28,420
behind the flags as well,
because it's not broadly

928
00:35:28,420 --> 00:35:29,400
available just yet.

929
00:35:29,400 --> 00:35:31,570
And it still needs some
time to bake.

930
00:35:31,570 --> 00:35:32,420
And WebGL.

931
00:35:32,420 --> 00:35:34,450
This is a demo by the guys
that play Canvas.

932
00:35:34,450 --> 00:35:36,770
They built it in about
a day or so.

933
00:35:36,770 --> 00:35:39,060
But essentially, there's WebGL
support inside Opera, I

934
00:35:39,060 --> 00:35:42,280
believe, and Firefox, which
allows you to build these 3D

935
00:35:42,280 --> 00:35:44,730
rich interactive games.

936
00:35:44,730 --> 00:35:48,140
And if you combine that with
WebRTC and Web Audio, you can

937
00:35:48,140 --> 00:35:51,400
build these really kind of
cool collaborative games.

938
00:35:51,400 --> 00:35:54,090
You name it, you can build
it, and it'd be cool.

939
00:35:54,090 --> 00:35:57,760
So we are nearly finished
now, aren't we?

940
00:35:57,760 --> 00:35:58,330
Pretty cool.

941
00:35:58,330 --> 00:35:59,600
We're running close on time.

942
00:35:59,600 --> 00:36:00,800
I want to ask one question.

943
00:36:00,800 --> 00:36:01,800
Do you want to ask it?

944
00:36:01,800 --> 00:36:04,170
PETER BEVERLOO: So is the
mobile web awesome yet?

945
00:36:04,170 --> 00:36:06,620
PAUL KINLAN: Is it awesome?

946
00:36:06,620 --> 00:36:08,055
Who said no?

947
00:36:08,055 --> 00:36:09,550
Oh.

948
00:36:09,550 --> 00:36:12,060
This is supposed to be a rally
call to yes, it is.

949
00:36:12,060 --> 00:36:13,990
So we can?

950
00:36:13,990 --> 00:36:16,780

951
00:36:16,780 --> 00:36:18,990
PETER BEVERLOO: We can adapt to
the various screen sizes of

952
00:36:18,990 --> 00:36:20,130
mobile devices.

953
00:36:20,130 --> 00:36:22,820
We know that screen sizes of
mobile devices are smaller.

954
00:36:22,820 --> 00:36:24,180
They have limitations.

955
00:36:24,180 --> 00:36:26,310
But there's plenty of features
available for us to

956
00:36:26,310 --> 00:36:29,170
restructure content based on
that, or to work around these

957
00:36:29,170 --> 00:36:33,190
constraints to bring a proper
user experience to your users.

958
00:36:33,190 --> 00:36:34,160
PAUL KINLAN: We can accommodate
users on the

959
00:36:34,160 --> 00:36:37,570
move-- the Geolocation API,
the offline access APIs.

960
00:36:37,570 --> 00:36:40,700
We can build applications that
are responsive to users being

961
00:36:40,700 --> 00:36:42,410
on the move.

962
00:36:42,410 --> 00:36:44,690
PETER BEVERLOO: We can
speed up inputs.

963
00:36:44,690 --> 00:36:47,060
It's awkward, but we can
make it as easy for

964
00:36:47,060 --> 00:36:50,510
the user as is possible.

965
00:36:50,510 --> 00:36:51,060
PAUL KINLAN: And we
can integrate with

966
00:36:51,060 --> 00:36:52,080
all the device features.

967
00:36:52,080 --> 00:36:53,420
You have access to the camera.

968
00:36:53,420 --> 00:36:57,180
You have access to GPS and a
whole lot of other features on

969
00:36:57,180 --> 00:36:58,350
the mobile web today that are

970
00:36:58,350 --> 00:37:00,970
ubiquitous across the platform.

971
00:37:00,970 --> 00:37:02,650
PETER BEVERLOO: We can measure
exactly where in our

972
00:37:02,650 --> 00:37:04,390
applications the pain
points are.

973
00:37:04,390 --> 00:37:07,000
Now, I know that we just
looked at some network

974
00:37:07,000 --> 00:37:09,250
specifications related
to the network.

975
00:37:09,250 --> 00:37:11,350
But there's a lot we can
do to actually figure

976
00:37:11,350 --> 00:37:13,070
out why it's slow.

977
00:37:13,070 --> 00:37:14,730
PAUL KINLAN: And we can look
forward to WebRTC,

978
00:37:14,730 --> 00:37:16,330
Web Audio, and WebGL.

979
00:37:16,330 --> 00:37:19,340
So I think in summary, we
believe that web on the mobile

980
00:37:19,340 --> 00:37:21,460
web is absolutely awesome.

981
00:37:21,460 --> 00:37:22,280
Thank you very much.

982
00:37:22,280 --> 00:37:23,530
PETER BEVERLOO: Thank you.

983
00:37:23,530 --> 00:37:28,860

984
00:37:28,860 --> 00:37:30,700
PAUL KINLAN: I'm going
to say, we do have

985
00:37:30,700 --> 00:37:31,570
three minutes for questions.

986
00:37:31,570 --> 00:37:34,880
It's probably best if we take
them off stage or outside.

987
00:37:34,880 --> 00:37:36,840
Me and Peter will be
available for any

988
00:37:36,840 --> 00:37:38,410
questions that you do have.

989
00:37:38,410 --> 00:37:39,660
Thank you.

990
00:37:39,660 --> 00:37:40,602

