1
00:00:02,340 --> 00:00:02,610
>>Boris Smus: Hi, folks.
>>> Hey!

2
00:00:02,610 --> 00:00:06,380
>>Boris Smus: All right. Welcome to Point,
Click, Tap, Touch, a session about building

3
00:00:06,380 --> 00:00:13,030
multi-device web interfaces. My name is Boris,
and I'm a research engineer working on user

4
00:00:13,030 --> 00:00:18,150
interfaces in the Google research group.
>>Rick Byers: And I'm Rick. I work on touchscreen

5
00:00:18,150 --> 00:00:22,230
support in Chrome and I'm a member of the
W3C standards groups working on standardizing

6
00:00:22,230 --> 00:00:25,500
touchscreen support on the web.
>>Boris Smus: So today's talk is mostly going

7
00:00:25,500 --> 00:00:31,650
to be about input and we'll talk a bit about
mouse space input but the bulk of it is going

8
00:00:31,650 --> 00:00:36,280
to be about touchscreens.
So just to motivate that, I'm sure you've

9
00:00:36,280 --> 00:00:42,250
all got a touchscreen device, or maybe two,
or maybe three, now that you've got Pixels,

10
00:00:42,250 --> 00:00:46,879
and so touch is becoming even more ubiquitous
than it was a year ago.

11
00:00:46,879 --> 00:00:52,129
Mobile touch -- mobile use in general is projected
to overtake the desktop sometime early next

12
00:00:52,129 --> 00:00:58,010
year, and the revenue forecast of touchscreen
modules only corroborate that. You can see

13
00:00:58,010 --> 00:01:04,079
it's a very up-and-to-the-right kind of graph.
Also we've got this new -- relatively new

14
00:01:04,079 --> 00:01:10,340
form factor of touch laptops, of which the
Pixel is one, and also Windows -- Windows

15
00:01:10,340 --> 00:01:15,049
machines are becoming increasingly touch-enabled.
Something like a quarter of Windows 8 laptop

16
00:01:15,049 --> 00:01:22,049
sales have a touchscreen. So if you're a developer
working on the web, you should expect your

17
00:01:22,369 --> 00:01:28,679
users to have a touchscreen device increasingly.
And the good thing here is that the web has

18
00:01:28,679 --> 00:01:33,590
a very powerful touch event API and it's been
around for something like five, six years

19
00:01:33,590 --> 00:01:38,770
and has become standard over the last two
years or so, and the basics of this API is

20
00:01:38,770 --> 00:01:43,429
we've got a touchstart event which fires when
your finger hits the screen, touchmove continually

21
00:01:43,429 --> 00:01:48,319
fires as you're moving around, touchend and
touchcancel are two different ways of ending

22
00:01:48,319 --> 00:01:51,299
that interaction.
So touchend is the natural thing that happens

23
00:01:51,299 --> 00:01:56,579
when your finger is raised and touchcancel
happens if your finger was -- if your touch

24
00:01:56,579 --> 00:02:00,649
gesture was cancelled for some other reason.
On Android, for example, if you start scrolling

25
00:02:00,649 --> 00:02:07,649
an area, touchcancel will fire as the browser
begins to scroll.

26
00:02:08,709 --> 00:02:15,489
So to distinguish between these multiple touches,
each one has a consistent identifier, and

27
00:02:15,489 --> 00:02:21,769
this API that I'm describing works really
well across a number of devices. Basically

28
00:02:21,769 --> 00:02:27,239
across the whole modern mobile browser landscape.
So let me quickly show you how this looks.

29
00:02:27,239 --> 00:02:32,840
On a Pixel, which is what I'm demoing from,
I've got this paint application. You can see

30
00:02:32,840 --> 00:02:39,129
that as soon as I lower my fingers, I can
do this amazing finger-painting exercise.

31
00:02:39,129 --> 00:02:46,069
And we support up to 10 points and you can
see each finger has a unique color which is

32
00:02:46,069 --> 00:02:52,120
because they have unique IDs.
Now, if I didn't have a touchscreen, I could

33
00:02:52,120 --> 00:02:58,049
emulate this behavior with just a mouse, and
you can see I can override this by turning

34
00:02:58,049 --> 00:03:05,049
on emulate touch events in the Chrome developer
tools, and when I do that, I get this little

35
00:03:05,430 --> 00:03:08,299
finger-like thing on the screen every time
I move the mouse.

36
00:03:08,299 --> 00:03:13,510
And it's just a good reminder that says, "Hey,
there's a certain size to your finger," that

37
00:03:13,510 --> 00:03:16,739
it's not as precise as your mouse. And I'll
talk more about that.

38
00:03:16,739 --> 00:03:23,739
Now, of course because this is a standard
API, it works just as well across a variety

39
00:03:24,840 --> 00:03:31,840
of devices, so here I've got the same exact
code running on a phone, and you can see that

40
00:03:32,180 --> 00:03:39,180
the behavior of this application is the same.
Okay. So I'll run through a couple of design

41
00:03:43,569 --> 00:03:49,150
suggestions, because designing for touch is
quite different from designing for mouse and

42
00:03:49,150 --> 00:03:55,790
keyboard.
So the first tip here is obviously touch interfaces

43
00:03:55,790 --> 00:04:02,389
require bigger targets. Your finger is inherently
far less precise than a mouse, which can give

44
00:04:02,389 --> 00:04:06,599
you one- or two-pixel precision, but exactly
how big?

45
00:04:06,599 --> 00:04:10,799
So extensive research has been done to suggest
that 9-by-9 millimeters is something like

46
00:04:10,799 --> 00:04:17,799
the optimal touch target size, but the web
has a few things that complicate matters.

47
00:04:18,079 --> 00:04:25,039
First, we've got a whole variety of devices
to support, and they vary hugely in their

48
00:04:25,039 --> 00:04:31,160
device density, so DPI varies, and therefore
it's hard to map physical size to device pixels.

49
00:04:31,160 --> 00:04:36,479
And secondly, the web has this concept of
CSS pixels not necessarily being the same

50
00:04:36,479 --> 00:04:41,530
as device pixels because they're modified
by something called device Pixel ratio.

51
00:04:41,530 --> 00:04:47,080
So with these two things in mind, we can do
some calculations for a variety of popular

52
00:04:47,080 --> 00:04:50,310
devices.
Here we've got the Nexus line where we convert

53
00:04:50,310 --> 00:04:55,400
9 millimeters into pixels and we can see what
that looks like on these devices.

54
00:04:55,400 --> 00:05:02,310
On the Chromebook Pixel, it's something -- because
of further distance of interaction, you end

55
00:05:02,310 --> 00:05:09,310
up with screwy -- with a slightly bigger -- with
fewer pixels required to represent the same

56
00:05:12,610 --> 00:05:16,539
physical size.
So while we don't have like a clear guideline

57
00:05:16,539 --> 00:05:21,569
in this case of what size you should use,
something between 42 and 58 pixels is our

58
00:05:21,569 --> 00:05:28,150
recommendation.
And this is fairly consistent with other guidelines.

59
00:05:28,150 --> 00:05:33,490
Second tip is related to hover. So hover we
can activate in two ways, generally with a

60
00:05:33,490 --> 00:05:39,699
mouse-based interface, so with CSS, using
the colon hover pseudo-selector and with JavaScript

61
00:05:39,699 --> 00:05:45,000
using mouseover and mouseout events.
With touchscreens, generally, with some exceptions

62
00:05:45,000 --> 00:05:52,000
like the Samsung S4 which has above-surface
hover, basically we don't have access to hover

63
00:05:52,190 --> 00:05:57,569
state. And even in the case of the S4, that
hover state is only in hardware and available

64
00:05:57,569 --> 00:06:04,569
in Android. It's not exposed to the web yet.
So what do we do in the case of -- in the

65
00:06:05,150 --> 00:06:12,030
case of touch for hover?
Basically, here's an example of a hover test

66
00:06:12,030 --> 00:06:16,599
page. We've got two hover areas. One of them
has a link, the other does not. And I can

67
00:06:16,599 --> 00:06:21,759
just activate hover by -- by tapping.
So a single tap activates hover on mobile

68
00:06:21,759 --> 00:06:26,740
devices with touchscreens.
The problem is if you have a hover and a link

69
00:06:26,740 --> 00:06:31,210
underlying that.
So in this case, if I click this area that

70
00:06:31,210 --> 00:06:36,120
has a link, the hover state was triggered
but for so brief a time that the user didn't

71
00:06:36,120 --> 00:06:40,750
actually get to see it. So this happens a
lot when you have menus, hierarchical menus

72
00:06:40,750 --> 00:06:46,599
that are activated on hover, and it's something
to definitely avoid.

73
00:06:46,599 --> 00:06:53,599
Okay. The last designing kind of thing that
I want to talk about is the touch laptop form

74
00:06:54,599 --> 00:06:59,289
factor and the kind of untapped potential
that this form factor can bring.

75
00:06:59,289 --> 00:07:04,539
So there's two sort of axes here.
First, we can think about switching between

76
00:07:04,539 --> 00:07:11,020
these two modalities of touch and not touch,
and it might look something like this.

77
00:07:11,020 --> 00:07:18,020
So here's a gallery of photos. In this case,
I've got photos of celebrities. You can see

78
00:07:22,220 --> 00:07:29,220
it's a very standard kind of interface and
I can pick new pictures with my mouse. It's

79
00:07:29,889 --> 00:07:33,599
great.
So what happens if I want to use a touch device,

80
00:07:33,599 --> 00:07:38,000
or my touchscreen in this case?
This is way too small for me to tap.

81
00:07:38,000 --> 00:07:43,479
So you can see if -- as soon as I tap this
-- this page, I get this responsive input

82
00:07:43,479 --> 00:07:50,289
effect and now everything is far more tappable.
So when I switch back to mouse, the page readjusts

83
00:07:50,289 --> 00:07:52,879
back.
So this is an interesting concept that you

84
00:07:52,879 --> 00:07:59,879
might want to explore.
Another possibility is to use both modes together.

85
00:08:00,689 --> 00:08:06,340
So in this page, I have a map that I have
pointer-locked so whenever I pan around with

86
00:08:06,340 --> 00:08:13,340
my trackpad or pinch zoom -- or sorry, two-finger
scroll, I can navigate the map. And I can

87
00:08:14,310 --> 00:08:19,250
also place waypoints on this map using my
touchscreen. So it's sort of an interesting

88
00:08:19,250 --> 00:08:24,189
interaction using both -- both touch surfaces
simultaneously.

89
00:08:24,189 --> 00:08:29,830
And along the same veins, in this example
I have a small green rectangle that I can

90
00:08:29,830 --> 00:08:36,520
move around as you'd expect, but I can also
simultaneously move my trackpad to rotate

91
00:08:36,520 --> 00:08:41,010
it and with two fingers I'll create a scaling
effect.

92
00:08:41,010 --> 00:08:44,410
And I can do these things simultaneously.
So it's kind of an interesting interaction

93
00:08:44,410 --> 00:08:50,820
that's only possible with these two touch
surfaces simultaneously.

94
00:08:50,820 --> 00:08:56,780
So with that, I'll hand over to Rick to talk
about some common problems and their solutions.

95
00:08:56,780 --> 00:09:01,290
>>Rick Byers: So in getting the Pixel ready
to ship, we worked with a lot of different

96
00:09:01,290 --> 00:09:05,160
web properties to help them make their Web
sites that were designed for desktop work

97
00:09:05,160 --> 00:09:07,360
better with touch.
So what I want to go through here is some

98
00:09:07,360 --> 00:09:10,800
of the common issues that we came across that
people hit regularly.

99
00:09:10,800 --> 00:09:16,460
The first one is this code. Does anyone realize
off the bat what the problem is with this

100
00:09:16,460 --> 00:09:19,140
code?
>> (Speaker is off microphone.)

101
00:09:19,140 --> 00:09:23,330
>>Rick Byers: Right. If you use it on a Pixel,
you can't use the trackpad. And really this

102
00:09:23,330 --> 00:09:27,840
isn't about the Pixel. This code was -- you
know, the assumption here is if I've got touch

103
00:09:27,840 --> 00:09:32,630
support, like in particular the touch event
APIs are supported on this browser, then I

104
00:09:32,630 --> 00:09:35,660
must be on a mobile device and I shouldn't
listen to mouse events. And this was actually

105
00:09:35,660 --> 00:09:39,810
never correct. BlackBerry devices have a little
trackball that sends mouse events, so this

106
00:09:39,810 --> 00:09:44,210
would also disable that. But this is really
bad for touchscreen laptops. It means someone's

107
00:09:44,210 --> 00:09:47,600
got their laptop and they upgrade to their
spiffy new touchscreen laptop and now a site

108
00:09:47,600 --> 00:09:52,080
that they're used to using with their trackpad
no longer works with the trackpad. Just because

109
00:09:52,080 --> 00:09:55,190
someone has a touchscreen on their laptop
doesn't mean they're going to use it all the

110
00:09:55,190 --> 00:10:00,080
time. In fact, a lot of users only use it
for special circumstances, like maps and whatnot,

111
00:10:00,080 --> 00:10:02,880
and it really varies how much people use their
touchscreen on their laptop.

112
00:10:02,880 --> 00:10:07,490
So you really don't want to disable mouse
support just because there's touch support.

113
00:10:07,490 --> 00:10:11,320
Let me show you an example of that.
Not to pick on any particular site in particular,

114
00:10:11,320 --> 00:10:15,790
but this page, this site, just to show you
how frustrating it is, I move my mouse over

115
00:10:15,790 --> 00:10:20,320
these buttons and clearly I should be able
to click on these, but when I click, nothing

116
00:10:20,320 --> 00:10:23,370
happens, and it's really frustrating and you
say, "Why the heck can't I click on this?"

117
00:10:23,370 --> 00:10:28,300
Until you realize, "Oh, actually, I can tap
with touch."

118
00:10:28,300 --> 00:10:35,100
And that's just because they've stopped listening
to the click event because it detects a touchscreen.

119
00:10:35,100 --> 00:10:38,190
So don't do that.
So how do you -- what do you do instead?

120
00:10:38,190 --> 00:10:41,710
So when you limit, don't try to predict whether
or not the user is going to do touch. In the

121
00:10:41,710 --> 00:10:45,410
limit, you can't predict it. For example,
they might have a USB touchscreen that's connected

122
00:10:45,410 --> 00:10:49,870
to a KVM switch, so it might come and go during
the lifetime of the page, so you can't predict

123
00:10:49,870 --> 00:10:52,830
whether or not the user's going to use touch.
Instead, what you should do is always listen

124
00:10:52,830 --> 00:10:56,920
for touch events and mouse events and then
you can decide dynamically, when you see a

125
00:10:56,920 --> 00:10:59,840
touch event get used, then you know the user
is using touch.

126
00:10:59,840 --> 00:11:04,330
So in this case, we listened for both all
the time, and I think the main reason people

127
00:11:04,330 --> 00:11:08,940
don't do this is for compatibility, touch
events by default, if I tap the screen, it

128
00:11:08,940 --> 00:11:13,640
will send a series of mouse events to emulate
a mouse click, so all these Web sites that

129
00:11:13,640 --> 00:11:17,380
were designed just for mouse will still work
by tapping the touchscreen.

130
00:11:17,380 --> 00:11:21,050
And so I think the reason people stop listening
for mouse events is they want to avoid hitting

131
00:11:21,050 --> 00:11:25,530
that redundant click event, but the right
way to do that is when you've consumed a touch

132
00:11:25,530 --> 00:11:30,010
event is to call preventDefault on the event.
PreventDefault tells the browser "I've handled

133
00:11:30,010 --> 00:11:33,340
this, please don't do something else with
it." And this is generally what you want to

134
00:11:33,340 --> 00:11:37,040
do anyway in most scenarios.
You know, if you're using touch to manipulate

135
00:11:37,040 --> 00:11:40,780
an object, you don't want the browser to also
use that touch to pan the page, scroll the

136
00:11:40,780 --> 00:11:44,840
page, for example.
So let me show you concretely what that looks

137
00:11:44,840 --> 00:11:48,090
like.
This is a really simple application that just

138
00:11:48,090 --> 00:11:52,340
registers an event handler on this blue box
here, so you can see if I move my mouse over,

139
00:11:52,340 --> 00:11:59,080
it just lists the events that are fired.
So if I touch and drag, I get touchstart,

140
00:11:59,080 --> 00:12:03,620
touchmove, and then -- oops -- if I touch
and drag, you can see I get touchmove and

141
00:12:03,620 --> 00:12:09,690
then touchend.
But if I tap on this, you see I get touchstart,

142
00:12:09,690 --> 00:12:13,380
touchend, as you'd expect, but then I also
get this compatibility mouse move -- mousedown,

143
00:12:13,380 --> 00:12:16,180
mouseout click -- sequence that's emulated
in the click.

144
00:12:16,180 --> 00:12:21,500
So to prevent that, I just go into my event
handler here and say ease out preventDefault,

145
00:12:21,500 --> 00:12:24,890
just say "I've handled the event, please don't
do anything else with it." And now when I

146
00:12:24,890 --> 00:12:31,890
tap I just get the touch events.
So if you leave here knowing -- remembering

147
00:12:32,110 --> 00:12:36,760
nothing else, this is the most important thing:
Don't make your users suffer just because

148
00:12:36,760 --> 00:12:40,380
they happen to have a touchscreen.
And now that you all have Pixels, this will

149
00:12:40,380 --> 00:12:41,940
probably become pretty obvious to you. Try
it at your sites.

150
00:12:41,940 --> 00:12:45,290
Now, you don't have to have a Pixel to test
this out. So those of you watching the extended

151
00:12:45,290 --> 00:12:51,140
or on YouTube that weren't as lucky to get
a Pixel yet, just go to Chrome flags and turn

152
00:12:51,140 --> 00:12:54,290
on enable touch events.
We'd actually like to -- we'd actually like

153
00:12:54,290 --> 00:12:58,010
Chrome to always support touch events and
the only reason we don't today is because

154
00:12:58,010 --> 00:13:01,490
so many Web sites have this bug, but hopefully
at some point in the future we'll make this

155
00:13:01,490 --> 00:13:04,430
the default mode. So you should turn this
on and test your Web sites to make sure the

156
00:13:04,430 --> 00:13:08,890
mouse still works on your Web sites with this
on.

157
00:13:08,890 --> 00:13:15,890
Another problem we see a lot is there's a
subtle difference in how the events are targeted,

158
00:13:17,200 --> 00:13:21,550
so a lot of people will often in many scenarios
want to delegate to the same code for touch

159
00:13:21,550 --> 00:13:26,000
and mouse, and there's a difference between
the mouse event model and the touch event

160
00:13:26,000 --> 00:13:31,260
model in where the events go. So as you probably
know, with the mouse if I move my mouse cursor

161
00:13:31,260 --> 00:13:36,090
over like this blue rectangle here and press
down and then drag outside the rectangle,

162
00:13:36,090 --> 00:13:41,320
I'll get a mousedown, some mouse moves, and
a mouseout event targeted at the rectangle,

163
00:13:41,320 --> 00:13:44,950
and then -- and then I'll continue receiving
events on whatever the background element

164
00:13:44,950 --> 00:13:47,910
is, the white element in this case. It will
get the mouseover, mousemoves, and mouseup

165
00:13:47,910 --> 00:13:52,990
when I lift.
This isn't the same for touch. For touch,

166
00:13:52,990 --> 00:13:56,640
the events always target the node where the
touch started, as opposed to the node that's

167
00:13:56,640 --> 00:14:01,000
currently under the cursor as for mouse.
So for touch, if I touch on this blue rectangle

168
00:14:01,000 --> 00:14:05,180
and drag across and lift, the touch old events
are going to go to the rectangle, including

169
00:14:05,180 --> 00:14:09,220
the end. And this make a lot of sense for
common scenarios. I've got a slider that I'm

170
00:14:09,220 --> 00:14:12,690
manipulating with touch. You'd really rather
not have to worry about what happens if the

171
00:14:12,690 --> 00:14:16,190
user's finger falls off the slider slightly
as they're sliding it. It make sense to say

172
00:14:16,190 --> 00:14:19,380
conceptually when the user starts touching
something, they're manipulating that thing

173
00:14:19,380 --> 00:14:23,510
for the duration of their touch. But this
gets tricky if you think about what if -- what

174
00:14:23,510 --> 00:14:28,130
if you have got a container with some elements
inside of it and it's changing over time.

175
00:14:28,130 --> 00:14:33,800
In particular, what if the element the user
touched on happens to get deleted while the

176
00:14:33,800 --> 00:14:38,630
user's in the middle of their touch. And this
actually happened to me in some code I was

177
00:14:38,630 --> 00:14:42,450
working on, and I was really surprised. I
didn't know what was going on.

178
00:14:42,450 --> 00:14:46,240
What happens is we followed this model. The
events continue to go to the element where

179
00:14:46,240 --> 00:14:49,250
you started touching. Even if that element
is no longer in the DOM, that's where the

180
00:14:49,250 --> 00:14:51,880
events go. They'll bubble up to the point
that there's no ancestor and they'll fall

181
00:14:51,880 --> 00:14:55,910
on the floor. So if you've got an event handler
on the container, you're not going to get

182
00:14:55,910 --> 00:15:01,890
the events once the inner node is removed,
and that will look to your app like a finger

183
00:15:01,890 --> 00:15:08,680
is just stuck down. I've got a demo of that,
so this is a really simple app that just transforms

184
00:15:08,680 --> 00:15:13,860
this rectangle to match with my touch events.
And this is -- this works fine because it's

185
00:15:13,860 --> 00:15:18,320
just a simple rectangle. But, you know, if
this was a ticker or something with some changing

186
00:15:18,320 --> 00:15:22,230
content inside of it or a list of email or
something, then it would be more complicated.

187
00:15:22,230 --> 00:15:27,260
So I'm going to simulate that by just adding
this red div every two seconds and then deleting

188
00:15:27,260 --> 00:15:30,540
it and then adding a new one.
So if I happen to start touching on the red

189
00:15:30,540 --> 00:15:36,010
div and drag around, as soon as the red div's
removed from the DOM, it's what's receiving

190
00:15:36,010 --> 00:15:40,100
the events and so the container doesn't know
about the events anymore and it thinks my

191
00:15:40,100 --> 00:15:44,710
finger is stuck down and now my code gets
confused. If I try to touch it again, it's

192
00:15:44,710 --> 00:15:48,140
confused because it missed the end. It never
got an end. You see I got touchstart and I

193
00:15:48,140 --> 00:15:51,180
got another touchstart, which is really confusing
for the code.

194
00:15:51,180 --> 00:15:55,640
So to fix that, an easy way to fix it is to
just take my event handlers here, my move,

195
00:15:55,640 --> 00:16:00,110
end, and cancel event handlers. Really I don't
want those on the container. In this case,

196
00:16:00,110 --> 00:16:05,060
I want to take them -- instead of putting
them on the container, I can go up here to

197
00:16:05,060 --> 00:16:10,950
my touchstart handler and I'll put the event
handlers instead on whatever the target of

198
00:16:10,950 --> 00:16:15,380
the touchstart was.
So in this case, it's going to be -- if I

199
00:16:15,380 --> 00:16:17,560
started touching on the red element, it's
going to be on the red element.

200
00:16:17,560 --> 00:16:21,870
Now, in theory you might also want to go and
remove these event handlers and the end event

201
00:16:21,870 --> 00:16:25,000
but actually it's not necessary because adding
the same event handler more than once is a

202
00:16:25,000 --> 00:16:28,380
"no op." So there's no disadvantage here to
just adding them and leaving them there. So

203
00:16:28,380 --> 00:16:32,470
now you can see if I start touching this red
guy, now it's removed from the DOM. It doesn't

204
00:16:32,470 --> 00:16:37,060
really exist anywhere except it's being kept
alive by the events that are being sent to

205
00:16:37,060 --> 00:16:40,980
it, and so the JavaScript code can still be
fired and see those events even though the

206
00:16:40,980 --> 00:16:47,980
node is not reachable in the DOM anywhere.
So that's how to fix that one.

207
00:16:50,730 --> 00:16:55,470
Just like that.
Another common problem is dealing with small

208
00:16:55,470 --> 00:16:59,760
targets. Lots of the web is designed for a
mouse today, so the browser's got to do something

209
00:16:59,760 --> 00:17:03,070
to make it easier for touchscreen users to
hit small things.

210
00:17:03,070 --> 00:17:07,220
If we just relied on looking at the center
point of your finger, it would be way too

211
00:17:07,220 --> 00:17:12,000
small. As Boris said, you know, you ideally
have larger targets. But if it's a site that's

212
00:17:12,000 --> 00:17:15,909
designed for a mouse or if you want to try
to strike some compromise on your site where

213
00:17:15,909 --> 00:17:19,459
you don't want things to be giant, then the
browser's got to do something to make it easier

214
00:17:19,459 --> 00:17:23,980
for people to touch large -- touch small targets.
So what Chrome does, it's got a feature called

215
00:17:23,980 --> 00:17:28,830
touch adjustment, and what it does, the green
rectangle here represents the bounding box

216
00:17:28,830 --> 00:17:33,049
of my touch. You know, using the radius from
the hardware on Pixel, we know the radius

217
00:17:33,049 --> 00:17:37,500
of the touch, but if we don't know the radius
on other hardware, we can use a suitable default.

218
00:17:37,500 --> 00:17:41,600
And then we look at all of the elements inside
that bounding box and we look at -- we'd find

219
00:17:41,600 --> 00:17:46,720
every one that has some signal that it's activatable
by tapping somehow. So it's got a click event

220
00:17:46,720 --> 00:17:51,600
handler or it's got an active CSS pseudo-class.
Anything that we expect something will happen

221
00:17:51,600 --> 00:17:58,100
when it's tapped. And we score those based
on how far away the edge of that element is

222
00:17:58,100 --> 00:18:02,789
from the center of the touch and how much
of that element gets overlapped by the touch.

223
00:18:02,789 --> 00:18:06,909
And we pick the one with the highest score
and then we adjust the touch. We don't change

224
00:18:06,909 --> 00:18:10,850
the raw touch events. Touch events are a low-level
API. We don't want to muck with those. But

225
00:18:10,850 --> 00:18:14,740
for the compatibility of most events, we'll
shift them. We'll change what element is targeted

226
00:18:14,740 --> 00:18:19,379
and we'll change the coordinates so that it
actually gets delivered to what we think the

227
00:18:19,379 --> 00:18:23,149
user is trying to touch. Let me show you that
in a demo.

228
00:18:23,149 --> 00:18:27,590
Oh, pro tip, by the way, for all of you with
your new Pixels. Control shift plus. We haven't

229
00:18:27,590 --> 00:18:31,779
put in the UI yet but we have a nice UI restore
feature. You can zoom in and out the whole

230
00:18:31,779 --> 00:18:37,210
Chrome OS UI. So I'm going to do that for
this demo and show you -- well, let me just

231
00:18:37,210 --> 00:18:41,059
show -- if I just tap here, I've got the rectangle
showing where my tap was, and the blue shows

232
00:18:41,059 --> 00:18:46,039
where the click event went, and in this case,
there's nothing touchable underneath so there's

233
00:18:46,039 --> 00:18:51,029
nothing unusual here.
And if I tap on top of a link, again, there's

234
00:18:51,029 --> 00:18:53,759
nothing really unusual.
But if I tap on the boundary of a link like

235
00:18:53,759 --> 00:18:59,580
this, you can see my touchend event, which
is the red dot, occurred on the "x" and "t"

236
00:18:59,580 --> 00:19:03,570
in the word "text" here and down in the log
you can see the touchend event occurred on

237
00:19:03,570 --> 00:19:07,720
this ID called "content," which is the text
content.

238
00:19:07,720 --> 00:19:12,350
But I overlapped the link and so the browser
sees that overlap and it adjusts the click

239
00:19:12,350 --> 00:19:15,820
event, so that the click is actually going
to the link, which is the blue dot next to

240
00:19:15,820 --> 00:19:18,990
it. And there's also two different signals
that we use so, you know, the link is the

241
00:19:18,990 --> 00:19:23,690
obvious one but anything with a hover effect,
like right here, this text turns red when

242
00:19:23,690 --> 00:19:27,940
you hover on top of it, so you can see I'm
adjusting down towards it.

243
00:19:27,940 --> 00:19:32,409
Or something with a tab index, right? A tab
index indicates that you can focus it by tapping

244
00:19:32,409 --> 00:19:36,529
-- by clicking on it or activating it. Or
even just a mousedown event handler because

245
00:19:36,529 --> 00:19:40,889
we fired those on tap as well. These are all
signals to tell us that something is touchable.

246
00:19:40,889 --> 00:19:46,279
And so this works great most of the time,
but it is possible to confuse it.

247
00:19:46,279 --> 00:19:50,669
In particular, we need some signal that -- that
what you've got is designed to be activated

248
00:19:50,669 --> 00:19:56,269
somehow, and if you're relying on event delegation,
so for example, you've got an event handler

249
00:19:56,269 --> 00:20:01,049
on your entire document and then in JavaScript
you're deciding, oh, this event actually really

250
00:20:01,049 --> 00:20:05,450
was on this element and I'm imperatively in
JavaScript going to rewrite the event to the

251
00:20:05,450 --> 00:20:10,970
right element, that gives the browsers no
real signal of -- of where -- what is touchable

252
00:20:10,970 --> 00:20:15,559
and what isn't.
Not only is that going to disable touch adjustment,

253
00:20:15,559 --> 00:20:19,740
but if there's other signals like hover effect
and active effects, it might actually make

254
00:20:19,740 --> 00:20:22,610
touch adjustment behave worse than not having
it at all.

255
00:20:22,610 --> 00:20:26,519
My favorite example of this is Gmail, unfortunately.
And we will get this fixed at some point soon.

256
00:20:26,519 --> 00:20:32,490
Oops. Let me go back here.
So I can tap these stars and activate them,

257
00:20:32,490 --> 00:20:37,929
no problem. And that's because the star in
its unactive state has a hover effect that

258
00:20:37,929 --> 00:20:42,299
makes it look slightly different when you
hover over it. So it looks tappable to us.

259
00:20:42,299 --> 00:20:45,929
Every time I touch near it, it will adjust
towards it. If I try to tap to turn off the

260
00:20:45,929 --> 00:20:50,620
star, it is incredibly frustrating. I just
keep hitting the things next to it. That's

261
00:20:50,620 --> 00:20:54,080
because these other things on either side
of it appear to us to be tappable, but there

262
00:20:54,080 --> 00:20:58,360
is no longer any signal on the star telling
us that it is tappable.

263
00:20:58,360 --> 00:21:01,259
Gmail is using event delegations, so there
is no event handler on it and there is no

264
00:21:01,259 --> 00:21:05,590
longer a hover effect or anything to tell
us it is random background content.

265
00:21:05,590 --> 00:21:12,590
And so we don't think it is something the
user is trying to touch.

266
00:21:13,720 --> 00:21:17,149
Another question I get a lot is how should
you recognize more complex gestures like pinch

267
00:21:17,149 --> 00:21:23,850
or rotate. Mobile Safari has a proprietary
API for this called gestureevent. And IE10

268
00:21:23,850 --> 00:21:30,850
has a proprietary API for this called MSGestureevent.
So in Chrome, we are not going to add another

269
00:21:30,940 --> 00:21:34,929
proprietary gesture API. We think proprietary
APIs are bad for the Web. We would love to

270
00:21:34,929 --> 00:21:36,639
have a standardized API that works across
all browsers.

271
00:21:36,639 --> 00:21:41,070
[ Applause ]
That's the first time I got a applause for

272
00:21:41,070 --> 00:21:47,320
not doing a feature. I love it.
We love to have a standard API that all browsers

273
00:21:47,320 --> 00:21:52,740
can implement. But for various reasons, that's
not going to happen any time soon.

274
00:21:52,740 --> 00:21:56,100
So -- but the good news is, you actually don't
need the browser to do this for you. This

275
00:21:56,100 --> 00:21:59,950
is something that can be done perfectly well
by libraries, built on top of the touch events.

276
00:21:59,950 --> 00:22:03,490
There is a wide variety of different libraries.
And then you can use one of these libraries

277
00:22:03,490 --> 00:22:06,610
and have it work across all these browsers,
not have to worry about the differences in

278
00:22:06,610 --> 00:22:10,070
the browsers.
So I wrote a little demo here using hammer.js

279
00:22:10,070 --> 00:22:14,480
which exposes a whole slew of different types
of gestures. But the transform gesture in

280
00:22:14,480 --> 00:22:19,070
particular recognizes pinch and rotate. Let
me just show you what this looks like.

281
00:22:19,070 --> 00:22:24,909
So with a very small amount of code, I can
handle moving this box around, pinching it

282
00:22:24,909 --> 00:22:29,360
to zoom it, and rotating it. I haven't had
to listen to touch events at all. I have just

283
00:22:29,360 --> 00:22:32,679
done this and listened for transformer events
and imported the hammer library.

284
00:22:32,679 --> 00:22:36,590
So if you want to do it with gestures, I encourage
you to explore these libraries and contribute

285
00:22:36,590 --> 00:22:41,559
to them. Most of them I believe are open source
projects. Much better than a proprietary browser

286
00:22:41,559 --> 00:22:48,559
API in my opinion.
And now back to Boris to talk about performance.

287
00:22:49,289 --> 00:22:56,289
>>Boris Smus: All right. So, one performance
issue you may have seen are heard of is this

288
00:22:56,299 --> 00:23:02,120
infamous click delay. So the idea here is
the clicks on mobile browsers are generally

289
00:23:02,120 --> 00:23:06,960
delayed by something like 300 milliseconds
because the browser needs to decide if your

290
00:23:06,960 --> 00:23:11,090
click was a genuine click or if it was actually
a double tap. So there is this gesture where

291
00:23:11,090 --> 00:23:15,200
you want to zoom into some content that's
very small and you double tapped that and

292
00:23:15,200 --> 00:23:22,200
the browser zooms in. And so This behavior
can cause pages to feel very slow and unresponsive.

293
00:23:22,269 --> 00:23:25,480
And if you have been working in this space,
you have probably heard of fastclick as a

294
00:23:25,480 --> 00:23:30,789
solution for this. What fastclick basically
does is instead of using click, it uses just

295
00:23:30,789 --> 00:23:34,059
the touchend event, which is something we
described earlier.

296
00:23:34,059 --> 00:23:39,929
So, of course, you know now that there's some
drawbacks to using touchend versus click such

297
00:23:39,929 --> 00:23:46,929
as the touchfuzzing that Rick described earlier.
And you lose that if you use a fastclick library.

298
00:23:47,149 --> 00:23:51,789
In cases where we don't need a fastclick library,
we should avoid it.

299
00:23:51,789 --> 00:23:57,269
A couple things also changed over the last
year or os in Chrome. Firstly, Chrome desktop,

300
00:23:57,269 --> 00:24:03,259
which has touch support in some cases, like
in this Pixel or on Windows devices, there's

301
00:24:03,259 --> 00:24:07,049
no click delay because we don't actually support
the double tap to zoom gesture.

302
00:24:07,049 --> 00:24:10,190
>>Rick Byers: That's another feature, by the
way, we are never going to support because

303
00:24:10,190 --> 00:24:11,509
we are not going to add 300 milliseconds to
the click events.

304
00:24:11,509 --> 00:24:15,190
>>Boris Smus: Excellent.
>>Rick Byers: If I have anything to say about

305
00:24:15,190 --> 00:24:17,759
it. Sorry.
>>Boris Smus: In Chrome for Android, we have

306
00:24:17,759 --> 00:24:24,330
an optimization that landed over the last
year that doesn't create a click delay in

307
00:24:24,330 --> 00:24:29,039
the case of a fixed viewport. So you can fix
your viewport with user scalable equals no.

308
00:24:29,039 --> 00:24:32,929
And in that case, again, the double tap gesture
doesn't exist. So there is no need for us

309
00:24:32,929 --> 00:24:36,039
to delay.
So it is important that the fastclick library

310
00:24:36,039 --> 00:24:40,830
that you use is aware of these changes. Otherwise,
you lose the benefits. So we worked with FT

311
00:24:40,830 --> 00:24:45,700
Labs, which support one of the most popular
fastclick libraries. And they've patched their

312
00:24:45,700 --> 00:24:50,139
code to make sure that their library is smart
about this.

313
00:24:50,139 --> 00:24:56,509
So keep that in mind next time you're using
a fastclick approach.

314
00:24:56,509 --> 00:25:03,509
Okay. Another performance issue, you may have
written or seen code that looks like this.

315
00:25:04,210 --> 00:25:10,009
So this code essentially just renders every
time you get a touchmove event. The problem

316
00:25:10,009 --> 00:25:16,110
with this is that touchmove can fire very
quickly. Often it fires much faster than your

317
00:25:16,110 --> 00:25:23,110
render loop, which is 60 hertz if you're getting
a smooth performance -- smooth visual display.

318
00:25:25,559 --> 00:25:32,139
In some browsers, this problem is mitigated
by coalescing multiple touch events into one.

319
00:25:32,139 --> 00:25:37,470
So there's touch arrays that come with every
touch event. And it is up to the browser,

320
00:25:37,470 --> 00:25:41,749
basically, to decide if it should put all
the events together or if it should create

321
00:25:41,749 --> 00:25:47,749
separate touchmove events.
So let me just quickly show you here on a

322
00:25:47,749 --> 00:25:54,749
mobile device the possible issue. So here
I've got some code that basically does this

323
00:25:56,529 --> 00:26:00,559
naive approach where it renders everything
on touch. You can see I have got one finger.

324
00:26:00,559 --> 00:26:05,249
I'm just drawing the point and that works
really well. I can add a second finger and

325
00:26:05,249 --> 00:26:12,119
a third finger. You can sort of see the slowdown
now. But as I add the fourth finger, things

326
00:26:12,119 --> 00:26:14,179
really degrade.
>>> Ahhh.

327
00:26:14,179 --> 00:26:18,490
>>Boris Smus: So this is not what we want.
[ Laughter ]

328
00:26:18,490 --> 00:26:24,789
So touch events are piling up and, basically,
we're not able to render quickly enough and

329
00:26:24,789 --> 00:26:29,889
there is a big backlog of touches which is
why you see this delay.

330
00:26:29,889 --> 00:26:36,889
So the solution to this is to avoid expense
operations in your touch handlers. In general,

331
00:26:39,720 --> 00:26:43,320
this is good practice. But this is especially
important for touch.

332
00:26:43,320 --> 00:26:47,700
So rather than rendering, you can store the
touches and then set up a separate animation

333
00:26:47,700 --> 00:26:52,619
loop with something like requestAnimationframe
which makes sure that every single render

334
00:26:52,619 --> 00:26:58,789
is tied to the vsync of your display.
Just by doing this small optimization, let

335
00:26:58,789 --> 00:27:05,019
me show you the difference. So I will switch
to the requestAnimationframe version. There

336
00:27:05,019 --> 00:27:12,019
we go. And you can see that same four-finger
gesture is now extremely responsive just with

337
00:27:14,169 --> 00:27:21,169
that one small change.
Okay. Another performance issue is related

338
00:27:23,679 --> 00:27:29,940
to scroll jank. So in case you are not familiar
with scroll jank, the basic idea is sometimes

339
00:27:29,940 --> 00:27:36,919
scrolling can be very uneven and just not
be very responsive to your actual input. This

340
00:27:36,919 --> 00:27:41,080
can come in many forms.
But we've done some studies, and it's very

341
00:27:41,080 --> 00:27:45,840
important for engagement. So if your users
are dealing with a janky site, it's likely

342
00:27:45,840 --> 00:27:50,779
that they won't come back.
And Chrome team has spent a lot of effort

343
00:27:50,779 --> 00:27:55,619
of trying to optimize this scrolling. And
the big push has been to move scrolling to

344
00:27:55,619 --> 00:28:00,820
a separate hardware-accelerated GPU thread.
Event handling, though, is still, of course,

345
00:28:00,820 --> 00:28:04,639
on the main thread.
So there's something that can happen if you

346
00:28:04,639 --> 00:28:11,639
have fairly busy main thread because every
time you scroll, as Rick pointed out earlier,

347
00:28:11,639 --> 00:28:16,759
you can prevent the default behavior of the
scroll. And the way we do that is in JavaScript

348
00:28:16,759 --> 00:28:20,889
by using event prevent default.
What happens is every time you scroll, we

349
00:28:20,889 --> 00:28:26,239
need to call back -- well, Chrome calls back
into the main thread to see if it is allowed

350
00:28:26,239 --> 00:28:32,980
to. And if the main thread is really busy,
that causes the GPU thread to wait. So here's

351
00:28:32,980 --> 00:28:39,090
how this looks. I have got an artificially
busy main thread in this page. And I have

352
00:28:39,090 --> 00:28:46,090
also enabled an empty touchmove handler. So
it just it looks like this. It is a no op.

353
00:28:46,220 --> 00:28:53,220
And if you see me scrolling here, my finger
is moving smoothly, it's very janky. So by

354
00:28:55,789 --> 00:29:02,789
simply turning this off, I have a very different
experience. And that's a no op touch handler.

355
00:29:03,639 --> 00:29:10,049
So what's the story here?
How can we avoid this? Well, first, and quite

356
00:29:10,049 --> 00:29:16,039
obviously, we can just not use that touch
event handler. If it is unnecessary, there's

357
00:29:16,039 --> 00:29:19,739
no need for you to put it there and you will
save -- you will save yourself from seeing

358
00:29:19,739 --> 00:29:25,110
this issue at all.
And, of course, remember that in some cases,

359
00:29:25,110 --> 00:29:30,830
it's not so bad to have -- to rely on synthesized
DOM events like click, scroll, and context

360
00:29:30,830 --> 00:29:35,909
menu which all fire on touch devices.
So, basically, what I'm saying is, you don't

361
00:29:35,909 --> 00:29:42,909
need to implement touch-specific event handlers
necessarily to have a good experience on touchscreens.

362
00:29:43,389 --> 00:29:48,460
And another approach to solving this problem
is if you definitely do need a touch handler,

363
00:29:48,460 --> 00:29:52,889
make sure you've contained that touch region
to be as small as possible.

364
00:29:52,889 --> 00:29:59,149
So Chrome has optimizations that says if the
part of the page that the user is scrolling

365
00:29:59,149 --> 00:30:03,159
doesn't have a touch handler, then there is
no need for us to call back to the main thread.

366
00:30:03,159 --> 00:30:08,820
And we can just do the thing very quickly.
So, essentially, if you think of your page

367
00:30:08,820 --> 00:30:13,159
-- if you think of subdividing your page into
regions, you can decide whether or not you

368
00:30:13,159 --> 00:30:18,869
want to optimize for smooth scrolling or for
touch event handling.

369
00:30:18,869 --> 00:30:24,419
So this example that I showed you earlier
is the worst case where you've got a touch

370
00:30:24,419 --> 00:30:31,419
handler on your whole body for not good reason.
Okay. Back to Rick.

371
00:30:32,919 --> 00:30:37,600
>>Rick Byers: So we told you a bit about the
state of touch on the Web today.

372
00:30:37,600 --> 00:30:42,379
I want to touch briefly on some of the directions
that we want to head going forward.

373
00:30:42,379 --> 00:30:47,059
So, first of all, here's just a rough idea
of some of the goals that we've got. First

374
00:30:47,059 --> 00:30:51,019
of all, as we talked before, touch events
are pretty low-level API. And a lot of times

375
00:30:51,019 --> 00:30:55,299
you want to express your intent in a higher-level
fashion. So we would like to do more to eliminate

376
00:30:55,299 --> 00:30:58,149
the need for you to drop down to this low-level
API.

377
00:30:58,149 --> 00:31:03,029
For example, a really common scenario is to
want to support dragging things around, right,

378
00:31:03,029 --> 00:31:08,139
drag and drop-type UIs. There is actually
a high-level drag and drop API for the Web

379
00:31:08,139 --> 00:31:12,249
today. Unfortunately, it is only implemented
from mouse. Every browser that's drag and

380
00:31:12,249 --> 00:31:16,139
drop only does it with mouse input, which
seems a real shame. So we are starting to

381
00:31:16,139 --> 00:31:19,220
experiment with this in Chrome OS. You can
try it on your Pixel. You can turn it on in

382
00:31:19,220 --> 00:31:23,309
"about" flags. It is touch-based drag and
drop. Long press will initiate a drag and

383
00:31:23,309 --> 00:31:28,999
drop. And we are hoping we will get that on
by default in M29, which is coming up in a

384
00:31:28,999 --> 00:31:32,830
little bit.
And then once we're happy with it there, we

385
00:31:32,830 --> 00:31:37,440
will turn it on in the other platforms as
well, Android and Windows.

386
00:31:37,440 --> 00:31:40,929
We also want to give you more control over
the browser's default behavior so you don't

387
00:31:40,929 --> 00:31:44,220
have to fall back to touch events. A really
common scenario with touch events is an image

388
00:31:44,220 --> 00:31:47,989
carousel where you want to support swiping
between the different images.

389
00:31:47,989 --> 00:31:52,639
And really that's just a scrollable div except
that you really want to snap where it stops

390
00:31:52,639 --> 00:31:56,549
to image boundaries. And so what people end
up doing is they use a library or they write

391
00:31:56,549 --> 00:32:00,389
custom code to listen for touch events and
then they have to implement all the scrolling

392
00:32:00,389 --> 00:32:04,200
themselves, which doesn't sound that bad until
you realize that there is a certain physics

393
00:32:04,200 --> 00:32:07,779
that people are used to and they are used
to a certain momentum when you fling and then

394
00:32:07,779 --> 00:32:12,049
trying to match that to the browser's behavior
which is changing in between browsers is very

395
00:32:12,049 --> 00:32:15,609
hard. And then this whole -- all the work
we do to try to do to scroll on a GPU thread

396
00:32:15,609 --> 00:32:18,919
so we're not subject to jank for the main
thread, all that goes out the window when

397
00:32:18,919 --> 00:32:22,909
you implement scrolling in JavaScript.
So we love for common scrolling scenarios

398
00:32:22,909 --> 00:32:26,059
like that. We would like to just give you
features that let you customize the behavior

399
00:32:26,059 --> 00:32:31,080
like add snap points. IE10 has a feature for
this, so we are talking with Microsoft about

400
00:32:31,080 --> 00:32:35,759
how we can standardize that and bring it to
the standard Web.

401
00:32:35,759 --> 00:32:40,909
And we're working with other browser vendors
to bring new Web standards to help with touch

402
00:32:40,909 --> 00:32:47,239
as well. So, in particular, IE10 has a number
of touch features that are pretty nice. So

403
00:32:47,239 --> 00:32:51,600
we're talking with Microsoft about those.
In particular, pointer events is a new input

404
00:32:51,600 --> 00:32:55,759
model in IE10. IE10 doesn't support the touch
event model that we have been talking throughout

405
00:32:55,759 --> 00:32:58,879
this slide for. They have got a different
input model called pointer events.

406
00:32:58,879 --> 00:33:04,289
It has some design properties that we are
pretty excited about. First of all, it abstracts

407
00:33:04,289 --> 00:33:08,049
different types of input. You still need to
think to think about touch and mouse separately

408
00:33:08,049 --> 00:33:10,899
when you are designing your site. Sometimes
the right thing to do is to handle them the

409
00:33:10,899 --> 00:33:14,529
same. If the right thing to do is to handle
touch and mouse the same, you should be able

410
00:33:14,529 --> 00:33:19,340
to use the same code to do it. This model
extends the mouse even model, which means

411
00:33:19,340 --> 00:33:22,789
if you have already got a big investment in
code that's designed for the mouse model,

412
00:33:22,789 --> 00:33:26,159
you can -- rather than having to worry about
things like the difference in targeting model

413
00:33:26,159 --> 00:33:29,789
and the lack of over-and-out events, you can
update that code to work with point events

414
00:33:29,789 --> 00:33:33,039
very easily.
We would love to see more discussion on pointer

415
00:33:33,039 --> 00:33:37,779
events. This is the mailing list for the standards
group. Love to hear discussion there.

416
00:33:37,779 --> 00:33:41,840
The implementation, obviously, IE has implementation
and Firefox has said they have started to

417
00:33:41,840 --> 00:33:46,529
work on an implementation. Microsoft built
a prototype for Chrome, which is great. And

418
00:33:46,529 --> 00:33:50,739
now we have just announced that we're going
to start landing some experimental support

419
00:33:50,739 --> 00:33:55,960
in Blink for pointer events.
But adding a new input model isn't something

420
00:33:55,960 --> 00:34:00,989
we take lightly especially when it is redundant
with existing models and not necessarily something

421
00:34:00,989 --> 00:34:06,369
that browser vendors are going to embrace.
We are starting by adding some features that

422
00:34:06,369 --> 00:34:10,440
are going to make it easy to build high-performance,
high-quality polyfills for pointer events.

423
00:34:10,440 --> 00:34:13,919
And then we really want to get feedback from
you guys. We want to see if you vote with

424
00:34:13,919 --> 00:34:18,300
your feet by using the polyfills and send
us signals that you really want this model

425
00:34:18,300 --> 00:34:21,100
natively in the browser, then we will add
it to Chrome.

426
00:34:21,100 --> 00:34:25,679
So today there is a few early polyfills. None
of them are perfect, Butt hey are all pretty

427
00:34:25,679 --> 00:34:29,950
good and a good way to get a handle on how
pointer events work.

428
00:34:29,950 --> 00:34:35,300
If you went to the Web components talk earlier,
the application of Web components, the polymer

429
00:34:35,300 --> 00:34:39,310
framework, they decided that pointer events
was the right input model for polymer. So

430
00:34:39,310 --> 00:34:46,310
they built a polyfill that emulates pointer
events that you can use completely independently.

431
00:34:46,700 --> 00:34:51,540
So please check those out and send us feedback.
I will not go into full details of the pointer

432
00:34:51,540 --> 00:34:55,210
events API. Microsoft has a bunch of good
links. There's lots of full talks on their

433
00:34:55,210 --> 00:34:59,540
own. I want to touch on two things I'm particularly
excited about. First of all, I said that you

434
00:34:59,540 --> 00:35:04,350
can -- they let you specify declaratively
what to do with touch. And this is done through

435
00:35:04,350 --> 00:35:07,160
a CSS property called touch action.
When you say touch action none, it means you

436
00:35:07,160 --> 00:35:11,000
don't want the browser to take a default action
on touch, like scrolling. And instead you

437
00:35:11,000 --> 00:35:15,310
just want to deliver events. Where if you
say touch action auto, then that means you

438
00:35:15,310 --> 00:35:18,410
want the browser to determine what to do.
So, for example, as soon as you start scrolling,

439
00:35:18,410 --> 00:35:21,790
the browser says I'm supposed to scroll now
and it can start scrolling immediately and

440
00:35:21,790 --> 00:35:24,940
just send a cancel event to JavaScript to
say you will not get any more events now that

441
00:35:24,940 --> 00:35:28,320
these started scrolling. And it doesn't have
to block on the main thread. So that scroll

442
00:35:28,320 --> 00:35:33,000
jank problem that Boris showed which can be
a real problem especially on mobile devices

443
00:35:33,000 --> 00:35:39,410
just goes away completely with this.
I also said that this can be better for code

444
00:35:39,410 --> 00:35:44,930
sharing. We want to enable you to build sites
that work well across a range of devices.

445
00:35:44,930 --> 00:35:51,930
And so let me show you an example here. This
is a really simple demo of -- this is a really

446
00:35:52,230 --> 00:35:56,550
simple demo of drag and drop that's kind of
modeled after the Google+ circle editor.

447
00:35:56,550 --> 00:36:01,910
The idea is I can touch on a card and drag
it -- let me get all three of the circles

448
00:36:01,910 --> 00:36:06,950
-- touch on a card and drag it to one of these
circles. This is designed to work with multiple

449
00:36:06,950 --> 00:36:10,950
inputs. I can touch two cards at once, or
I can even use a mouse and touchscreen at

450
00:36:10,950 --> 00:36:15,750
once to drag things around.
And so let me show you what was involved to

451
00:36:15,750 --> 00:36:19,560
make this work. There's a bit of code here.
I won't go through all of it. The move handlers

452
00:36:19,560 --> 00:36:25,130
perhaps is the most interesting. When the
mouse moves, I just have a little bit of work

453
00:36:25,130 --> 00:36:27,850
to do really and then I delegate to this common
move function.

454
00:36:27,850 --> 00:36:32,800
But when I get a touchmove event, I am going
to delegate to the common move function. But

455
00:36:32,800 --> 00:36:35,490
then I have got to do a lot of other stuff
to compensate for the difference in targeting

456
00:36:35,490 --> 00:36:39,120
model.
This is all specific to the touchmodel.

457
00:36:39,120 --> 00:36:42,890
And then the common function for handling
movements is, like, a couple of lines. It

458
00:36:42,890 --> 00:36:46,640
is unfortunate, this is the only thing I can
do in common. The start and end events are

459
00:36:46,640 --> 00:36:50,730
like that as well. It is a pretty small amount
of common code for the two cases.

460
00:36:50,730 --> 00:36:57,150
If I use pointer events, I can get the amount
of shared code for about half the lines of

461
00:36:57,150 --> 00:37:01,230
code being shared for the two scenarios up
to 97% in this case. And get the number of

462
00:37:01,230 --> 00:37:04,560
lines of code I had to write down from 131
down to 89.

463
00:37:04,560 --> 00:37:08,560
Let me show you what that looks like. In this
case, since Chrome here doesn't have pointer

464
00:37:08,560 --> 00:37:15,560
event support, I'm using the points.js polyfill.
So with much less code, now I can still support

465
00:37:15,630 --> 00:37:20,350
dragging things around with touch and a mouse
simultaneously.

466
00:37:20,350 --> 00:37:23,600
And you can see that there is very little
code here that to handle the difference between

467
00:37:23,600 --> 00:37:26,590
mouse events and pointer events. I basically
just have to check to see if the browser supports

468
00:37:26,590 --> 00:37:30,990
pointer events. If so, I will use events that
start with the word "pointer" instead of the

469
00:37:30,990 --> 00:37:33,450
word "mouse." Otherwise, the events are the
same.

470
00:37:33,450 --> 00:37:38,500
And in order to handle multiple things moving
around at once, if I'm using pointer events,

471
00:37:38,500 --> 00:37:42,350
I'm using the unique identifier for pointer.
Otherwise, if I am using mouse events, I will

472
00:37:42,350 --> 00:37:47,010
just use this constant one. And, otherwise,
all the code is the same. The move event handler

473
00:37:47,010 --> 00:37:52,230
is just this here.
And then I have over-and-out handlers. And

474
00:37:52,230 --> 00:37:55,330
so for this scenario where I really want the
same thing to happen regardless the type of

475
00:37:55,330 --> 00:37:59,630
input, I can dramatically reduce the amount
of code I have to write and have to test,

476
00:37:59,630 --> 00:38:01,970
which is a big part of it.
That's a big part of it. So those are the

477
00:38:01,970 --> 00:38:04,500
reasons that I'm exciting about pointer events.
We would love to get your feedback, start

478
00:38:04,500 --> 00:38:11,500
using the polyfills. And, hopefully, we will
see it in Chrome at some point in the future.

479
00:38:11,860 --> 00:38:15,900
That's it for the future.
And we have given you a few tips now for how

480
00:38:15,900 --> 00:38:19,160
to make your site work great on touch. Now
that you all have Pixels, please try out your

481
00:38:19,160 --> 00:38:25,030
Web sites and apply these tips and make your
sites awesome on touchscreen laptops. If you

482
00:38:25,030 --> 00:38:28,640
have any problems doing that, we want to hear
about them. This is an area of the Web we

483
00:38:28,640 --> 00:38:31,540
are trying to make better and make more consistent
across different form factors and different

484
00:38:31,540 --> 00:38:33,550
browsers. So, please, we want to hear about
it.

485
00:38:33,550 --> 00:38:37,780
The public Web events mailing list, this the
group of the W3C that I'm a member of that

486
00:38:37,780 --> 00:38:42,370
works on touch events. That's a great mailing
list to give us feedback on the touch event

487
00:38:42,370 --> 00:38:45,960
model.
You can also reach out to me directly on Google+

488
00:38:45,960 --> 00:38:51,900
or Twitter. And Boris and I are going to be
to available to take questions. We have got,

489
00:38:51,900 --> 00:38:56,060
like, one minute, I guess.
Why don't we take one question from our extended

490
00:38:56,060 --> 00:39:00,050
audience. We have got thousands of people
watching around the world and take one quick

491
00:39:00,050 --> 00:39:03,250
question. Please submit feedback using this
URL, and then we will be down here to take

492
00:39:03,250 --> 00:39:09,640
any live questions.
You got the Dory up? Do we have any?

493
00:39:09,640 --> 00:39:13,300
>>Boris Smus: Maybe a live question, how's
that? We'll take one.

494
00:39:13,300 --> 00:39:20,300
>>Rick Byers: One live question. Okay.
>>> Do you know we're awesome?

495
00:39:22,860 --> 00:39:23,930
>>Rick Byers: We do now. Thank you very much.
>>Boris Smus: Thank you very much.

496
00:39:23,930 --> 00:39:24,330
[ Applause ]
>>> You were talking at the beginning about

497
00:39:24,330 --> 00:39:24,580
the hover. I was wondering if there is any
standards work going on of sort of creating

498
00:39:24,330 --> 00:39:24,580
an alternative to hover when you do the touchdown,
that that activates another style and touchup?

499
00:39:24,330 --> 00:39:24,580
Instead of hover, you know, have that in the
CSS rather than having to do that in JavaScript?

500
00:39:24,330 --> 00:39:24,580
>>Rick Byers: Right. That's what the active
CSS pseudoclass is for. The active CSS pseudoclass

501
00:39:24,560 --> 00:39:24,810
is defined in the standard to say when the
user is actively manipulating this thing,

502
00:39:24,720 --> 00:39:24,970
then active should be applied. So we apply
that -- on touchdown, we apply that and we

503
00:39:24,890 --> 00:39:25,140
stop applying on touchup. There is a couple
of details. We don't want to apply when you

504
00:39:25,060 --> 00:39:25,310
are scrolling, so there is a slight delay
before it kicks in. But that's effectively

505
00:39:25,220 --> 00:39:25,470
exactly what active is for.
>>> Does that work in multiple -- does that

506
00:39:25,350 --> 00:39:25,600
work in other browsers?
>>Rick Byers: It works in many. I think there

507
00:39:25,480 --> 00:39:25,730
is a caveat with iOS that I'm not too familiar
with. But I think there is some detail where

508
00:39:25,680 --> 00:39:26,040
you have to do something extra to make sure
it works in iOS. Certainly in Chrome, it works

509
00:39:26,040 --> 00:39:26,290
fine.
(Speaker off microphone.)

510
00:39:26,100 --> 00:39:26,350
>>Rick Byers: Depends upon your layout. It
can be made to work.

511
00:39:26,260 --> 00:39:26,510
>>> I seem to recall having tried that and
it didn't work.

512
00:39:26,410 --> 00:39:26,660
>>Rick Byers: Certainly, that's an example
of something we don't want you to have a touchevent

513
00:39:26,630 --> 00:39:26,880
handler to just change the style when something
is being touched like depressing a button.

514
00:39:26,840 --> 00:39:27,090
>>> Thanks.
>>Rick Byers: All right. Thanks very much.

515
00:39:26,950 --> 00:39:27,200
We will be down here for questions and then
up in the Chrome office hours area.

