1
00:00:00,000 --> 00:00:00,492

2
00:00:00,492 --> 00:00:05,904
[MUSIC PLAYING]

3
00:00:05,904 --> 00:00:16,740

4
00:00:16,740 --> 00:00:17,430
JOHN MCCUTCHAN: Hey, everyone.

5
00:00:17,430 --> 00:00:19,400
I'm John McCutchan, and welcome
to the Break Point.

6
00:00:19,400 --> 00:00:20,530
And I'm here with Loreena Lee.

7
00:00:20,530 --> 00:00:23,100
LOREENA LEE: Hi, I'm
Loreena Lee.

8
00:00:23,100 --> 00:00:24,590
JOHN MCCUTCHAN: So what
do you do at Google?

9
00:00:24,590 --> 00:00:27,020
LOREENA LEE: I actually work
on Gmail, and I'm focused

10
00:00:27,020 --> 00:00:31,220
primarily on performance, so
making it faster as well as

11
00:00:31,220 --> 00:00:33,110
making sure we're using the
right amount of memory.

12
00:00:33,110 --> 00:00:34,470
JOHN MCCUTCHAN: Nice,
well that's good.

13
00:00:34,470 --> 00:00:37,440
Good thing you're here, because
we're here today to

14
00:00:37,440 --> 00:00:39,880
talk about understanding the
way memory works inside

15
00:00:39,880 --> 00:00:43,160
JavaScript and how to profile
your usage of memory inside

16
00:00:43,160 --> 00:00:45,330
Chrome dev tools.

17
00:00:45,330 --> 00:00:49,490
So I'm going to spend a little
bit of time talking about the

18
00:00:49,490 --> 00:00:54,440
conceptual material for how
JavaScript manages memory.

19
00:00:54,440 --> 00:00:57,940
And then Loreena is going to
show us a really cool demo of

20
00:00:57,940 --> 00:01:00,990
using Chrome dev tools.

21
00:01:00,990 --> 00:01:05,400
So JavaScript variables can
be of four primary types--

22
00:01:05,400 --> 00:01:08,460
the boolean type, which just
true or false canonical

23
00:01:08,460 --> 00:01:13,530
values, the number type, which
is any double precision

24
00:01:13,530 --> 00:01:17,270
floating point number, the
string, which is a UTF-16

25
00:01:17,270 --> 00:01:20,650
encoded character array,
or an object, which

26
00:01:20,650 --> 00:01:21,695
is a key value map.

27
00:01:21,695 --> 00:01:23,360
For those of you familiar
with JavaScript, this

28
00:01:23,360 --> 00:01:24,400
is very basic stuff.

29
00:01:24,400 --> 00:01:27,830
But we're just going to start
from scratch and build up.

30
00:01:27,830 --> 00:01:31,390
So objects are built around
key value mapping.

31
00:01:31,390 --> 00:01:33,850
So the key goes in the
square brackets.

32
00:01:33,850 --> 00:01:34,960
And this is always a string.

33
00:01:34,960 --> 00:01:37,500
No matter what you put in
it, it's going to be

34
00:01:37,500 --> 00:01:38,870
coerced into a string.

35
00:01:38,870 --> 00:01:42,830
And then use that as the
look up into the table.

36
00:01:42,830 --> 00:01:47,240
And then for value, you can
store any JavaScript object

37
00:01:47,240 --> 00:01:50,330
inside of the value.

38
00:01:50,330 --> 00:01:54,810
So a key fundamental concept
of memory and JavaScript is

39
00:01:54,810 --> 00:01:56,250
the object graph.

40
00:01:56,250 --> 00:02:00,360
So we're looking at a whole
bunch of circles and lines on

41
00:02:00,360 --> 00:02:01,800
this slide.

42
00:02:01,800 --> 00:02:04,440
But let's start from the left
at the blue circle.

43
00:02:04,440 --> 00:02:08,120
This is the root object inside
the memory management system.

44
00:02:08,120 --> 00:02:10,630
This is not something that you
can explicitly manipulate or

45
00:02:10,630 --> 00:02:13,850
do anything with, but this is
just where every object that

46
00:02:13,850 --> 00:02:16,280
you create descends from.

47
00:02:16,280 --> 00:02:17,640
And so this is called
the root.

48
00:02:17,640 --> 00:02:21,050
And from the root, it references
global variables

49
00:02:21,050 --> 00:02:26,470
and other global state that's
available to the browser.

50
00:02:26,470 --> 00:02:28,640
The red objects are
object variables.

51
00:02:28,640 --> 00:02:31,030
So these can reference
other variables.

52
00:02:31,030 --> 00:02:34,900
And the green circles are
scalar variables, like a

53
00:02:34,900 --> 00:02:38,830
boolean or a number that can't
reference anything else.

54
00:02:38,830 --> 00:02:42,190
And you can see the green note
at the end there, on the upper

55
00:02:42,190 --> 00:02:46,120
right part of the screen with
the yellow arrow, this is the

56
00:02:46,120 --> 00:02:49,680
terminating node in this part
of the object graph.

57
00:02:49,680 --> 00:02:54,270

58
00:02:54,270 --> 00:02:56,660
So objects have a concept
of a retaining tree.

59
00:02:56,660 --> 00:03:01,620
And this is the paths along the
graph that are keeping the

60
00:03:01,620 --> 00:03:03,910
object from being classified
as memory.

61
00:03:03,910 --> 00:03:06,560
So on the slide right now,
you can see a green node.

62
00:03:06,560 --> 00:03:07,980
And let's look at the
retaining tree

63
00:03:07,980 --> 00:03:09,890
for this green node.

64
00:03:09,890 --> 00:03:13,190
So the retaining tree is
this yellow node here--

65
00:03:13,190 --> 00:03:15,310
the root node--

66
00:03:15,310 --> 00:03:19,570
as well as this other path from
the root to the other

67
00:03:19,570 --> 00:03:20,440
yellow node as well.

68
00:03:20,440 --> 00:03:23,340
So the object actually has two
paths that are keeping it

69
00:03:23,340 --> 00:03:24,740
pinned into memory.

70
00:03:24,740 --> 00:03:27,260
If both of these paths are
terminated, then the object

71
00:03:27,260 --> 00:03:28,860
becomes garbage and eventually
is collected.

72
00:03:28,860 --> 00:03:33,990

73
00:03:33,990 --> 00:03:35,810
Objects have two sizes.

74
00:03:35,810 --> 00:03:38,310
They have a shallow size, which
is just the size of the

75
00:03:38,310 --> 00:03:39,690
actual object.

76
00:03:39,690 --> 00:03:42,570
And this is usually a very
small constant value.

77
00:03:42,570 --> 00:03:46,590
I think on my system, an
object is 36 bytes.

78
00:03:46,590 --> 00:03:50,520
All of the variables that the
object references are

79
00:03:50,520 --> 00:03:51,740
accumulated together.

80
00:03:51,740 --> 00:03:54,170
The sizes of those objects are
accumulated, and this is the

81
00:03:54,170 --> 00:03:55,740
retained size of an object.

82
00:03:55,740 --> 00:03:58,440
This is the amount of memory
that could be freed if this

83
00:03:58,440 --> 00:04:02,260
object was turned
into garbage.

84
00:04:02,260 --> 00:04:05,240
LOREENA LEE: If you go back to
the previous slide, we can see

85
00:04:05,240 --> 00:04:11,280
the retained side of the root
node would be basically the

86
00:04:11,280 --> 00:04:13,940
whole graph except for those
two disconnected

87
00:04:13,940 --> 00:04:14,724
nodes in the middle.

88
00:04:14,724 --> 00:04:16,910
JOHN MCCUTCHAN: Yes,
which are garbage.

89
00:04:16,910 --> 00:04:20,190
So from the root node, the
retain sizes is the size of

90
00:04:20,190 --> 00:04:23,020
everything that's
still reachable.

91
00:04:23,020 --> 00:04:27,750

92
00:04:27,750 --> 00:04:29,150
So what exactly is garbage?

93
00:04:29,150 --> 00:04:32,110
Well, the definition of garbage
is any variable and

94
00:04:32,110 --> 00:04:36,290
all variables which cannot be
reached from the root node.

95
00:04:36,290 --> 00:04:39,850
So in this diagram here, I've
highlighted the two nodes

96
00:04:39,850 --> 00:04:40,640
which are garbage.

97
00:04:40,640 --> 00:04:43,860
The red node is referencing in
the green node, but there is

98
00:04:43,860 --> 00:04:49,030
no path from the blue root node
to that red node, making

99
00:04:49,030 --> 00:04:50,885
both the red and the green
node into garbage.

100
00:04:50,885 --> 00:04:54,420

101
00:04:54,420 --> 00:04:56,960
So garbage collection happens
in two phases.

102
00:04:56,960 --> 00:05:02,810
First, the graph is scanned,
and all garbage is found.

103
00:05:02,810 --> 00:05:05,090
So we already know the garbage
in this graph was the red and

104
00:05:05,090 --> 00:05:06,030
the green node.

105
00:05:06,030 --> 00:05:10,000
And then this memory is returned
to the system during

106
00:05:10,000 --> 00:05:11,250
the collection phase.

107
00:05:11,250 --> 00:05:14,500

108
00:05:14,500 --> 00:05:16,650
So it's important when
optimizing for performance and

109
00:05:16,650 --> 00:05:18,950
memory usage to understand
the cost model

110
00:05:18,950 --> 00:05:20,740
for allocating memory.

111
00:05:20,740 --> 00:05:23,190
So every time that your
JavaScript application calls

112
00:05:23,190 --> 00:05:26,710
new, it reserves memory from
something called the young

113
00:05:26,710 --> 00:05:27,860
memory pool.

114
00:05:27,860 --> 00:05:31,700
So memory is split into young
objects and old objects.

115
00:05:31,700 --> 00:05:35,110
The v8 internally decides when
to promote an object from the

116
00:05:35,110 --> 00:05:37,410
young memory pool to the
old memory pool.

117
00:05:37,410 --> 00:05:39,445
You don't have any control over
that, but when you call

118
00:05:39,445 --> 00:05:42,230
new, you're going to be scooping
up memory from the

119
00:05:42,230 --> 00:05:44,160
young memory pool, which
is very cheap.

120
00:05:44,160 --> 00:05:49,090
It's actually incredibly fast
until the on memory pool runs

121
00:05:49,090 --> 00:05:50,010
out of memory.

122
00:05:50,010 --> 00:05:53,850
And at that point, the young
memory pool is scanned, and

123
00:05:53,850 --> 00:05:55,950
all of the garbage is collected,
freeing memory,

124
00:05:55,950 --> 00:05:58,890
making it possible to allocate
new objects.

125
00:05:58,890 --> 00:06:00,740
And this could take
milliseconds.

126
00:06:00,740 --> 00:06:03,420
So for interactive applications,
you really want

127
00:06:03,420 --> 00:06:07,690
to be careful about how you
allocate objects and what the

128
00:06:07,690 --> 00:06:11,490
patterns are, and how long you
hold onto them, particularly

129
00:06:11,490 --> 00:06:12,450
for a game.

130
00:06:12,450 --> 00:06:15,470
You pretty much need to be able
to do a frame with zero

131
00:06:15,470 --> 00:06:18,900
allocations, because inside
of a frame, you have 16

132
00:06:18,900 --> 00:06:21,630
milliseconds to compute the
state of the world, render it,

133
00:06:21,630 --> 00:06:24,800
and take input handling,
play sound.

134
00:06:24,800 --> 00:06:29,330
If half of that time is taken up
by garbage collection, the

135
00:06:29,330 --> 00:06:30,730
game's not going to
be very much fun.

136
00:06:30,730 --> 00:06:35,120

137
00:06:35,120 --> 00:06:40,860
So in summary, all variables
that you have in JavaScript

138
00:06:40,860 --> 00:06:42,680
are part of the object graph.

139
00:06:42,680 --> 00:06:46,530
And the only inner nodes
in an object graph

140
00:06:46,530 --> 00:06:47,990
are JavaScript objects.

141
00:06:47,990 --> 00:06:50,540
They're the only type of
variable that can reference

142
00:06:50,540 --> 00:06:52,180
other variables.

143
00:06:52,180 --> 00:06:53,730
And objects have two sizes--

144
00:06:53,730 --> 00:06:56,460
the shallow size, which is
just the size of this the

145
00:06:56,460 --> 00:06:59,640
object itself and then the
retained size, which is the

146
00:06:59,640 --> 00:07:02,040
size of the object itself
plus all of its

147
00:07:02,040 --> 00:07:05,600
descendants shallow sizes.

148
00:07:05,600 --> 00:07:08,560
So all variables that cannot be
reached from the root are

149
00:07:08,560 --> 00:07:09,760
classified as garbage.

150
00:07:09,760 --> 00:07:13,810
And when v8 decides it's an
appropriate time, it will do a

151
00:07:13,810 --> 00:07:16,780
garbage collection phase,
freeing up memory and

152
00:07:16,780 --> 00:07:20,100
collecting all the garbage and
giving it back to the system.

153
00:07:20,100 --> 00:07:22,840
So allocations are really cheap
until the young memory

154
00:07:22,840 --> 00:07:24,760
pool runs out of memory.

155
00:07:24,760 --> 00:07:27,220
At that point, a garbage
collection is forced, it's not

156
00:07:27,220 --> 00:07:29,550
just done at an opportune
time.

157
00:07:29,550 --> 00:07:31,030
So you have to watch out
for that in interactive

158
00:07:31,030 --> 00:07:32,280
applications.

159
00:07:32,280 --> 00:07:34,680

160
00:07:34,680 --> 00:07:36,910
So Loreena, do you want
to give us your demo?

161
00:07:36,910 --> 00:07:38,820
LOREENA LEE: Sure, so just a
little bit of basics about the

162
00:07:38,820 --> 00:07:39,600
Chrome dev tools.

163
00:07:39,600 --> 00:07:42,340
So we'll talk about how you
can use the dev tools to

164
00:07:42,340 --> 00:07:46,020
profile what's in your heap at
any given time, and then also

165
00:07:46,020 --> 00:07:48,990
to find situations where you may
be leaving around memory

166
00:07:48,990 --> 00:07:52,940
allocated that you don't
need anymore.

167
00:07:52,940 --> 00:07:55,000
So in general, the garbage
collector should be cleaning

168
00:07:55,000 --> 00:07:55,940
up after you.

169
00:07:55,940 --> 00:07:57,920
But there are certain
situations, which we'll see in

170
00:07:57,920 --> 00:08:00,500
a little bit, where
things may not get

171
00:08:00,500 --> 00:08:03,340
cleaned up as expected.

172
00:08:03,340 --> 00:08:07,270
So a little bit of his
background on the dev tools.

173
00:08:07,270 --> 00:08:08,450
We can use these now.

174
00:08:08,450 --> 00:08:10,600
There are multiple tabs, and
we're going to go through this

175
00:08:10,600 --> 00:08:11,400
in an example.

176
00:08:11,400 --> 00:08:15,090
But first, you want to if you
have a suspicious action, so

177
00:08:15,090 --> 00:08:19,280
you see that your memory is
growing, or you think that

178
00:08:19,280 --> 00:08:21,120
your application is slowing
down for some reason or

179
00:08:21,120 --> 00:08:23,500
another, and you think that
memory might be the situation,

180
00:08:23,500 --> 00:08:28,130
you can use the Timeline tab to
perform the action and see

181
00:08:28,130 --> 00:08:29,070
what's happening to memory.

182
00:08:29,070 --> 00:08:30,890
So we can see if it's
growing over time.

183
00:08:30,890 --> 00:08:33,919
And if so, then we can say,
OK, now we need to dig a

184
00:08:33,919 --> 00:08:37,090
little bit deeper and see what's
happening in the heap.

185
00:08:37,090 --> 00:08:39,960
So we can use that to capture
a heap snapshot, which will

186
00:08:39,960 --> 00:08:42,620
show you all the objects that
are in the graph that John

187
00:08:42,620 --> 00:08:44,470
just talked about.

188
00:08:44,470 --> 00:08:47,850
It does not capture scalar
values, which were the green

189
00:08:47,850 --> 00:08:48,560
nodes-- green nodes?

190
00:08:48,560 --> 00:08:48,720
JOHN MCCUTCHAN: Yes.

191
00:08:48,720 --> 00:08:51,610
LOREENA LEE: Green nodes in
the graph that we saw.

192
00:08:51,610 --> 00:08:54,350
But it does show you
all the JavaScript

193
00:08:54,350 --> 00:08:56,390
objects that are allocated.

194
00:08:56,390 --> 00:08:58,230
There are four views
of a snapshot.

195
00:08:58,230 --> 00:08:59,990
And you'll see these in
the demo as well.

196
00:08:59,990 --> 00:09:02,220
There's the summary view, which
shows you everything in

197
00:09:02,220 --> 00:09:07,750
the heap, and you can apply a
filter on the entire graph to

198
00:09:07,750 --> 00:09:09,080
show only certain things.

199
00:09:09,080 --> 00:09:10,530
And I'll talk about that
in a little bit

200
00:09:10,530 --> 00:09:12,570
in the demo as well.

201
00:09:12,570 --> 00:09:14,370
And then there's a comparison
view, where you can view the

202
00:09:14,370 --> 00:09:15,980
differences between two
heap snapshots.

203
00:09:15,980 --> 00:09:18,540
So you take one snapshot and
then take another one and see

204
00:09:18,540 --> 00:09:19,780
what happens to memories.

205
00:09:19,780 --> 00:09:21,210
Did more things get allocated?

206
00:09:21,210 --> 00:09:22,890
Did a bunch of stuff
get collected?

207
00:09:22,890 --> 00:09:24,700
What's going on there?

208
00:09:24,700 --> 00:09:28,120
There's a containment view,
which is a bird's eye view of

209
00:09:28,120 --> 00:09:30,620
the app's overall object
structure.

210
00:09:30,620 --> 00:09:34,410
So John mentioned a little
bit about memory

211
00:09:34,410 --> 00:09:38,080
versus retained memory.

212
00:09:38,080 --> 00:09:41,250
And so in the containment view,
you can see more easily

213
00:09:41,250 --> 00:09:43,950
what the retained memory is.

214
00:09:43,950 --> 00:09:45,660
And the DOMinator's also
has a different

215
00:09:45,660 --> 00:09:46,610
view of the same summary.

216
00:09:46,610 --> 00:09:48,360
JOHN MCCUTCHAN: Yeah, so the
summary and the comparison

217
00:09:48,360 --> 00:09:51,570
view are sorted and organized
around the objects

218
00:09:51,570 --> 00:09:55,320
constructor, whereas the
containment view is organized

219
00:09:55,320 --> 00:09:56,370
starting at the root.

220
00:09:56,370 --> 00:09:59,950
So it captures the structure
of the object graph.

221
00:09:59,950 --> 00:10:03,220

222
00:10:03,220 --> 00:10:05,540
LOREENA LEE: OK, so we're not
going to cover the container

223
00:10:05,540 --> 00:10:08,380
and DOMinator's view too
much in this demo.

224
00:10:08,380 --> 00:10:11,790
But there's some really great
documentation online at

225
00:10:11,790 --> 00:10:15,120
developers.google.com, where
you can see some nice demos

226
00:10:15,120 --> 00:10:17,410
that show you exactly
what you can see by

227
00:10:17,410 --> 00:10:20,740
these two other views.

228
00:10:20,740 --> 00:10:23,110
So we talked about comparison
view and how sometimes you can

229
00:10:23,110 --> 00:10:24,370
take two snapshots
to find leaks.

230
00:10:24,370 --> 00:10:26,160
But we're going to talk
about a case where two

231
00:10:26,160 --> 00:10:27,410
is not quite enough.

232
00:10:27,410 --> 00:10:30,940

233
00:10:30,940 --> 00:10:33,760
Some other good tips to know,
though, are, you should always

234
00:10:33,760 --> 00:10:36,750
do these experiments in
an incognito window.

235
00:10:36,750 --> 00:10:38,870
You want to make sure that
you're in a clean room

236
00:10:38,870 --> 00:10:39,500
environment.

237
00:10:39,500 --> 00:10:42,230
You don't have your extensions
that may be interacting with

238
00:10:42,230 --> 00:10:44,620
your app in a way that you
don't understand or

239
00:10:44,620 --> 00:10:45,580
you don't even know.

240
00:10:45,580 --> 00:10:47,470
So something these third party
extensions do all sorts of

241
00:10:47,470 --> 00:10:49,610
crazy things to memory, and
you want to make sure that

242
00:10:49,610 --> 00:10:51,615
those aren't influencing
your results at all.

243
00:10:51,615 --> 00:10:54,010
JOHN MCCUTCHAN: Yeah, just to
repeat that, any browser

244
00:10:54,010 --> 00:10:57,860
extension that is loaded will be
part of the heap snapshot.

245
00:10:57,860 --> 00:10:59,900
So you're not just looking
at your code.

246
00:10:59,900 --> 00:11:02,930
You're also looking at any
extension that happens to be

247
00:11:02,930 --> 00:11:04,190
loaded at the same time.

248
00:11:04,190 --> 00:11:06,850
So an incognito windows is a
quick way to avoid loading

249
00:11:06,850 --> 00:11:08,100
your extensions.

250
00:11:08,100 --> 00:11:10,250

251
00:11:10,250 --> 00:11:11,880
LOREENA LEE: And then you want
to get your bearings.

252
00:11:11,880 --> 00:11:16,230
So on the heap profile page,
you'll see that when we show

253
00:11:16,230 --> 00:11:18,350
the heap, there's a lot
of stuff in the heap.

254
00:11:18,350 --> 00:11:21,030
Basically, anything in
parentheses you should just

255
00:11:21,030 --> 00:11:22,580
filter out of your brain
for a little bit.

256
00:11:22,580 --> 00:11:24,000
You can just ignore them.

257
00:11:24,000 --> 00:11:26,500
A lot of the things are also
going to be dimmed, and those

258
00:11:26,500 --> 00:11:29,070
are system allocations
that we can't really

259
00:11:29,070 --> 00:11:29,890
control from your app.

260
00:11:29,890 --> 00:11:32,040
So those also should
be ignored.

261
00:11:32,040 --> 00:11:34,010
And then the other thing to note
is, when you click that

262
00:11:34,010 --> 00:11:38,190
heap snapshot button, a full
garbage collection right

263
00:11:38,190 --> 00:11:40,330
before you click it before
the heap is profiled.

264
00:11:40,330 --> 00:11:44,160
So you can assume that anything
that v8 decided that

265
00:11:44,160 --> 00:11:47,350
it should GC should already
be cleaned up.

266
00:11:47,350 --> 00:11:52,520
So let's move on to the demo.

267
00:11:52,520 --> 00:11:54,040
Let's see.

268
00:11:54,040 --> 00:11:55,290
Where are we?

269
00:11:55,290 --> 00:11:57,010

270
00:11:57,010 --> 00:12:00,700
So we have this quick
little demo.

271
00:12:00,700 --> 00:12:03,450
It really doesn't
do a whole lot.

272
00:12:03,450 --> 00:12:04,800
There's one button.

273
00:12:04,800 --> 00:12:07,170
And when I click it, it will
start filling up a cache.

274
00:12:07,170 --> 00:12:12,910
So I have a cache of five items
that, whenever I click

275
00:12:12,910 --> 00:12:15,440
it, it fills in the
cache of five.

276
00:12:15,440 --> 00:12:16,520
So the size is five.

277
00:12:16,520 --> 00:12:18,597
JOHN MCCUTCHAN: So what happens
to the entries that

278
00:12:18,597 --> 00:12:20,190
are already in the cache?

279
00:12:20,190 --> 00:12:21,590
LOREENA LEE: When I first
click it, there's

280
00:12:21,590 --> 00:12:22,970
nothing in the cache.

281
00:12:22,970 --> 00:12:27,720
So what we want to do is, in
theory, when we flush the

282
00:12:27,720 --> 00:12:30,260
cache-- so by filling
it with new stuff--

283
00:12:30,260 --> 00:12:33,220
in theory, all the things that
were in the cache before

284
00:12:33,220 --> 00:12:34,070
should be evicted.

285
00:12:34,070 --> 00:12:37,230
And in theory, we think that
they should be collected.

286
00:12:37,230 --> 00:12:38,850
Let's find out what happens.

287
00:12:38,850 --> 00:12:42,560
So let's go ahead and refresh
just so we know that we're

288
00:12:42,560 --> 00:12:44,150
loading everything from
a clean state.

289
00:12:44,150 --> 00:12:48,520

290
00:12:48,520 --> 00:12:49,060
Let's go back to the timeline.

291
00:12:49,060 --> 00:12:50,220
I mentioned this earlier.

292
00:12:50,220 --> 00:12:51,630
JOHN MCCUTCHAN: Yeah, that
would be great, actually.

293
00:12:51,630 --> 00:12:53,190
LOREENA LEE: So we can
go to the timeline.

294
00:12:53,190 --> 00:12:56,710
Let's say that we think that
this is causing a memory leak.

295
00:12:56,710 --> 00:12:58,900
So we're going to go onto
the memory here.

296
00:12:58,900 --> 00:13:02,690
And we're going to click Record,
which is this gray

297
00:13:02,690 --> 00:13:03,590
circle at the bottom.

298
00:13:03,590 --> 00:13:04,640
JOHN MCCUTCHAN: It
will be red.

299
00:13:04,640 --> 00:13:05,810
LOREENA LEE: And now it's red.

300
00:13:05,810 --> 00:13:08,290
So we're going to go ahead and
say, let's do some work.

301
00:13:08,290 --> 00:13:11,490
And we'll just do it a few
times, click it a few times.

302
00:13:11,490 --> 00:13:13,070
And then there's this little
button here that looks

303
00:13:13,070 --> 00:13:14,270
like a trash can.

304
00:13:14,270 --> 00:13:16,880
And that will force a
garbage collection.

305
00:13:16,880 --> 00:13:21,260
So let's just force it and
say, OK, maybe it now can

306
00:13:21,260 --> 00:13:23,430
clean up whatever it was
that I left behind.

307
00:13:23,430 --> 00:13:26,340
So hopefully, all those things
that I added to the cache that

308
00:13:26,340 --> 00:13:28,580
had been flushed out, pushed
out of the cache should be

309
00:13:28,580 --> 00:13:29,160
cleaned up.

310
00:13:29,160 --> 00:13:30,990
And we'll go and do
some more work.

311
00:13:30,990 --> 00:13:34,600
So you can see that at the top,
the memory is growing.

312
00:13:34,600 --> 00:13:36,750
So you see in blue there
that there's some new

313
00:13:36,750 --> 00:13:37,780
memory being allocated.

314
00:13:37,780 --> 00:13:40,840
And when I click the garbage
can, it seemed to have dropped

315
00:13:40,840 --> 00:13:43,800
a little bit but not quite
to the baseline.

316
00:13:43,800 --> 00:13:46,270
So let's go ahead
and stop this.

317
00:13:46,270 --> 00:13:52,060
And if I go and click anywhere
on the top here, I can look at

318
00:13:52,060 --> 00:13:53,900
a specific part of the graph.

319
00:13:53,900 --> 00:13:59,940
And I can widen this window here
to view whatever portion

320
00:13:59,940 --> 00:14:01,400
of the graph I want to see.

321
00:14:01,400 --> 00:14:03,700
So down below, you see this
green line that kind of looks

322
00:14:03,700 --> 00:14:05,090
like a stair step.

323
00:14:05,090 --> 00:14:08,040
And each time I push the button,
that is the number of

324
00:14:08,040 --> 00:14:09,520
DOM nodes that are allocated.

325
00:14:09,520 --> 00:14:11,600
So you can see that
it goes up.

326
00:14:11,600 --> 00:14:13,410
JOHN MCCUTCHAN: So it looks like
we're leaking DOM nodes.

327
00:14:13,410 --> 00:14:14,140
LOREENA LEE: Well, it
looks like we're

328
00:14:14,140 --> 00:14:15,110
allocating DOM nodes.

329
00:14:15,110 --> 00:14:17,170
We aren't necessarily
leaking them yet.

330
00:14:17,170 --> 00:14:18,650
So we don't know.

331
00:14:18,650 --> 00:14:20,420
The garbage collector may
not have kicked in yet.

332
00:14:20,420 --> 00:14:23,850
And so they wouldn't
get collected.

333
00:14:23,850 --> 00:14:24,210
JOHN MCCUTCHAN: Oh,
that's right.

334
00:14:24,210 --> 00:14:26,870
We're not looking at the part
of the graph after you

335
00:14:26,870 --> 00:14:27,980
clicked, garbage.

336
00:14:27,980 --> 00:14:29,732
LOREENA LEE: Exactly.

337
00:14:29,732 --> 00:14:33,030
Let's bring it out over a little
bit wider so we can see

338
00:14:33,030 --> 00:14:34,180
what's going on.

339
00:14:34,180 --> 00:14:37,640
And right around where the dip
is in the blue line is when I

340
00:14:37,640 --> 00:14:39,150
click the garbage button.

341
00:14:39,150 --> 00:14:41,360
And we don't see
it going down.

342
00:14:41,360 --> 00:14:43,240
So that is the problem.

343
00:14:43,240 --> 00:14:45,810
And if we widen it even more,
where I clicked a little bit

344
00:14:45,810 --> 00:14:50,600
more, you can see there's more
stair steps up when I click

345
00:14:50,600 --> 00:14:51,380
the button.

346
00:14:51,380 --> 00:14:52,830
So we're pretty sure
we have a leak.

347
00:14:52,830 --> 00:14:54,780
JOHN MCCUTCHAN: This looks
pretty suspicious.

348
00:14:54,780 --> 00:14:56,970
LOREENA LEE: And on the left,
there's the DOM node count.

349
00:14:56,970 --> 00:15:00,890
So it'll tell you what the range
in DOM nodes allocated

350
00:15:00,890 --> 00:15:02,470
for the range that you're
looking at.

351
00:15:02,470 --> 00:15:04,430
So from here, we
started at 15.

352
00:15:04,430 --> 00:15:05,370
And now we've got 92.

353
00:15:05,370 --> 00:15:07,250
So that number never
went down.

354
00:15:07,250 --> 00:15:12,740
We see that the green line
pretty much never goes down.

355
00:15:12,740 --> 00:15:16,280
So now we can go back
to the profile page.

356
00:15:16,280 --> 00:15:19,140
And let's refresh again, so we
can flush the cache, start

357
00:15:19,140 --> 00:15:20,980
with a clean slate.

358
00:15:20,980 --> 00:15:23,090
And now we're going to
take a heap snapshot.

359
00:15:23,090 --> 00:15:26,610
So take a heap snapshot,
and click Start.

360
00:15:26,610 --> 00:15:28,380
So it's super fast,
because this is a

361
00:15:28,380 --> 00:15:29,590
pretty lightweight thing.

362
00:15:29,590 --> 00:15:31,640
So this is our first snapshot.

363
00:15:31,640 --> 00:15:34,280
JOHN MCCUTCHAN: So I see a lot
of things in parentheses right

364
00:15:34,280 --> 00:15:35,370
up at the top.

365
00:15:35,370 --> 00:15:36,780
LOREENA LEE: So we're going to
go ahead and ignore those.

366
00:15:36,780 --> 00:15:40,160
These are compiled code, system
arrays, things that we

367
00:15:40,160 --> 00:15:41,250
really can't control.

368
00:15:41,250 --> 00:15:43,920
So go ahead and ignore
those for now.

369
00:15:43,920 --> 00:15:47,200
And we'll just scroll
down a little bit.

370
00:15:47,200 --> 00:15:50,090
And you can see that we've
got all sorts of

371
00:15:50,090 --> 00:15:51,230
stuff in our heap.

372
00:15:51,230 --> 00:15:54,100
JOHN MCCUTCHAN: So everything in
this table is sorted by the

373
00:15:54,100 --> 00:15:55,890
constructor call.

374
00:15:55,890 --> 00:16:01,210
So it's not the variable name
or the path that you could

375
00:16:01,210 --> 00:16:02,560
follow to get to the variable.

376
00:16:02,560 --> 00:16:06,390
It is the constructor.

377
00:16:06,390 --> 00:16:08,300
LOREENA LEE: So at the top,
it says, class filter.

378
00:16:08,300 --> 00:16:09,860
So if you wanted to search
for a certain thing--

379
00:16:09,860 --> 00:16:13,600
I know that we have our caches
of objects called stuff.

380
00:16:13,600 --> 00:16:15,320
So if I type in, stuff here--

381
00:16:15,320 --> 00:16:16,310
JOHN MCCUTCHAN: Very
descriptive.

382
00:16:16,310 --> 00:16:17,820
LOREENA LEE: Well, there's
nothing here, because we

383
00:16:17,820 --> 00:16:19,820
haven't allocated
anything yet.

384
00:16:19,820 --> 00:16:21,730
So that's expected.

385
00:16:21,730 --> 00:16:23,680
So let's clear this out.

386
00:16:23,680 --> 00:16:25,940
And let's do some more work--

387
00:16:25,940 --> 00:16:27,820
or do some work, we haven't
done any yet.

388
00:16:27,820 --> 00:16:32,330
And we're going to click and
collect another snapshot.

389
00:16:32,330 --> 00:16:34,900
So if we click on this snapshot
now, you can see that

390
00:16:34,900 --> 00:16:39,820
we've got a 1.3 megabyte heap,
whereas before we had a 1.2.

391
00:16:39,820 --> 00:16:41,750
So now we get to those different
views we talked

392
00:16:41,750 --> 00:16:43,020
about earlier.

393
00:16:43,020 --> 00:16:45,440
So right at the bottom here,
it says, summary.

394
00:16:45,440 --> 00:16:47,610
And right now, we're looking at
a summary view, and we're

395
00:16:47,610 --> 00:16:49,000
showing all objects
in the view.

396
00:16:49,000 --> 00:16:54,130
And so that's why we see this
long, long list of things.

397
00:16:54,130 --> 00:16:56,090
So let's go to Comparison
View.

398
00:16:56,090 --> 00:16:57,880
Let's say we want to know,
what's the difference between

399
00:16:57,880 --> 00:17:01,760
snapshot two and snapshot one
when we click that button?

400
00:17:01,760 --> 00:17:03,700
And so it says we're in
Comparison View, and we're

401
00:17:03,700 --> 00:17:05,670
comparing with snapshot one.

402
00:17:05,670 --> 00:17:07,770
And so these are the
differences.

403
00:17:07,770 --> 00:17:10,430
And it's a much shorter list,
because we filtered out now.

404
00:17:10,430 --> 00:17:12,099
JOHN MCCUTCHAN: We really
culled a lot of it.

405
00:17:12,099 --> 00:17:18,270
LOREENA LEE: So these are
now showing us only the

406
00:17:18,270 --> 00:17:20,329
differences between
one and two.

407
00:17:20,329 --> 00:17:22,530
So you see we have this,
stuff object.

408
00:17:22,530 --> 00:17:25,670
And I told you that the cache
was a five item cache.

409
00:17:25,670 --> 00:17:27,950
And so there are five items.

410
00:17:27,950 --> 00:17:31,960
And way over here, you can
see, if we highlight the

411
00:17:31,960 --> 00:17:35,820
stuff, the delta between
snapshot two and snapshot one

412
00:17:35,820 --> 00:17:36,560
is plus five.

413
00:17:36,560 --> 00:17:38,920
So there's five new objects of
stuff, which is exactly what

414
00:17:38,920 --> 00:17:40,440
we expected.

415
00:17:40,440 --> 00:17:44,750
JOHN MCCUTCHAN: So this column
here is the number of objects

416
00:17:44,750 --> 00:17:46,890
that were created of that type,
this is the number that

417
00:17:46,890 --> 00:17:49,400
were deleted, and then this is
just the sum of the two.

418
00:17:49,400 --> 00:17:50,650
LOREENA LEE: Correct.

419
00:17:50,650 --> 00:17:52,800

420
00:17:52,800 --> 00:17:53,760
So this is expected.

421
00:17:53,760 --> 00:17:55,080
We have a cache of size five.

422
00:17:55,080 --> 00:17:56,130
We push the button.

423
00:17:56,130 --> 00:17:57,320
We filled the cache.

424
00:17:57,320 --> 00:17:59,810
So this is what we were saying
earlier is that OK, well,

425
00:17:59,810 --> 00:18:00,840
there's no leak here.

426
00:18:00,840 --> 00:18:02,100
We expected to see five.

427
00:18:02,100 --> 00:18:03,140
There's five.

428
00:18:03,140 --> 00:18:05,300
So now we need a third one.

429
00:18:05,300 --> 00:18:06,570
So let's try that again.

430
00:18:06,570 --> 00:18:09,640
Let's do some work
and go ahead and

431
00:18:09,640 --> 00:18:10,890
collect a third snapshot.

432
00:18:10,890 --> 00:18:13,350

433
00:18:13,350 --> 00:18:14,420
Memory is going up.

434
00:18:14,420 --> 00:18:16,800
We are at 1.4 now.

435
00:18:16,800 --> 00:18:25,650
And if we diff with the second
one again, we'll see that

436
00:18:25,650 --> 00:18:26,994
there are--

437
00:18:26,994 --> 00:18:29,630
oops, there we go--

438
00:18:29,630 --> 00:18:31,330
JOHN MCCUTCHAN: Another
five stuff for--

439
00:18:31,330 --> 00:18:31,980
LOREENA LEE: And that's fine.

440
00:18:31,980 --> 00:18:32,800
We allocated five.

441
00:18:32,800 --> 00:18:34,310
But we didn't delete anything.

442
00:18:34,310 --> 00:18:35,780
So, hmm.

443
00:18:35,780 --> 00:18:40,360
So if we look back in the
Summary View here, we'll see

444
00:18:40,360 --> 00:18:45,260
that there are now 10 objects
of type stuff.

445
00:18:45,260 --> 00:18:46,780
JOHN MCCUTCHAN: And this matches
what we saw in the

446
00:18:46,780 --> 00:18:50,310
timeline graph, where we were
never seeing anything go down.

447
00:18:50,310 --> 00:18:53,550
It just kept going up on
a fixed size, seeing

448
00:18:53,550 --> 00:18:55,170
the stair step in.

449
00:18:55,170 --> 00:18:58,450
LOREENA LEE: So another thing
that's great to see now is

450
00:18:58,450 --> 00:19:02,480
that we can go into the
Summary View again.

451
00:19:02,480 --> 00:19:05,950
And we can say, show me the
objects that were allocated

452
00:19:05,950 --> 00:19:08,160
before snapshot one.

453
00:19:08,160 --> 00:19:09,670
And that will show you that.

454
00:19:09,670 --> 00:19:12,400
And there shouldn't be any
stuff in this, because we

455
00:19:12,400 --> 00:19:14,290
hadn't filled any cache.

456
00:19:14,290 --> 00:19:17,120
But now you can say, show
me the objects that were

457
00:19:17,120 --> 00:19:19,490
allocated between snapshots
one and two.

458
00:19:19,490 --> 00:19:21,020
JOHN MCCUTCHAN: So we should
see five stuff.

459
00:19:21,020 --> 00:19:23,150
LOREENA LEE: So we should see
five things that were

460
00:19:23,150 --> 00:19:25,290
allocated between snapshots
one and two.

461
00:19:25,290 --> 00:19:27,630
And those things we expect have
been flushed out of the

462
00:19:27,630 --> 00:19:30,300
cache by the time that we
did the third snapshot.

463
00:19:30,300 --> 00:19:32,660
And so if they're still hanging
around in the heap in

464
00:19:32,660 --> 00:19:35,070
snapshot three, that's probably
our problem here.

465
00:19:35,070 --> 00:19:36,800
JOHN MCCUTCHAN: One thing we
should notice here is that

466
00:19:36,800 --> 00:19:40,090
when we're looking for the
summary of objects allocated

467
00:19:40,090 --> 00:19:44,210
between snapshots one and two,
you can tack on the sentence

468
00:19:44,210 --> 00:19:47,130
that are still alive
at snapshot three.

469
00:19:47,130 --> 00:19:52,180
So from the moment in time that
snapshot three was taken,

470
00:19:52,180 --> 00:19:54,470
these are objects that were
allocated between one and two

471
00:19:54,470 --> 00:19:56,650
that are still alive.

472
00:19:56,650 --> 00:19:59,010
So we should not see any
stuff here, if we

473
00:19:59,010 --> 00:19:59,860
weren't leaking memory.

474
00:19:59,860 --> 00:20:02,100
LOREENA LEE: Correct, exactly.

475
00:20:02,100 --> 00:20:03,560
So we are leaking memory.

476
00:20:03,560 --> 00:20:06,350
And we do see that there are
five objects that were

477
00:20:06,350 --> 00:20:10,130
allocated between subjects one
and two that are still alive

478
00:20:10,130 --> 00:20:11,910
in snapshot three.

479
00:20:11,910 --> 00:20:15,500
So if we go ahead and expand
this, you can see here that

480
00:20:15,500 --> 00:20:18,210
the stuff, we can click
on one of these.

481
00:20:18,210 --> 00:20:20,230
And on the bottom, you'll
see the retaining path.

482
00:20:20,230 --> 00:20:22,990
And it'll tell you that it's
being retained by the object

483
00:20:22,990 --> 00:20:27,880
data, which is in this
HTML div element.

484
00:20:27,880 --> 00:20:30,900
And this helps you figure out
where you're going to go and

485
00:20:30,900 --> 00:20:31,370
fix the problem.

486
00:20:31,370 --> 00:20:34,700
So you can tell exactly where
this is retained from who's

487
00:20:34,700 --> 00:20:36,260
holding on to the
handle from it.

488
00:20:36,260 --> 00:20:38,950
JOHN MCCUTCHAN: So remember the
retaining path is the path

489
00:20:38,950 --> 00:20:42,550
from a garbage collector
root to the variable

490
00:20:42,550 --> 00:20:45,180
that's being held.

491
00:20:45,180 --> 00:20:49,780
LOREENA LEE: So the other thing
to note is, here, none

492
00:20:49,780 --> 00:20:51,320
of these stuffs have
a background

493
00:20:51,320 --> 00:20:53,220
that is colored yellow.

494
00:20:53,220 --> 00:20:59,190
And if we look at the Summary
View with everything that's in

495
00:20:59,190 --> 00:21:02,240
snapshot three, we can
look at stuff.

496
00:21:02,240 --> 00:21:06,530
And we should see that half of
them are yellow and half of

497
00:21:06,530 --> 00:21:07,060
them are not.

498
00:21:07,060 --> 00:21:08,310
JOHN MCCUTCHAN: So why
are they yellow?

499
00:21:08,310 --> 00:21:09,830
LOREENA LEE: So the yellow
background indicates that

500
00:21:09,830 --> 00:21:13,460
there's a JavaScript handle
on this object.

501
00:21:13,460 --> 00:21:17,620
So there's a way to reach this
object through the JavaScript.

502
00:21:17,620 --> 00:21:19,870
And if it's not colored yellow,
there's very likely

503
00:21:19,870 --> 00:21:23,030
not to be a JavaScript handle,
which means you're going to

504
00:21:23,030 --> 00:21:24,360
have a hard time
cleaning it up.

505
00:21:24,360 --> 00:21:25,980
You've probably lost its
reference to it.

506
00:21:25,980 --> 00:21:29,350
It's still on the DOM tree, but
you lost your JavaScript

507
00:21:29,350 --> 00:21:29,930
reference to it.

508
00:21:29,930 --> 00:21:32,670
JOHN MCCUTCHAN: So you could
regain a reference to this by

509
00:21:32,670 --> 00:21:32,790
walking the dog.

510
00:21:32,790 --> 00:21:33,720
LOREENA LEE: By walking the--

511
00:21:33,720 --> 00:21:38,060
right, so it's not like it was
in the previous slides where

512
00:21:38,060 --> 00:21:40,970
we showed you that they were
true garbage that had zero

513
00:21:40,970 --> 00:21:43,240
path to the root
from the root.

514
00:21:43,240 --> 00:21:44,850
So it does have a path from the
root, but there's no way

515
00:21:44,850 --> 00:21:46,150
to access it from JavaScript.

516
00:21:46,150 --> 00:21:49,570
So this is why this is a
JavaScript memory leak and not

517
00:21:49,570 --> 00:21:52,420
necessarily a garbage
collectible leak.

518
00:21:52,420 --> 00:21:54,120
JOHN MCCUTCHAN: So the
yellow indicates

519
00:21:54,120 --> 00:21:55,140
that there is a path.

520
00:21:55,140 --> 00:21:58,580
And white indicates
that there is not.

521
00:21:58,580 --> 00:22:00,775
LOREENA LEE: And not
a JavaScript path.

522
00:22:00,775 --> 00:22:05,050
And if it were true garbage like
we had seen in the graphs

523
00:22:05,050 --> 00:22:08,390
that John presented earlier,
it would be with a red

524
00:22:08,390 --> 00:22:09,140
background.

525
00:22:09,140 --> 00:22:12,090
And those are things that
are in the [INAUDIBLE]

526
00:22:12,090 --> 00:22:12,630
DOM tree.

527
00:22:12,630 --> 00:22:14,680
They cannot be reached from
the root of the DOM node.

528
00:22:14,680 --> 00:22:16,420
But they're being retained
by something.

529
00:22:16,420 --> 00:22:18,840
So a lot of times
in those cases--

530
00:22:18,840 --> 00:22:23,190
and there's some good examples
of this on the dev website

531
00:22:23,190 --> 00:22:24,970
that have them highlighted
in red.

532
00:22:24,970 --> 00:22:27,310
And those are things that are
being retained for some reason

533
00:22:27,310 --> 00:22:29,240
or another.

534
00:22:29,240 --> 00:22:29,400
but.

535
00:22:29,400 --> 00:22:31,650
They're not reachable from
the root of the DOM tree.

536
00:22:31,650 --> 00:22:33,950
And so in those cases, you
should be able to open the

537
00:22:33,950 --> 00:22:34,740
retaining path.

538
00:22:34,740 --> 00:22:36,910
And you should see something
highlighted in yellow, which

539
00:22:36,910 --> 00:22:39,030
says you have a JavaScript
reference to this thing.

540
00:22:39,030 --> 00:22:40,920
But it's not in the
DOM tree at all.

541
00:22:40,920 --> 00:22:42,320
And that should help you.

542
00:22:42,320 --> 00:22:43,530
JOHN MCCUTCHAN: So these
are detached DOM nodes.

543
00:22:43,530 --> 00:22:45,560
LOREENA LEE: Right.

544
00:22:45,560 --> 00:22:48,230
And there's a great example of
that online as well so that we

545
00:22:48,230 --> 00:22:49,330
can go through that.

546
00:22:49,330 --> 00:22:51,730
So I think that's pretty
much the demo.

547
00:22:51,730 --> 00:22:53,820
So we can recap it.

548
00:22:53,820 --> 00:22:57,280
Let's go back to the
slides and recap.

549
00:22:57,280 --> 00:23:01,850

550
00:23:01,850 --> 00:23:03,580
So we presented when Comparison

551
00:23:03,580 --> 00:23:04,700
View just isn't enough.

552
00:23:04,700 --> 00:23:07,750
And we showed that not all
memory leaks result in

553
00:23:07,750 --> 00:23:09,830
detached DOM tree nodes.

554
00:23:09,830 --> 00:23:12,150
There are things like
unintentional unbounded array

555
00:23:12,150 --> 00:23:13,830
growths, so you add things
to an array to

556
00:23:13,830 --> 00:23:14,680
be processed later.

557
00:23:14,680 --> 00:23:16,620
And you forget that you need to
clean it up at some point.

558
00:23:16,620 --> 00:23:19,080
So either you process it and
you never dumped it.

559
00:23:19,080 --> 00:23:21,240
So these kinds of things can
be caught with this three

560
00:23:21,240 --> 00:23:25,310
snapshot technique that
I just presented.

561
00:23:25,310 --> 00:23:26,210
And there's one other case.

562
00:23:26,210 --> 00:23:28,220
That's lingering event handlers
retaining DOM nodes

563
00:23:28,220 --> 00:23:29,620
that are otherwise detached.

564
00:23:29,620 --> 00:23:33,440
And that can be seen in the
scenario that I just

565
00:23:33,440 --> 00:23:35,930
explained, where you would have
something in red with a

566
00:23:35,930 --> 00:23:39,830
retaining path that has some
yellow nodes in it.

567
00:23:39,830 --> 00:23:42,350
And so that's when you would
want to bring out your three

568
00:23:42,350 --> 00:23:43,210
snapshot technique.

569
00:23:43,210 --> 00:23:47,050
JOHN MCCUTCHAN: So these are
some closure function that is

570
00:23:47,050 --> 00:23:49,510
attached as an event list
node to DOM node that

571
00:23:49,510 --> 00:23:50,370
is out of the DOM.

572
00:23:50,370 --> 00:23:51,980
LOREENA LEE: Correct.

573
00:23:51,980 --> 00:23:54,260
And this is just a graphical
representation of

574
00:23:54,260 --> 00:23:56,100
what we just did.

575
00:23:56,100 --> 00:23:58,720
But it's much better to see
that in the dev tools

576
00:23:58,720 --> 00:24:00,870
themselves.

577
00:24:00,870 --> 00:24:02,440
So hopefully this was helpful.

578
00:24:02,440 --> 00:24:03,360
JOHN MCCUTCHAN: Yeah,
I think so.

579
00:24:03,360 --> 00:24:05,142
I learned a lot.

580
00:24:05,142 --> 00:24:07,350
LOREENA LEE: Sounds good.

581
00:24:07,350 --> 00:24:10,330
JOHN MCCUTCHAN: So I think we
have a little bit of time.

582
00:24:10,330 --> 00:24:13,500
So here's a little quiz,
the tale of the

583
00:24:13,500 --> 00:24:15,340
missing object key.

584
00:24:15,340 --> 00:24:17,650
So if we look at the source code
on the slides here, you

585
00:24:17,650 --> 00:24:20,990
see a new object
is constructed.

586
00:24:20,990 --> 00:24:22,844
It's empty.

587
00:24:22,844 --> 00:24:26,750
A key called, double was added
and assigned to double value.

588
00:24:26,750 --> 00:24:30,290
A key called, integer was added
and assigned an integer.

589
00:24:30,290 --> 00:24:32,850
Then when you look at the
object, you can see the key

590
00:24:32,850 --> 00:24:34,260
double and integer are there.

591
00:24:34,260 --> 00:24:36,340
And the two values are there.

592
00:24:36,340 --> 00:24:39,830
So if you were to then take a
heap snapshot and look at the

593
00:24:39,830 --> 00:24:43,740
heap snapshot and find the
object, o, inside the

594
00:24:43,740 --> 00:24:47,770
containment view, you'll notice
that the integer key is

595
00:24:47,770 --> 00:24:49,160
missing from the
heap snapshot.

596
00:24:49,160 --> 00:24:52,030
That seems a little weird,
because we just confirmed that

597
00:24:52,030 --> 00:24:55,740
it is inside o, and it
is in fact inside o.

598
00:24:55,740 --> 00:25:02,600
But what's going on here is that
v8 has some tricks in how

599
00:25:02,600 --> 00:25:04,250
it stores integers.

600
00:25:04,250 --> 00:25:08,350
If the number fits into a signed
31-bit integer, then

601
00:25:08,350 --> 00:25:11,660
it's actually stitched into the
object graph structure and

602
00:25:11,660 --> 00:25:14,720
not actually part of the object
graph, which is kind of

603
00:25:14,720 --> 00:25:15,100
interesting.

604
00:25:15,100 --> 00:25:16,260
So look out for that.

605
00:25:16,260 --> 00:25:18,340
There's also cases
where a property

606
00:25:18,340 --> 00:25:20,150
is backed by a getter.

607
00:25:20,150 --> 00:25:26,410
And so when you do a heap
snapshot, the heap snapshot

608
00:25:26,410 --> 00:25:28,540
can't call the getter because
it might alter the program

609
00:25:28,540 --> 00:25:32,150
state or might be incredibly
expensive to call the getters,

610
00:25:32,150 --> 00:25:34,600
because there could be many
thousands of these objects

611
00:25:34,600 --> 00:25:35,930
with these getters.

612
00:25:35,930 --> 00:25:36,940
It avoids doing that.

613
00:25:36,940 --> 00:25:40,050
So you might see when you take a
heap snapshot that some keys

614
00:25:40,050 --> 00:25:41,640
are missing.

615
00:25:41,640 --> 00:25:42,890
But they're still there.

616
00:25:42,890 --> 00:25:45,830

617
00:25:45,830 --> 00:25:46,940
LOREENA LEE: Good things
to be careful.

618
00:25:46,940 --> 00:25:48,350
JOHN MCCUTCHAN: So thanks a lot
for joining us, Loreena.

619
00:25:48,350 --> 00:25:48,690
LOREENA LEE: No problem.

620
00:25:48,690 --> 00:25:49,210
Thank you.

621
00:25:49,210 --> 00:25:50,692
Thanks for having me.

622
00:25:50,692 --> 00:25:51,120
JOHN MCCUTCHAN: Bye.

623
00:25:51,120 --> 00:25:52,370
LOREENA LEE: Bye, everyone.

624
00:25:52,370 --> 00:26:04,722

