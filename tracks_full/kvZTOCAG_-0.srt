1
00:00:00,000 --> 00:00:00,890

2
00:00:00,890 --> 00:00:02,130
SETH LADD: OK, welcome
everyone.

3
00:00:02,130 --> 00:00:03,820
Thanks very much for coming.

4
00:00:03,820 --> 00:00:07,180
This is What's New with Dart:
Your First-Class Upgrade to

5
00:00:07,180 --> 00:00:08,050
Web Development.

6
00:00:08,050 --> 00:00:08,870
My name is Seth Ladd.

7
00:00:08,870 --> 00:00:11,000
I'm a Developer Advocate
with the Dart team.

8
00:00:11,000 --> 00:00:11,900
JUSTIN FAGNANI: And I'm
Justin Fagnani.

9
00:00:11,900 --> 00:00:13,740
I'm an engineer on the
Dart team working

10
00:00:13,740 --> 00:00:15,000
on tools and libraries.

11
00:00:15,000 --> 00:00:18,680
And I also help internal
teams move to Dart.

12
00:00:18,680 --> 00:00:20,270
SETH LADD: All right, real
quick, what is Dart?

13
00:00:20,270 --> 00:00:21,930
Well, Dart is much more
than a language.

14
00:00:21,930 --> 00:00:24,810
It's also a set of rich
libraries, very productive

15
00:00:24,810 --> 00:00:27,160
tools, fast run-times like
a virtual machine.

16
00:00:27,160 --> 00:00:30,690
But probably most importantly,
Dart compiles the JavaScript.

17
00:00:30,690 --> 00:00:32,850
So you could write a Dart app,
compile it down to modern

18
00:00:32,850 --> 00:00:34,900
JavaScript, and run
it across modern

19
00:00:34,900 --> 00:00:35,960
browsers like this today.

20
00:00:35,960 --> 00:00:37,760
We like to think of Dart
as a batteries

21
00:00:37,760 --> 00:00:40,920
included package for you.

22
00:00:40,920 --> 00:00:43,520
OK, so this is a real-life story
from a developer just

23
00:00:43,520 --> 00:00:44,200
like you guys out there.

24
00:00:44,200 --> 00:00:44,900
He works for a bank.

25
00:00:44,900 --> 00:00:46,870
He has to write a
lot of web apps.

26
00:00:46,870 --> 00:00:47,860
So he's telling me.

27
00:00:47,860 --> 00:00:48,650
This is true.

28
00:00:48,650 --> 00:00:50,630
He's saying, OK, the other day I
was asked to build a new web

29
00:00:50,630 --> 00:00:52,490
app for my internal customers.

30
00:00:52,490 --> 00:00:55,000
So hi, I want to build
a web app.

31
00:00:55,000 --> 00:00:58,560
First off, you need to go get
require.js because you need

32
00:00:58,560 --> 00:00:59,770
some sense of modularity.

33
00:00:59,770 --> 00:01:02,770
He needed to get Backbone
because he needs some sense of

34
00:01:02,770 --> 00:01:04,569
client-side infrastructure.

35
00:01:04,569 --> 00:01:06,250
He needed to get Backbone
Marionette because, of course,

36
00:01:06,250 --> 00:01:08,170
he needs some extra
functionality.

37
00:01:08,170 --> 00:01:10,100
He needed to get jQuery
because every web

38
00:01:10,100 --> 00:01:11,310
project uses jQuery.

39
00:01:11,310 --> 00:01:14,000
Whether you like it or not,
somebody uses it.

40
00:01:14,000 --> 00:01:16,130
He needed to get Modernizr
because he needed to do

41
00:01:16,130 --> 00:01:17,210
feature detection.

42
00:01:17,210 --> 00:01:20,760
He needed to get moment.js
because he needed to deal with

43
00:01:20,760 --> 00:01:22,620
dates, parsing dates,
formatting dates.

44
00:01:22,620 --> 00:01:24,620
He needed to then get dest
templates because he needed

45
00:01:24,620 --> 00:01:28,040
some solution for client-side
templates.

46
00:01:28,040 --> 00:01:30,160
He needed to get PhantomJS
because he needed some sense

47
00:01:30,160 --> 00:01:32,330
of browser-based testing.

48
00:01:32,330 --> 00:01:34,000
Then he needed to get Jasmine
because he needed to actually

49
00:01:34,000 --> 00:01:35,530
write those tests.

50
00:01:35,530 --> 00:01:38,090
Then when he's got this
teetering pile here, of course

51
00:01:38,090 --> 00:01:39,960
then he finds out that every
one of these projects has a

52
00:01:39,960 --> 00:01:41,800
completely different set
of formatted docs.

53
00:01:41,800 --> 00:01:43,810
So you got to find those
and read those and

54
00:01:43,810 --> 00:01:45,190
figure those out.

55
00:01:45,190 --> 00:01:48,180
And then, he needed to finally
integrate this entire pile

56
00:01:48,180 --> 00:01:50,750
here to make some semblance
of a working system.

57
00:01:50,750 --> 00:01:53,350
An interesting thing here
though, is that not only do

58
00:01:53,350 --> 00:01:54,600
you actually have to wire
it all together.

59
00:01:54,600 --> 00:01:57,710
But some of these solutions
offer duplicate answers to the

60
00:01:57,710 --> 00:01:58,310
same problem.

61
00:01:58,310 --> 00:01:59,690
So you've got to
reconcile that.

62
00:01:59,690 --> 00:02:03,770
So after he built this kind of
teetering pile here, quote, "I

63
00:02:03,770 --> 00:02:06,750
just want to build web apps."

64
00:02:06,750 --> 00:02:09,449
So then he found the Dart
project-- true story.

65
00:02:09,449 --> 00:02:12,260
He was able to replace the
teetering pile with simply

66
00:02:12,260 --> 00:02:16,100
just the Dart SDK and three
packages that he could just

67
00:02:16,100 --> 00:02:17,440
download with our
package manager.

68
00:02:17,440 --> 00:02:20,500
And quote, "Thanks to Dart,
things are consistent and

69
00:02:20,500 --> 00:02:21,290
clear."

70
00:02:21,290 --> 00:02:23,540
So this is a good example of a
real-life story of a small

71
00:02:23,540 --> 00:02:25,890
team, a team that needs to
move fast, and their

72
00:02:25,890 --> 00:02:26,910
experience using Dart.

73
00:02:26,910 --> 00:02:29,260
But that's an external
small team.

74
00:02:29,260 --> 00:02:31,610
Justin, how's our internal
teams doing?

75
00:02:31,610 --> 00:02:33,600
JUSTIN FAGNANI: So like I
mentioned, I help internal

76
00:02:33,600 --> 00:02:35,280
teams adopt Dart.

77
00:02:35,280 --> 00:02:38,970
And at Google, we build
a few web apps.

78
00:02:38,970 --> 00:02:40,880
And some of them
are quite big.

79
00:02:40,880 --> 00:02:43,700
To give you an idea of how big
they are, our teams can be

80
00:02:43,700 --> 00:02:45,630
from dozens to hundreds
of engineers.

81
00:02:45,630 --> 00:02:48,420
And we can easily have millions
of lines of code.

82
00:02:48,420 --> 00:02:50,910
And over the years, our
engineers have determined that

83
00:02:50,910 --> 00:02:53,100
they need tools to help them
manage this complexity.

84
00:02:53,100 --> 00:02:55,630
And basically, maintain their
sanity to be able to work with

85
00:02:55,630 --> 00:02:58,070
such large amounts of
code in large teams.

86
00:02:58,070 --> 00:03:01,120
So they've built tools like
GWT and Closure and Soy.

87
00:03:01,120 --> 00:03:05,500
And these tools do different
things to help them guarantee

88
00:03:05,500 --> 00:03:07,540
correctness and behavior
of the applications.

89
00:03:07,540 --> 00:03:10,820
They introduce modularity
and structure, classes.

90
00:03:10,820 --> 00:03:12,190
Maybe some type checking.

91
00:03:12,190 --> 00:03:15,580
GWT introduces Java as
the source language.

92
00:03:15,580 --> 00:03:17,510
And these tools have been very
successful in that they help

93
00:03:17,510 --> 00:03:20,070
teams write these complex
apps and actually get

94
00:03:20,070 --> 00:03:21,220
them out the door.

95
00:03:21,220 --> 00:03:23,370
But they have some downsides.

96
00:03:23,370 --> 00:03:26,770
In particular, all JavaScript
at Google is compiled.

97
00:03:26,770 --> 00:03:29,450
And this means that we've
introduced a compiler into the

98
00:03:29,450 --> 00:03:30,800
development workflow.

99
00:03:30,800 --> 00:03:33,750
And that can significantly
slow things down.

100
00:03:33,750 --> 00:03:36,620
With these large apps, the
compilers can take a long time

101
00:03:36,620 --> 00:03:40,190
to run while you're trying
to develop your app.

102
00:03:40,190 --> 00:03:43,300
So we've started moving
some teams to Dart.

103
00:03:43,300 --> 00:03:46,280
And with Dart, we tried
to fix that problem.

104
00:03:46,280 --> 00:03:48,730
SETH LADD: I want to point out
real quick that this is real

105
00:03:48,730 --> 00:03:49,820
feedback from internal teams.

106
00:03:49,820 --> 00:03:52,320
24 minutes, sometimes,
to see a change.

107
00:03:52,320 --> 00:03:55,230
Can you imagine iterating at
24-minutes per change?

108
00:03:55,230 --> 00:03:56,260
JUSTIN FAGNANI: I've
done that.

109
00:03:56,260 --> 00:03:57,125
SETH LADD: Surely
we can better.

110
00:03:57,125 --> 00:03:57,410
JUSTIN FAGNANI: Right.

111
00:03:57,410 --> 00:03:59,660
So surely we could do better.

112
00:03:59,660 --> 00:04:02,670
So what we've done with Dart
is we've tried to address

113
00:04:02,670 --> 00:04:03,190
these issues.

114
00:04:03,190 --> 00:04:06,260
To fix some of the problems
with the structure and the

115
00:04:06,260 --> 00:04:10,000
semantics of the language, but
also not have the downsides.

116
00:04:10,000 --> 00:04:12,740
So here we have a chart that
kind of shows some different

117
00:04:12,740 --> 00:04:14,140
projects out there
that are compiled

118
00:04:14,140 --> 00:04:15,570
to JavaScript projects.

119
00:04:15,570 --> 00:04:18,029
So we have GWT and
Closure here.

120
00:04:18,029 --> 00:04:19,529
I'm sure you guys have heard
of CoffeeScript.

121
00:04:19,529 --> 00:04:22,130
And also, Microsoft has their
own compile to JS project

122
00:04:22,130 --> 00:04:23,330
called TypeScript.

123
00:04:23,330 --> 00:04:25,670
And we've kind of roughly said
whether or not they hurt and

124
00:04:25,670 --> 00:04:28,000
help on these different
dimensions.

125
00:04:28,000 --> 00:04:30,640
And we feel like Dart is finally
a solution that we

126
00:04:30,640 --> 00:04:32,240
have that helps on
every dimension.

127
00:04:32,240 --> 00:04:34,880
It actually improves the
development cycle, while also

128
00:04:34,880 --> 00:04:38,340
giving teams the safety and
semantic improvements that

129
00:04:38,340 --> 00:04:38,670
they require.

130
00:04:38,670 --> 00:04:39,680
SETH LADD: One thing I want
to point out on this slide

131
00:04:39,680 --> 00:04:41,200
actually, I think it's really
important to understand this

132
00:04:41,200 --> 00:04:43,090
requires compilation
for development.

133
00:04:43,090 --> 00:04:46,870
Notice how Dart does not require
compilation for your

134
00:04:46,870 --> 00:04:48,510
very fast iteration development
cycles.

135
00:04:48,510 --> 00:04:52,420
We'll see how we make that
possible in a little bit.

136
00:04:52,420 --> 00:04:53,120
OK, cool.

137
00:04:53,120 --> 00:04:55,690
So before we jump into all the
what's new across the whole

138
00:04:55,690 --> 00:04:56,380
Dart platform--

139
00:04:56,380 --> 00:04:58,210
and there's a lot-- we want to
give you a quick lightning

140
00:04:58,210 --> 00:05:01,210
tour across the syntax,
semantics, and structure that

141
00:05:01,210 --> 00:05:03,470
Dart offers so we can show you
a bunch of code samples

142
00:05:03,470 --> 00:05:04,980
throughout the talk.

143
00:05:04,980 --> 00:05:06,230
Let's start with the syntax.

144
00:05:06,230 --> 00:05:08,150
First up, very familiar
classes,

145
00:05:08,150 --> 00:05:09,830
semicolons, curly braces.

146
00:05:09,830 --> 00:05:11,470
I think everyone can
read this code.

147
00:05:11,470 --> 00:05:12,240
Dart's very terse.

148
00:05:12,240 --> 00:05:14,150
We like to say it's
ceremony free.

149
00:05:14,150 --> 00:05:15,360
Here's a good example here.

150
00:05:15,360 --> 00:05:17,340
What do you always do in
constructors, but this.x

151
00:05:17,340 --> 00:05:19,580
equals x, this.y equals
y, et cetera.

152
00:05:19,580 --> 00:05:20,930
This is getting boring.

153
00:05:20,930 --> 00:05:23,990
So instead you can say if the
constructor parameter name is

154
00:05:23,990 --> 00:05:27,030
the same as the name of the
field, you can simply say

155
00:05:27,030 --> 00:05:28,960
this.strength here
in this case.

156
00:05:28,960 --> 00:05:31,120
Eliminates some of the ceremony
or boilerplate that

157
00:05:31,120 --> 00:05:33,800
you typically have in
other languages.

158
00:05:33,800 --> 00:05:35,980
Name constructors, one of my
favorite features here.

159
00:05:35,980 --> 00:05:37,310
Obviously, methods you
can name pretty much

160
00:05:37,310 --> 00:05:38,170
whatever you want.

161
00:05:38,170 --> 00:05:40,240
But constructors, typically,
are always named

162
00:05:40,240 --> 00:05:41,110
the name of the class.

163
00:05:41,110 --> 00:05:43,160
That's a little bit
constraining, so Dart offers

164
00:05:43,160 --> 00:05:43,930
name constructors.

165
00:05:43,930 --> 00:05:47,790
Here, I can say new hug.bear
and set up a bear hug.

166
00:05:47,790 --> 00:05:49,190
It's very clear.

167
00:05:49,190 --> 00:05:51,760
I totally understand what I'm
creating when I use these name

168
00:05:51,760 --> 00:05:53,730
constructors.

169
00:05:53,730 --> 00:05:55,110
Dart has operator overriding.

170
00:05:55,110 --> 00:05:58,050
Here's a good example of that.

171
00:05:58,050 --> 00:06:00,430
Named, optional parameters,
another one of my favorite

172
00:06:00,430 --> 00:06:00,990
features here.

173
00:06:00,990 --> 00:06:03,310
So the curly braces here turn
on a couple things.

174
00:06:03,310 --> 00:06:05,050
First, this becomes an
optional parameter.

175
00:06:05,050 --> 00:06:07,230
So you may or may not--
or you can or cannot

176
00:06:07,230 --> 00:06:08,950
pass a parameter there.

177
00:06:08,950 --> 00:06:11,610
It's name that I understand
what this number is.

178
00:06:11,610 --> 00:06:12,660
So hands.

179
00:06:12,660 --> 00:06:14,870
And I get a default
value of one.

180
00:06:14,870 --> 00:06:17,670
So again, features that normal
scripting languages have, Dart

181
00:06:17,670 --> 00:06:19,930
has as well.

182
00:06:19,930 --> 00:06:21,420
Some of my other favorite
features here-- fat arrow

183
00:06:21,420 --> 00:06:24,820
syntax for your simple one-line
functions here.

184
00:06:24,820 --> 00:06:27,580
This is just syntactic sugar
for curly brace return

185
00:06:27,580 --> 00:06:29,000
expression curly brace.

186
00:06:29,000 --> 00:06:32,150
Dart uses one-line functions
a lot, especially in inline

187
00:06:32,150 --> 00:06:33,420
anonymous functions.

188
00:06:33,420 --> 00:06:35,200
So they're really
useful there.

189
00:06:35,200 --> 00:06:37,090
And finally, string
interpolation.

190
00:06:37,090 --> 00:06:40,860
A very simple way to build up
strings based on variables or

191
00:06:40,860 --> 00:06:42,110
expressions.

192
00:06:42,110 --> 00:06:43,850

193
00:06:43,850 --> 00:06:47,650
JUSTIN FAGNANI: OK, but Dart
isn't all just syntax

194
00:06:47,650 --> 00:06:48,550
improvements.

195
00:06:48,550 --> 00:06:51,000
Dart is its own language and
it has its own semantics.

196
00:06:51,000 --> 00:06:53,620
And I'm sure some of you have
heard of the JavaScript wats

197
00:06:53,620 --> 00:06:55,400
out there, or these surprising
moments.

198
00:06:55,400 --> 00:06:55,740
Wat.

199
00:06:55,740 --> 00:06:56,530
SETH LADD: Wat.

200
00:06:56,530 --> 00:06:57,530
JUSTIN FAGNANI: In JavaScript.

201
00:06:57,530 --> 00:06:58,960
Or the Java puzzlers.

202
00:06:58,960 --> 00:07:01,460
So these are confusing
parts of the language

203
00:07:01,460 --> 00:07:02,510
we're familiar with.

204
00:07:02,510 --> 00:07:05,490
And we try to improve on that,
too, and turn our wats into

205
00:07:05,490 --> 00:07:08,260
some kind of atomic rock
dinosaur thing.

206
00:07:08,260 --> 00:07:09,490
But awesomeness in general.

207
00:07:09,490 --> 00:07:10,510
SETH LADD: I want the
one on the right.

208
00:07:10,510 --> 00:07:11,110
JUSTIN FAGNANI: Yes, me too.

209
00:07:11,110 --> 00:07:13,214
It looks more fun.

210
00:07:13,214 --> 00:07:13,980
SETH LADD: That one's scary.

211
00:07:13,980 --> 00:07:14,230
JUSTIN FAGNANI: OK.

212
00:07:14,230 --> 00:07:16,300
Some examples of semantic
improvements.

213
00:07:16,300 --> 00:07:18,450
Just real quick, only
true is truthy.

214
00:07:18,450 --> 00:07:20,840
So you don't have to guess what
values are going to be

215
00:07:20,840 --> 00:07:21,630
true or false.

216
00:07:21,630 --> 00:07:23,860
Basically, true is true, false
is false, and everything else

217
00:07:23,860 --> 00:07:25,830
is what it is.

218
00:07:25,830 --> 00:07:26,890
We got rid of undefined.

219
00:07:26,890 --> 00:07:28,390
There's only null.

220
00:07:28,390 --> 00:07:29,750
That fixes a lot of problems.

221
00:07:29,750 --> 00:07:33,450
There's no type coercion with
equalities checks or operators

222
00:07:33,450 --> 00:07:34,270
or other things like that.

223
00:07:34,270 --> 00:07:37,720
So the language is more
predictable in a lot of ways.

224
00:07:37,720 --> 00:07:39,580
Some other examples.

225
00:07:39,580 --> 00:07:43,430
So in JavaScript, if you access
a property that isn't

226
00:07:43,430 --> 00:07:47,950
available on an object, you
will get undefined.

227
00:07:47,950 --> 00:07:48,950
So that can be a problem.

228
00:07:48,950 --> 00:07:50,960
If you have a typo, you don't
necessarily know it.

229
00:07:50,960 --> 00:07:52,610
You just get an undefined
value.

230
00:07:52,610 --> 00:07:54,120
So in Dart, we changed this.

231
00:07:54,120 --> 00:07:54,670
We fixed it.

232
00:07:54,670 --> 00:07:55,950
And what do you think
happens here, Seth?

233
00:07:55,950 --> 00:07:57,240
SETH LADD: Well, hopefully a
clear and consistent and

234
00:07:57,240 --> 00:07:58,370
logical error.

235
00:07:58,370 --> 00:08:00,830
JUSTIN FAGNANI: Well, that's
exactly right.

236
00:08:00,830 --> 00:08:04,070
If you access a missing property
on an object in Dart,

237
00:08:04,070 --> 00:08:06,830
you get a NoSuchMethodError
because Dart knows it doesn't

238
00:08:06,830 --> 00:08:09,310
exist because it wasn't
declared.

239
00:08:09,310 --> 00:08:10,370
Let's look at list access.

240
00:08:10,370 --> 00:08:13,800
So here we have an empty list
and we're accessing the 99th

241
00:08:13,800 --> 00:08:14,910
element of an empty list.

242
00:08:14,910 --> 00:08:17,150
So we're way out of range.

243
00:08:17,150 --> 00:08:18,250
What do you think happens
here, Seth?

244
00:08:18,250 --> 00:08:19,070
SETH LADD: Hopefully
a clear and

245
00:08:19,070 --> 00:08:20,540
consistent and logical error.

246
00:08:20,540 --> 00:08:21,040
JUSTIN FAGNANI: Amazing.

247
00:08:21,040 --> 00:08:22,200
You're right again.

248
00:08:22,200 --> 00:08:24,520
Here, you get a range error,
like you would expect.

249
00:08:24,520 --> 00:08:27,860
This has a number of benefits
to your program and the VM.

250
00:08:27,860 --> 00:08:29,720
Next, let's talk about scope.

251
00:08:29,720 --> 00:08:33,100
So JavaScript, as you might
know, has function scope.

252
00:08:33,100 --> 00:08:35,960
And it hoists the function
declarations to

253
00:08:35,960 --> 00:08:37,309
the top of the function.

254
00:08:37,309 --> 00:08:41,100
So here we have two variables
with the same name "foo." One

255
00:08:41,100 --> 00:08:43,760
of them is a top-level scope and
the other one is inside of

256
00:08:43,760 --> 00:08:46,160
this block here, inside
the if statement.

257
00:08:46,160 --> 00:08:49,140
So when we print foo here, how
do we know which one is going

258
00:08:49,140 --> 00:08:50,160
to be printed?

259
00:08:50,160 --> 00:08:52,800
Well, so we call this method
here and it's going to print

260
00:08:52,800 --> 00:08:53,260
something, Seth.

261
00:08:53,260 --> 00:08:54,110
What do you think it prints?

262
00:08:54,110 --> 00:08:56,020
SETH LADD: Hopefully, due
to the logical static

263
00:08:56,020 --> 00:08:56,310
[? analysis ?]

264
00:08:56,310 --> 00:08:58,650
I can do with my own eyes
here, top-level.

265
00:08:58,650 --> 00:09:00,200
JUSTIN FAGNANI: Seth
is a ringer.

266
00:09:00,200 --> 00:09:02,390
Yes, it does print top-level.

267
00:09:02,390 --> 00:09:06,380
So these things are less
confusing, less surprising and

268
00:09:06,380 --> 00:09:08,360
better for development.

269
00:09:08,360 --> 00:09:09,130
This also.

270
00:09:09,130 --> 00:09:10,910
So we have lexically
scoped this.

271
00:09:10,910 --> 00:09:13,590
This is bound to a
lexical scope.

272
00:09:13,590 --> 00:09:16,050
You always know what this
is going to refer to.

273
00:09:16,050 --> 00:09:19,810
In DOM programming, for example,
the "this" pointer of

274
00:09:19,810 --> 00:09:22,340
an event handler actually refers
to the function that's

275
00:09:22,340 --> 00:09:24,930
the event handler, not the
object that you're in when you

276
00:09:24,930 --> 00:09:25,770
define that function.

277
00:09:25,770 --> 00:09:28,580
And there's libraries that
try to fix this.

278
00:09:28,580 --> 00:09:30,370
But in Dart, we've just gone
ahead and fixed it for you.

279
00:09:30,370 --> 00:09:34,320
So in this case, this refers
to our instance of awesome

280
00:09:34,320 --> 00:09:35,420
button and it calls
the right method.

281
00:09:35,420 --> 00:09:38,700
And it's just very
unsurprising.

282
00:09:38,700 --> 00:09:40,490
SETH LADD: OK, so that
was the syntax, a

283
00:09:40,490 --> 00:09:41,550
little bit of the semantics.

284
00:09:41,550 --> 00:09:42,760
Let's talk about
the structure.

285
00:09:42,760 --> 00:09:45,030
Now, we've seen functions and
classes, and we'll see some of

286
00:09:45,030 --> 00:09:47,120
these other features like
mixins in a little bit.

287
00:09:47,120 --> 00:09:48,410
So let's talk about libraries.

288
00:09:48,410 --> 00:09:51,360
Dart has a really nice way to
bunch up your code into

289
00:09:51,360 --> 00:09:52,630
reusable chunks we
call libraries.

290
00:09:52,630 --> 00:09:54,030
Here's an example here.

291
00:09:54,030 --> 00:09:55,190
This is a single file.

292
00:09:55,190 --> 00:09:57,700
You simply declare that a file
is a library using library

293
00:09:57,700 --> 00:09:59,180
games here in this case.

294
00:09:59,180 --> 00:10:00,970
You can import other
libraries.

295
00:10:00,970 --> 00:10:03,440
Dart:math comes from
the Dart SDK.

296
00:10:03,440 --> 00:10:06,060
players.dart is another Dart
file, so we can pull in other

297
00:10:06,060 --> 00:10:07,900
files as libraries as well.

298
00:10:07,900 --> 00:10:11,080
And a feature I really like is
you can put, say, multiple

299
00:10:11,080 --> 00:10:14,350
classes, top-level functions
all in the same file.

300
00:10:14,350 --> 00:10:16,670
So it gives you a very flexible
way to organize not

301
00:10:16,670 --> 00:10:18,200
only just where you want
to put your classes and

302
00:10:18,200 --> 00:10:21,100
functions, but also how you want
to structure them on the

303
00:10:21,100 --> 00:10:21,650
file system.

304
00:10:21,650 --> 00:10:23,270
But everything falls
inside a library.

305
00:10:23,270 --> 00:10:24,950
You can then import them
and reuse them.

306
00:10:24,950 --> 00:10:27,520

307
00:10:27,520 --> 00:10:29,360
OK, that was a lightning tour.

308
00:10:29,360 --> 00:10:31,020
Let's look at some
of what's new.

309
00:10:31,020 --> 00:10:33,610
We'll start with the language.

310
00:10:33,610 --> 00:10:36,260
All right, here's a common thing
that you always do, say,

311
00:10:36,260 --> 00:10:37,552
working with a DOM.

312
00:10:37,552 --> 00:10:40,330
You want to create a new button
and set up the state of

313
00:10:40,330 --> 00:10:41,000
that button--

314
00:10:41,000 --> 00:10:43,660
ID, text, classes,
click handlers.

315
00:10:43,660 --> 00:10:44,720
Well, in this particular
case, I've

316
00:10:44,720 --> 00:10:46,680
repeated button six times.

317
00:10:46,680 --> 00:10:47,700
That's a lot.

318
00:10:47,700 --> 00:10:50,450
Well, taking a cue from
Smalltalk, we've introduced

319
00:10:50,450 --> 00:10:51,760
method cascades.

320
00:10:51,760 --> 00:10:54,370
And in this example here, I've
eliminate the repetition of

321
00:10:54,370 --> 00:10:56,590
the variable button.

322
00:10:56,590 --> 00:10:57,950
See the double dots here?

323
00:10:57,950 --> 00:11:00,470
All of these expressions are
applied to this very first

324
00:11:00,470 --> 00:11:02,710
expression here new
ButtonElement.

325
00:11:02,710 --> 00:11:06,170
I've eliminated most of the
occurrences of button here.

326
00:11:06,170 --> 00:11:07,590
I like this for builder
type APIs.

327
00:11:07,590 --> 00:11:10,010
It makes it just more
clear and concise.

328
00:11:10,010 --> 00:11:12,800
But we can do a little bit
better, because all of these

329
00:11:12,800 --> 00:11:16,010
different cascades roll up to
this first expression here.

330
00:11:16,010 --> 00:11:18,150
I can actually eliminate
the need to

331
00:11:18,150 --> 00:11:20,070
introduce a new variable.

332
00:11:20,070 --> 00:11:23,120
So here you can see I can add
this new button element to the

333
00:11:23,120 --> 00:11:25,620
children of this parent element
and initialize its

334
00:11:25,620 --> 00:11:27,920
state all within the
same call here.

335
00:11:27,920 --> 00:11:29,270
This is really--

336
00:11:29,270 --> 00:11:32,130
JUSTIN FAGNANI: One great thing
about this is that it

337
00:11:32,130 --> 00:11:33,560
turns every API into
a builder API.

338
00:11:33,560 --> 00:11:35,680
So you don't have to
preemptively return this from

339
00:11:35,680 --> 00:11:37,920
all your methods in order
to have a fluent API.

340
00:11:37,920 --> 00:11:40,670
In Dart, every API becomes
fluent and it's universal

341
00:11:40,670 --> 00:11:41,920
across the board
and consistent.

342
00:11:41,920 --> 00:11:45,190

343
00:11:45,190 --> 00:11:45,860
OK.

344
00:11:45,860 --> 00:11:48,330
So let's talk about another
great new language feature

345
00:11:48,330 --> 00:11:49,890
called mixins.

346
00:11:49,890 --> 00:11:54,090
So mixin is something that
languages, like Newspeak and

347
00:11:54,090 --> 00:11:57,880
Smalltalk have, and it's a way
to share code without using

348
00:11:57,880 --> 00:11:58,640
inheritance.

349
00:11:58,640 --> 00:12:00,840
You might be familiar with the
maxim, composition over

350
00:12:00,840 --> 00:12:02,170
inheritance.

351
00:12:02,170 --> 00:12:04,100
And the idea is that there's
problems if you try to share

352
00:12:04,100 --> 00:12:05,940
code exclusively through
inheritance.

353
00:12:05,940 --> 00:12:07,400
You can only have
one super-class.

354
00:12:07,400 --> 00:12:10,020
So it might not be a class you
actually want to extend.

355
00:12:10,020 --> 00:12:12,270
So in the last year, Dart's
added mixins.

356
00:12:12,270 --> 00:12:15,000
And let's take our hug example
from before and let's say we

357
00:12:15,000 --> 00:12:16,930
want to save it to a database.

358
00:12:16,930 --> 00:12:18,990
A typical solution to this is
you extend some kind of

359
00:12:18,990 --> 00:12:21,010
persistable base class.

360
00:12:21,010 --> 00:12:21,800
But that has a lot
of problems.

361
00:12:21,800 --> 00:12:24,080
You might want to extend some
other class, actually.

362
00:12:24,080 --> 00:12:26,510
So what you're interested in
here is the behavior, not

363
00:12:26,510 --> 00:12:28,950
necessarily the inheritance
hierarchy.

364
00:12:28,950 --> 00:12:31,660
Hug is not actually
a persistable.

365
00:12:31,660 --> 00:12:33,530
It has the persistable
behavior.

366
00:12:33,530 --> 00:12:35,750
So you don't want to pollute
your inheritance tree.

367
00:12:35,750 --> 00:12:38,430
Instead, what you want to do
is just add this behavior.

368
00:12:38,430 --> 00:12:40,790
You want to compose it or slide
it in from the side--

369
00:12:40,790 --> 00:12:42,490
the persistable behavior.

370
00:12:42,490 --> 00:12:44,080
So what does this look like?

371
00:12:44,080 --> 00:12:48,070
Well, up top here we have our
abstract class persistable.

372
00:12:48,070 --> 00:12:50,890
And in save and load, we defined
the behavior we want,

373
00:12:50,890 --> 00:12:53,430
the implementations in the
dot, dot, dots there.

374
00:12:53,430 --> 00:12:56,250
And we require that classes
that implement persistable

375
00:12:56,250 --> 00:12:57,740
implement this toJson method.

376
00:12:57,740 --> 00:13:00,000
Once they do that, save and load
can use that method in

377
00:13:00,000 --> 00:13:01,980
order to implement
their behavior.

378
00:13:01,980 --> 00:13:04,840
So down here in our hug class,
we're going to use the brand

379
00:13:04,840 --> 00:13:07,490
new keyboard with to say that we
want to mix in the behavior

380
00:13:07,490 --> 00:13:09,810
from persistable into
our hug class.

381
00:13:09,810 --> 00:13:12,130
And then you'll notice that we
define that toJson class,

382
00:13:12,130 --> 00:13:13,860
which is used by the
other methods.

383
00:13:13,860 --> 00:13:16,230
And in the bottom here, you can
see that we call the save

384
00:13:16,230 --> 00:13:18,120
method that's been
added to hug.

385
00:13:18,120 --> 00:13:20,810
It's not inheritance and it
behaves as you would expect.

386
00:13:20,810 --> 00:13:24,510
So this is a great way to
compose classes together.

387
00:13:24,510 --> 00:13:26,790
You also notice that persistable
is just a class.

388
00:13:26,790 --> 00:13:28,870
We don't have a mixin keyword.

389
00:13:28,870 --> 00:13:30,410
So that's just a few
restrictions.

390
00:13:30,410 --> 00:13:32,270
If your class extends object
and it doesn't have a

391
00:13:32,270 --> 00:13:35,290
constructor, then you can
use it as a mixin.

392
00:13:35,290 --> 00:13:37,740
And some of these restrictions
might go away over time.

393
00:13:37,740 --> 00:13:40,572

394
00:13:40,572 --> 00:13:43,406
Oh, we had animations.

395
00:13:43,406 --> 00:13:43,850
All right.

396
00:13:43,850 --> 00:13:46,540
SETH LADD: Another new
feature are metadata.

397
00:13:46,540 --> 00:13:47,540
Here's a good example.

398
00:13:47,540 --> 00:13:51,160
You can use metadata with the
at symbol here, @deprecated.

399
00:13:51,160 --> 00:13:53,730
And that gives really good
feedback to, say, tools.

400
00:13:53,730 --> 00:13:56,110
In this case, the Dart Editor,
he can look at @deprecated,

401
00:13:56,110 --> 00:13:58,760
and then visually indicate the
functions or methods that are

402
00:13:58,760 --> 00:14:00,250
deprecated.

403
00:14:00,250 --> 00:14:02,990
The nice thing about metadata
in Dart though, is you can

404
00:14:02,990 --> 00:14:04,500
define your own metadata.

405
00:14:04,500 --> 00:14:06,340
Here's a good example of an
in-progress feature we're

406
00:14:06,340 --> 00:14:09,730
working on, lazy load libraries,
that uses const

407
00:14:09,730 --> 00:14:12,090
objects as metadata
annotations.

408
00:14:12,090 --> 00:14:14,040
Let's try to walk through
some of this code.

409
00:14:14,040 --> 00:14:15,950
So first we're going to declare
that the library

410
00:14:15,950 --> 00:14:17,090
itself is deferred.

411
00:14:17,090 --> 00:14:20,230
We're creating a const
object, const lazy.

412
00:14:20,230 --> 00:14:22,690
We can then use that lazy
const object to mark the

413
00:14:22,690 --> 00:14:26,260
import as lazy as shown here.

414
00:14:26,260 --> 00:14:29,710
Then, we can call load on that
lazy const object, the

415
00:14:29,710 --> 00:14:32,350
deferred library, and use a
Future to wait for that

416
00:14:32,350 --> 00:14:33,880
library to finish loading.

417
00:14:33,880 --> 00:14:36,930
Then, we can use the features
and functionality from that

418
00:14:36,930 --> 00:14:40,630
library inside of the future.

419
00:14:40,630 --> 00:14:44,740
Now, our tools can read these
metadata annotations here and

420
00:14:44,740 --> 00:14:48,190
say, take in Dart applications
spread across multiple files.

421
00:14:48,190 --> 00:14:50,840
Pipe them through dart2js,
which can look for these

422
00:14:50,840 --> 00:14:53,740
metadata annotations and spit
out a single JavaScript file

423
00:14:53,740 --> 00:14:54,810
for the bulk of the app.

424
00:14:54,810 --> 00:14:56,540
And then, another JavaScript
file for

425
00:14:56,540 --> 00:14:58,180
that lazy loaded library.

426
00:14:58,180 --> 00:15:01,200
This is a great deployment time
tool for you to choose

427
00:15:01,200 --> 00:15:03,510
how and when you want to load in
the different components of

428
00:15:03,510 --> 00:15:04,760
your application.

429
00:15:04,760 --> 00:15:06,960

430
00:15:06,960 --> 00:15:09,090
JUSTIN FAGNANI: OK, so that's
what's new in the language.

431
00:15:09,090 --> 00:15:10,450
Let's talk next about
the libraries.

432
00:15:10,450 --> 00:15:13,050
There's been a lot of great
developments in the last year.

433
00:15:13,050 --> 00:15:15,530
First, let's talk about the
number one question that we

434
00:15:15,530 --> 00:15:17,990
get asked with Dart
is, can I use

435
00:15:17,990 --> 00:15:19,330
existing JavaScript libraries?

436
00:15:19,330 --> 00:15:21,220
Can I integrate with JavaScript
in some way?

437
00:15:21,220 --> 00:15:22,670
And the answer is yes.

438
00:15:22,670 --> 00:15:25,860
We do this through our
JavaScript interop package.

439
00:15:25,860 --> 00:15:29,030
Now, Dart can exist in two
different worlds, really.

440
00:15:29,030 --> 00:15:31,030
We have this Dart to JS world,
where everything is compiled

441
00:15:31,030 --> 00:15:32,070
to JavaScript.

442
00:15:32,070 --> 00:15:34,360
And also, in Dartium, we have
a world where there's two

443
00:15:34,360 --> 00:15:35,900
different VMs.

444
00:15:35,900 --> 00:15:38,560
And so you don't always have
direct access to the objects.

445
00:15:38,560 --> 00:15:40,770
So the way JavaScript interop
works is that

446
00:15:40,770 --> 00:15:41,890
we use proxy objects.

447
00:15:41,890 --> 00:15:43,950
And these proxy objects
represent an object that's in

448
00:15:43,950 --> 00:15:45,400
the other environment.

449
00:15:45,400 --> 00:15:47,040
And the calls are forwarded,
data is

450
00:15:47,040 --> 00:15:49,900
serialized as necessary.

451
00:15:49,900 --> 00:15:51,030
So let's show an example.

452
00:15:51,030 --> 00:15:54,840
So here we're using the JS
package with the prefix js.

453
00:15:54,840 --> 00:15:57,760
We have code up top in Dart and
down below in JavaScript.

454
00:15:57,760 --> 00:16:00,710
And we're going to use an
imaginary charts API.

455
00:16:00,710 --> 00:16:02,620
You can see that the code looks
very, very similar.

456
00:16:02,620 --> 00:16:05,390
In the first line, here we're
just stashing a reference to

457
00:16:05,390 --> 00:16:06,880
the API object.

458
00:16:06,880 --> 00:16:09,420
In the second line, we need
to create some data.

459
00:16:09,420 --> 00:16:12,590
Because our charts API is a
JavaScript API and we need the

460
00:16:12,590 --> 00:16:15,390
data to be a JavaScript array,
we simply pass a Dart array to

461
00:16:15,390 --> 00:16:18,380
this function that creates a
JavaScript array out of it.

462
00:16:18,380 --> 00:16:20,580
And then in the third line
here, we want to

463
00:16:20,580 --> 00:16:21,770
create a new chart.

464
00:16:21,770 --> 00:16:24,490
The way you do this from the
Dart world is you say, I want

465
00:16:24,490 --> 00:16:25,360
to create a new proxy.

466
00:16:25,360 --> 00:16:26,740
And you tell it what constructor
and what

467
00:16:26,740 --> 00:16:28,090
arguments to use.

468
00:16:28,090 --> 00:16:29,530
A little bit different,
but looks very

469
00:16:29,530 --> 00:16:31,290
similar to the line below.

470
00:16:31,290 --> 00:16:33,630
And then finally, chart
is now a proxy to

471
00:16:33,630 --> 00:16:34,840
a JavaScript object.

472
00:16:34,840 --> 00:16:37,500
And now you can interact with
it in a way that looks very

473
00:16:37,500 --> 00:16:38,910
much like any other
Dart object.

474
00:16:38,910 --> 00:16:41,780
And in fact, looks identical
to the JavaScript below.

475
00:16:41,780 --> 00:16:45,010
So with a JS interop package,
you can use JavaScript APIs.

476
00:16:45,010 --> 00:16:48,880
This is very important for
existing applications.

477
00:16:48,880 --> 00:16:51,190
SETH LADD: Another new library
we've been working on over the

478
00:16:51,190 --> 00:16:54,580
past year is our Mirror-based
reflection library.

479
00:16:54,580 --> 00:16:57,620
With mirror-based reflection,
you can do source code and

480
00:16:57,620 --> 00:16:58,730
run-time reflection.

481
00:16:58,730 --> 00:17:01,530
That is, you can load up a bunch
of source code and use

482
00:17:01,530 --> 00:17:03,320
mirrors to ask questions
about it.

483
00:17:03,320 --> 00:17:05,839
You can also, at run-time, ask
questions about the structure

484
00:17:05,839 --> 00:17:06,770
of your app.

485
00:17:06,770 --> 00:17:11,060
You can use mirrors to reflect
on both classes and instances.

486
00:17:11,060 --> 00:17:13,880
And you can introspect, say what
fields do you have, what

487
00:17:13,880 --> 00:17:16,990
construction do you have, and
invoke methods on those

488
00:17:16,990 --> 00:17:18,960
objects dynamically.

489
00:17:18,960 --> 00:17:19,780
How might we use this?

490
00:17:19,780 --> 00:17:22,869
Well, here's an example of
creating a logging proxy.

491
00:17:22,869 --> 00:17:25,329
Say I have some client code that
wants to call Hello on

492
00:17:25,329 --> 00:17:28,300
some object, but I wanted to go
through a proxy that logs

493
00:17:28,300 --> 00:17:29,530
all these calls.

494
00:17:29,530 --> 00:17:30,920
So it's going to hit
proxy first.

495
00:17:30,920 --> 00:17:33,050
He's going to print out some
sort of logging statement.

496
00:17:33,050 --> 00:17:35,380
Then he's going to delegate
the actual Hello call back

497
00:17:35,380 --> 00:17:37,230
down to the true delegate
object.

498
00:17:37,230 --> 00:17:40,530
Let's see how we do this with
mirrors and reflection.

499
00:17:40,530 --> 00:17:42,960
So first up, import the
Dart mirrors library.

500
00:17:42,960 --> 00:17:46,150
It comes to you from
the Dart SDK.

501
00:17:46,150 --> 00:17:49,000
Next, use the top-level function
reflect to reflect on

502
00:17:49,000 --> 00:17:53,340
the delegate object and get
back an instance mirror.

503
00:17:53,340 --> 00:17:57,090
Next, now remember if you call
a getter or function on an

504
00:17:57,090 --> 00:17:59,340
object and that doesn't
exist, you'll get a

505
00:17:59,340 --> 00:18:00,130
noSuchMethodError.

506
00:18:00,130 --> 00:18:03,050
It's Nice clear, and concise.

507
00:18:03,050 --> 00:18:05,550
You can actually implement
noSuchMethod here and capture

508
00:18:05,550 --> 00:18:07,300
those calls and do something
dynamic and

509
00:18:07,300 --> 00:18:08,200
interesting with it.

510
00:18:08,200 --> 00:18:10,210
In this case, we're going to do
that to capture all calls

511
00:18:10,210 --> 00:18:13,110
going through our
logging proxy.

512
00:18:13,110 --> 00:18:14,600
Before we actually delegate,
let's go ahead and

513
00:18:14,600 --> 00:18:15,800
log that call out.

514
00:18:15,800 --> 00:18:17,210
We'll just print it
out very easily.

515
00:18:17,210 --> 00:18:20,240
And then, using that instance
mirror itself, we can delegate

516
00:18:20,240 --> 00:18:24,130
the original call that came in
from noSuchMethod and pipe it

517
00:18:24,130 --> 00:18:26,410
into the actual delegate
itself.

518
00:18:26,410 --> 00:18:29,330
This is a really nice way to
deal with run-time dynamic

519
00:18:29,330 --> 00:18:33,210
programs using noSuchMethod
and mirrors.

520
00:18:33,210 --> 00:18:34,420
Here's the example.

521
00:18:34,420 --> 00:18:37,330
We're going to create a login
proxy wrap greeter.

522
00:18:37,330 --> 00:18:39,360
We're going to call the Hello
method on what we

523
00:18:39,360 --> 00:18:40,310
think is the greeter.

524
00:18:40,310 --> 00:18:42,300
But of course, it's going
through logging proxy.

525
00:18:42,300 --> 00:18:43,680
Two things will be
printed out.

526
00:18:43,680 --> 00:18:45,220
First, the symbol Hello
was called.

527
00:18:45,220 --> 00:18:46,870
That comes from the
logging proxy.

528
00:18:46,870 --> 00:18:48,860
And then, Hello that comes from
the greeter because we

529
00:18:48,860 --> 00:18:53,280
delegated that call back
down to the delegate.

530
00:18:53,280 --> 00:18:54,710
JUSTIN FAGNANI: All right, let's
talk about something

531
00:18:54,710 --> 00:18:56,880
that's very important for web
programming, which is

532
00:18:56,880 --> 00:18:58,830
asynchronous APIs
and asynchronous

533
00:18:58,830 --> 00:19:00,540
programming in Dart.

534
00:19:00,540 --> 00:19:03,940
So Dart's had some facilities
for asynchronous programming

535
00:19:03,940 --> 00:19:05,270
and they've been greatly
expanded in the

536
00:19:05,270 --> 00:19:07,740
new Dart Async library.

537
00:19:07,740 --> 00:19:10,150
First of all, why is async
programming so important?

538
00:19:10,150 --> 00:19:12,290
Why is it such a big
deal for Dart?

539
00:19:12,290 --> 00:19:14,740
Well, the web is full of
asynchronous APIs.

540
00:19:14,740 --> 00:19:17,530
These are the APIs that when
you invoke them, they don't

541
00:19:17,530 --> 00:19:19,370
block your program and they
go do some work in the

542
00:19:19,370 --> 00:19:19,880
background.

543
00:19:19,880 --> 00:19:22,370
Or maybe they wait for some
event to happen and they need

544
00:19:22,370 --> 00:19:23,890
to notify your program
when they're done,

545
00:19:23,890 --> 00:19:25,070
so they take a callback.

546
00:19:25,070 --> 00:19:27,460
And when they've loaded some
data or a user clicks on a

547
00:19:27,460 --> 00:19:30,120
button or something, the
callback is invoked.

548
00:19:30,120 --> 00:19:32,940
If you need to perform some data
after that, then you need

549
00:19:32,940 --> 00:19:34,210
to call another--

550
00:19:34,210 --> 00:19:36,360
perform another asynchronous
operation after that, you need

551
00:19:36,360 --> 00:19:38,950
to call another API in the
callback and then register

552
00:19:38,950 --> 00:19:40,070
another callback.

553
00:19:40,070 --> 00:19:42,500
You end up with these nested
callbacks, which leads us to

554
00:19:42,500 --> 00:19:45,490
what is known as
callback hell.

555
00:19:45,490 --> 00:19:48,570
Well, with Dart, we've tried
to add features to the

556
00:19:48,570 --> 00:19:50,970
libraries that make your life
easier and lead you from

557
00:19:50,970 --> 00:19:53,300
callback hell to callback
nirvana, or

558
00:19:53,300 --> 00:19:54,550
callback tropical beach.

559
00:19:54,550 --> 00:19:55,270
SETH LADD: Beautiful beach.

560
00:19:55,270 --> 00:19:56,550
JUSTIN FAGNANI: Yeah.

561
00:19:56,550 --> 00:19:58,920
And we do this with futures
and streams.

562
00:19:58,920 --> 00:20:01,560
So first, let's take
a look at futures.

563
00:20:01,560 --> 00:20:05,420
So a future is a promise that
there will be some value

564
00:20:05,420 --> 00:20:07,400
delivered to you at some
time in the future.

565
00:20:07,400 --> 00:20:09,640
In fact, in JavaScript
libraries, the concept is

566
00:20:09,640 --> 00:20:11,080
often called promises.

567
00:20:11,080 --> 00:20:13,570
So first, let's look at a
callback example here.

568
00:20:13,570 --> 00:20:17,010
DoStuff is an asynchronous
method.

569
00:20:17,010 --> 00:20:19,270
It takes as a first argument a
callback that will be invoked

570
00:20:19,270 --> 00:20:19,770
when it's done.

571
00:20:19,770 --> 00:20:23,450
And as its second optional
method, an error handler.

572
00:20:23,450 --> 00:20:25,550
So this is what a callback-based
API would look

573
00:20:25,550 --> 00:20:26,390
like in Dart.

574
00:20:26,390 --> 00:20:29,950
And as you can see, even with
a simple one-level deep no

575
00:20:29,950 --> 00:20:32,435
nesting, it's already looking
a little complicated.

576
00:20:32,435 --> 00:20:34,610
Well, with futures, what you
do is instead of taking a

577
00:20:34,610 --> 00:20:36,370
callback, you return a future.

578
00:20:36,370 --> 00:20:38,800
And this future object has
a very consistent way of

579
00:20:38,800 --> 00:20:40,760
registering the callback
in the error handler.

580
00:20:40,760 --> 00:20:43,060
All futures are the
same class.

581
00:20:43,060 --> 00:20:44,360
They all do this the same way.

582
00:20:44,360 --> 00:20:46,280
And you can see it already
looks a little cleaner.

583
00:20:46,280 --> 00:20:50,560
But because futures chain, they
return themselves, you

584
00:20:50,560 --> 00:20:52,370
can make this look
even simpler.

585
00:20:52,370 --> 00:20:54,230
You don't actually have to store
the future in a value.

586
00:20:54,230 --> 00:20:55,500
And in fact, in Dart,
you often see code

587
00:20:55,500 --> 00:20:56,520
that looks like this.

588
00:20:56,520 --> 00:20:58,140
You call an asynchronous
method.

589
00:20:58,140 --> 00:21:00,350
You register a handler and
you register a callback.

590
00:21:00,350 --> 00:21:02,170
And it looks very sequential.

591
00:21:02,170 --> 00:21:03,940
SETH LADD: We should point out
here that handle and handle

592
00:21:03,940 --> 00:21:05,570
errors themselves
are functions.

593
00:21:05,570 --> 00:21:07,830
So we can pass in a function
right into these callbacks

594
00:21:07,830 --> 00:21:10,720
without dealing with a whole
one-line or multiple line,

595
00:21:10,720 --> 00:21:11,760
like what you see on the left.

596
00:21:11,760 --> 00:21:14,290
JUSTIN FAGNANI: Exactly.

597
00:21:14,290 --> 00:21:16,730
All right, now let's look at
something where we have more

598
00:21:16,730 --> 00:21:18,140
than one level of nesting.

599
00:21:18,140 --> 00:21:20,680
So here's an imaginary cat
service, because we all know

600
00:21:20,680 --> 00:21:24,580
the internet basically exists
for trading cat pictures.

601
00:21:24,580 --> 00:21:27,290
So the first step we do here
is we get some cat data.

602
00:21:27,290 --> 00:21:28,780
And once we get the cat
data, we're going to

603
00:21:28,780 --> 00:21:29,740
want to go get a picture.

604
00:21:29,740 --> 00:21:31,290
And then once we have the
picture, we're going to want

605
00:21:31,290 --> 00:21:32,330
to rotate it and some work.

606
00:21:32,330 --> 00:21:33,960
These are all asynchronous
calls.

607
00:21:33,960 --> 00:21:37,570
And finally, four levels deep,
we do the work we wanted to.

608
00:21:37,570 --> 00:21:39,650
And you can already see that the
control flow here is hard

609
00:21:39,650 --> 00:21:42,860
to follow because it's based on
the nesting and where the

610
00:21:42,860 --> 00:21:43,980
arguments are.

611
00:21:43,980 --> 00:21:45,110
But it gets even worse.

612
00:21:45,110 --> 00:21:47,540
Now imagine you want to
do error handling.

613
00:21:47,540 --> 00:21:50,140
And if these methods each take
an error handler, than the

614
00:21:50,140 --> 00:21:50,940
error handlers get a little bit

615
00:21:50,940 --> 00:21:52,900
separated from the callbacks.

616
00:21:52,900 --> 00:21:55,250
And if there's actually real
work being done in these, if

617
00:21:55,250 --> 00:21:56,870
they're not just one-liners,
this becomes very

618
00:21:56,870 --> 00:21:58,500
complicated to follow.

619
00:21:58,500 --> 00:22:01,070
But if you imagine the same
example with futures, it

620
00:22:01,070 --> 00:22:02,400
becomes much simpler.

621
00:22:02,400 --> 00:22:04,660
With futures, the errors are
propagated through them and

622
00:22:04,660 --> 00:22:05,720
you can chain them
with different

623
00:22:05,720 --> 00:22:07,090
asynchronous calls in a row.

624
00:22:07,090 --> 00:22:09,830
And you can make that same
nested callback structure look

625
00:22:09,830 --> 00:22:11,470
like a sequence of events.

626
00:22:11,470 --> 00:22:15,340
So this is where futures start
to show some big advantages in

627
00:22:15,340 --> 00:22:16,890
terms of clarity of the code.

628
00:22:16,890 --> 00:22:18,720
SETH LADD: When you say the
error is propagated-- so an

629
00:22:18,720 --> 00:22:20,950
error or exception can
happen at any one of

630
00:22:20,950 --> 00:22:22,000
these calls to then.

631
00:22:22,000 --> 00:22:24,220
It will bubble down to
that one catch error.

632
00:22:24,220 --> 00:22:24,510
JUSTIN FAGNANI: Exactly.

633
00:22:24,510 --> 00:22:26,670
You don't have to register
multiple error handlers.

634
00:22:26,670 --> 00:22:29,160
It's almost like a try catch
block, but asynchronously.

635
00:22:29,160 --> 00:22:31,770

636
00:22:31,770 --> 00:22:33,010
OK, so that's not all, right?

637
00:22:33,010 --> 00:22:35,910
So futures are nice and
consistent and they clean up

638
00:22:35,910 --> 00:22:37,620
the code structure
a little bit.

639
00:22:37,620 --> 00:22:39,120
But futures also compose.

640
00:22:39,120 --> 00:22:41,490
Future is like our first-class
concept of, there will be a

641
00:22:41,490 --> 00:22:42,300
value in the future.

642
00:22:42,300 --> 00:22:45,180
And you can write utilities
that deal in futures.

643
00:22:45,180 --> 00:22:47,290
And one of the most basic
utilities is just waiting for

644
00:22:47,290 --> 00:22:48,970
things to happen in parallel.

645
00:22:48,970 --> 00:22:51,550
So future has a static method on
it called wait, which takes

646
00:22:51,550 --> 00:22:52,970
a list of other futures.

647
00:22:52,970 --> 00:22:54,950
It waits for them all to
complete and returns a new

648
00:22:54,950 --> 00:22:56,230
future when it's done.

649
00:22:56,230 --> 00:22:59,340
And so this is a very easy way
to wait for parallel items.

650
00:22:59,340 --> 00:23:01,850
You can imagine in JavaScript,
you usually have to keep some

651
00:23:01,850 --> 00:23:04,440
kind of counter of how many
callbacks have finished, and

652
00:23:04,440 --> 00:23:06,735
update them, and error handling
becomes difficult.

653
00:23:06,735 --> 00:23:08,150
Well, here it's all
done for you.

654
00:23:08,150 --> 00:23:09,570
You just give it a
list of futures.

655
00:23:09,570 --> 00:23:11,090
Here we're getting two
pictures and we

656
00:23:11,090 --> 00:23:12,130
want to blend them.

657
00:23:12,130 --> 00:23:16,520
And we still have an error
handler down at the bottom.

658
00:23:16,520 --> 00:23:18,475
So we work with both pictures.

659
00:23:18,475 --> 00:23:19,720
I'll go back.

660
00:23:19,720 --> 00:23:22,180
And notice that the error
handler will work on the

661
00:23:22,180 --> 00:23:23,840
future that are happening
in parallel and

662
00:23:23,840 --> 00:23:27,190
every subsequent operation.

663
00:23:27,190 --> 00:23:29,210
OK, so futures have been around
for a little while, but

664
00:23:29,210 --> 00:23:31,570
what's really new in
Dart is streams.

665
00:23:31,570 --> 00:23:32,770
So futures only fire once.

666
00:23:32,770 --> 00:23:35,390
But you also have to worry about
repeating events, things

667
00:23:35,390 --> 00:23:39,890
like user interaction with
the UI and I/O. So

668
00:23:39,890 --> 00:23:41,280
streams are the new thing.

669
00:23:41,280 --> 00:23:43,750
And they are the repeating
analog to future.

670
00:23:43,750 --> 00:23:46,720
And in the Dart libraries,
because we get to start fresh,

671
00:23:46,720 --> 00:23:49,570
nearly all repeating events
in Dart are streams.

672
00:23:49,570 --> 00:23:53,620
You should see very, very, if
any, little callback-based

673
00:23:53,620 --> 00:23:54,370
APIs anymore.

674
00:23:54,370 --> 00:23:55,620
SETH LADD: I think that's
an excellent point.

675
00:23:55,620 --> 00:23:59,320
With futures and streams, we
bake them across the APIs and

676
00:23:59,320 --> 00:24:00,460
libraries we've built.

677
00:24:00,460 --> 00:24:04,210
So everything from, say, opening
files to XML HTTP

678
00:24:04,210 --> 00:24:07,830
request, to get user media, to
the file I/O, the directories.

679
00:24:07,830 --> 00:24:08,360
JUSTIN FAGNANI: All your
basic DOM events.

680
00:24:08,360 --> 00:24:09,800
SETH LADD: All this now is
futures and streams.

681
00:24:09,800 --> 00:24:12,220
And you get that because we bake
it into the SDK for you.

682
00:24:12,220 --> 00:24:13,550
JUSTIN FAGNANI: And because we
got to start fresh with the

683
00:24:13,550 --> 00:24:15,650
libraries, too.

684
00:24:15,650 --> 00:24:17,440
So let's take a look
at an example.

685
00:24:17,440 --> 00:24:19,860
Here, we're going to look at
the documentation for the

686
00:24:19,860 --> 00:24:20,590
element class.

687
00:24:20,590 --> 00:24:23,040
This is the base class for
all the HTML elements.

688
00:24:23,040 --> 00:24:25,210
And you can see that there's
this line here that says

689
00:24:25,210 --> 00:24:27,720
onKeyPress is a property
that's a

690
00:24:27,720 --> 00:24:29,140
stream of keyboard events.

691
00:24:29,140 --> 00:24:29,910
So what does that mean?

692
00:24:29,910 --> 00:24:33,850
It means that we can do a query
here for a text area.

693
00:24:33,850 --> 00:24:36,990
And we can access this
onKeyPress property and call

694
00:24:36,990 --> 00:24:40,570
listen, which is very much
like then on a future.

695
00:24:40,570 --> 00:24:43,140
The function given to listen
will be invoked every time

696
00:24:43,140 --> 00:24:44,430
that there's a keypress
event and it will

697
00:24:44,430 --> 00:24:45,980
be given that event.

698
00:24:45,980 --> 00:24:48,450
So here we simply turn our key
press event into a string and

699
00:24:48,450 --> 00:24:48,940
print it out.

700
00:24:48,940 --> 00:24:53,180
So this'll print char equals
wherever we happen to type.

701
00:24:53,180 --> 00:24:54,360
But streams do a lot more.

702
00:24:54,360 --> 00:24:55,930
They have a very,
very rich API.

703
00:24:55,930 --> 00:24:57,300
You can filter the events.

704
00:24:57,300 --> 00:24:58,390
You can transform them.

705
00:24:58,390 --> 00:25:00,610
You can turn streams into
futures by getting the first

706
00:25:00,610 --> 00:25:03,100
or last element in a stream.

707
00:25:03,100 --> 00:25:05,130
So here's an example where
we want to get

708
00:25:05,130 --> 00:25:06,440
our keypress event.

709
00:25:06,440 --> 00:25:09,720
And let's say we only care about
events that are actually

710
00:25:09,720 --> 00:25:12,390
keys on the keyboard that
you can type and read.

711
00:25:12,390 --> 00:25:14,100
So you might want to want these
to get rid of control

712
00:25:14,100 --> 00:25:15,400
characters and things.

713
00:25:15,400 --> 00:25:17,440
So here, we can just
filter the stream.

714
00:25:17,440 --> 00:25:19,910
And we use some range filter
to say these are our valid

715
00:25:19,910 --> 00:25:20,770
characters.

716
00:25:20,770 --> 00:25:24,240
And this returns a new stream,
where we can call listen or

717
00:25:24,240 --> 00:25:27,180
more transformation
methods on.

718
00:25:27,180 --> 00:25:29,730
And next we're going
to call map.

719
00:25:29,730 --> 00:25:32,580
And what map does is it takes
every element, every event in

720
00:25:32,580 --> 00:25:34,760
the stream and it turns it into
some new kind of event

721
00:25:34,760 --> 00:25:36,520
and creates a new stream
out of that.

722
00:25:36,520 --> 00:25:37,840
So here we're going to
map and turn our

723
00:25:37,840 --> 00:25:40,690
keyboard events into strings.

724
00:25:40,690 --> 00:25:42,960
Finally, let's say we're only
concerned with the very first

725
00:25:42,960 --> 00:25:45,680
keypress in our text
area here.

726
00:25:45,680 --> 00:25:47,690
So we can call first on the
stream and that returns us a

727
00:25:47,690 --> 00:25:51,760
future now, which returns
a value when that

728
00:25:51,760 --> 00:25:53,090
key is first pressed.

729
00:25:53,090 --> 00:25:54,960
And then we call then
like we did before.

730
00:25:54,960 --> 00:25:56,070
And we can print out
that the first

731
00:25:56,070 --> 00:25:57,720
character is that character.

732
00:25:57,720 --> 00:25:59,370
And you can see that this
reads really nice.

733
00:25:59,370 --> 00:26:01,360
And because streams are so
common across the libraries,

734
00:26:01,360 --> 00:26:03,220
you'll be able to see and
recognize these patterns

735
00:26:03,220 --> 00:26:04,650
across Dart code bases.

736
00:26:04,650 --> 00:26:07,710

737
00:26:07,710 --> 00:26:09,790
Finally, this is a relatively
short talk.

738
00:26:09,790 --> 00:26:12,950
So we don't have enough time,
nearly enough time to go to

739
00:26:12,950 --> 00:26:14,590
HTML and web components.

740
00:26:14,590 --> 00:26:17,430
There is a talk later at 3:30
PM with Emily and Seth.

741
00:26:17,430 --> 00:26:20,900
And they're going to go deep
into the new developments in

742
00:26:20,900 --> 00:26:23,800
HTML and web components and how
you develop rich complex

743
00:26:23,800 --> 00:26:25,530
UIs in Dart.

744
00:26:25,530 --> 00:26:28,030
A lot of changes in the last
year is that we've Dartified

745
00:26:28,030 --> 00:26:29,440
the HTML library.

746
00:26:29,440 --> 00:26:32,590
It follows Dart idioms, uses
Dart collections, and gives

747
00:26:32,590 --> 00:26:34,620
you some jQuery-like
functionality.

748
00:26:34,620 --> 00:26:36,590
We also have Web UI, which
is our custom elements

749
00:26:36,590 --> 00:26:37,630
implementation.

750
00:26:37,630 --> 00:26:40,470
We've done things like gotten
rid of vendor prefixes so you

751
00:26:40,470 --> 00:26:42,580
can just use one method call.

752
00:26:42,580 --> 00:26:44,900
So that's at 3:30
PM in this room.

753
00:26:44,900 --> 00:26:47,020
Yeah.

754
00:26:47,020 --> 00:26:47,620
SETH LADD: OK, cool.

755
00:26:47,620 --> 00:26:49,230
Let's look at what's new
across the tools

756
00:26:49,230 --> 00:26:51,600
and ecosystem here.

757
00:26:51,600 --> 00:26:53,230
Well, one thing that's really
important to point-- and we

758
00:26:53,230 --> 00:26:54,730
alluded to do this earlier--

759
00:26:54,730 --> 00:26:57,630
is that the development cycle in
Dart is very, very fast and

760
00:26:57,630 --> 00:26:58,790
very quick and iterative.

761
00:26:58,790 --> 00:27:00,820
This is important for web
developers who are used to

762
00:27:00,820 --> 00:27:02,240
simply making a change
and hitting

763
00:27:02,240 --> 00:27:03,210
Reload in their browser.

764
00:27:03,210 --> 00:27:04,610
They want to see that
change immediately.

765
00:27:04,610 --> 00:27:06,740
They don't want to be slowed
down by any sort of compile

766
00:27:06,740 --> 00:27:09,630
time process during the bulk
of their development.

767
00:27:09,630 --> 00:27:11,150
So I'm happy to say that
with Dartium--

768
00:27:11,150 --> 00:27:13,440
it's a special build of Chromium
with the Dart Virtual

769
00:27:13,440 --> 00:27:14,800
Machine embedded inside--

770
00:27:14,800 --> 00:27:17,670
we can deliver those very fast,
no compiles required,

771
00:27:17,670 --> 00:27:19,350
edit/reload cycles.

772
00:27:19,350 --> 00:27:21,350
So typically the flow will
look something like this.

773
00:27:21,350 --> 00:27:23,190
The feature
[? bugging section ?]

774
00:27:23,190 --> 00:27:25,040
throughout the bulk of the
development, you're simply

775
00:27:25,040 --> 00:27:27,070
writing code, hitting
Reload in Dartium.

776
00:27:27,070 --> 00:27:28,940
Boom, you see the change
right away.

777
00:27:28,940 --> 00:27:31,050
Only right at the very end--
and this is what we've been

778
00:27:31,050 --> 00:27:34,000
told by real users of Dart.

779
00:27:34,000 --> 00:27:37,280
Only at the very end will they
introduce dart2js, compile

780
00:27:37,280 --> 00:27:39,710
their application into
JavaScript, and test on all of

781
00:27:39,710 --> 00:27:40,750
the browsers.

782
00:27:40,750 --> 00:27:43,270
So this is really,
really nice.

783
00:27:43,270 --> 00:27:44,790
We've also been working
on a standalone

784
00:27:44,790 --> 00:27:46,060
editor called Dart Editor.

785
00:27:46,060 --> 00:27:48,240
This is built from the ground
up, built on the Eclipse

786
00:27:48,240 --> 00:27:50,720
platform, to give you features
and functionalities you're

787
00:27:50,720 --> 00:27:52,830
used to when you develop
code and apps on

788
00:27:52,830 --> 00:27:53,710
all the other platforms.

789
00:27:53,710 --> 00:27:54,830
Things like refactoring.

790
00:27:54,830 --> 00:27:58,260
Things like jump to definition,
inline types, a

791
00:27:58,260 --> 00:27:59,330
nice problems view.

792
00:27:59,330 --> 00:28:00,480
The list goes on and on.

793
00:28:00,480 --> 00:28:02,750
This is the kind of productive
developments experience that

794
00:28:02,750 --> 00:28:05,535
you like when you deal with code
as you grow from 1 to 10,

795
00:28:05,535 --> 00:28:08,320
to 1,000 to, to, say, 500 or a
million lines of code, which

796
00:28:08,320 --> 00:28:10,740
is not unheard of when you build
the kind of apps users

797
00:28:10,740 --> 00:28:12,000
are demanding.

798
00:28:12,000 --> 00:28:14,590
But if Eclipse is in your bag,
that's OK, because we've also

799
00:28:14,590 --> 00:28:16,100
got plug-ins for VIM.

800
00:28:16,100 --> 00:28:18,800
An actual plug-in for Eclipse
as opposed to Dart Editor,

801
00:28:18,800 --> 00:28:20,360
which is a standalone editor.

802
00:28:20,360 --> 00:28:21,740
Plug-ins for Sublime.

803
00:28:21,740 --> 00:28:24,010
And our friends IntelliJ
and WebStorm--

804
00:28:24,010 --> 00:28:25,830
they're actually up there in
the Chrome booth-- can show

805
00:28:25,830 --> 00:28:27,220
off their Dart plug-in
as well.

806
00:28:27,220 --> 00:28:29,750
So hopefully we've got a choice
for you across whatever

807
00:28:29,750 --> 00:28:31,880
editor you are working with.

808
00:28:31,880 --> 00:28:33,500
Now, we'd love to show a demo of
this, but we have something

809
00:28:33,500 --> 00:28:35,880
really new and exciting to
show you guys in terms of

810
00:28:35,880 --> 00:28:36,580
editing Dart.

811
00:28:36,580 --> 00:28:40,790
We're happy to announce the
relaunch of try.dartlang.org

812
00:28:40,790 --> 00:28:41,950
that our team's been
working on.

813
00:28:41,950 --> 00:28:44,410
We've taken the dart2js
compiler, compiled it with

814
00:28:44,410 --> 00:28:47,500
itself into JavaScript, put it
in a browser, and given you

815
00:28:47,500 --> 00:28:49,930
the ability to write Dart code
and see it live without having

816
00:28:49,930 --> 00:28:50,620
to install anything.

817
00:28:50,620 --> 00:28:51,330
So let's see.

818
00:28:51,330 --> 00:28:51,920
Let's take a look.

819
00:28:51,920 --> 00:28:52,580
JUSTIN FAGNANI: All right.

820
00:28:52,580 --> 00:28:53,830
Let's check it out.

821
00:28:53,830 --> 00:28:55,970

822
00:28:55,970 --> 00:28:58,440
OK, so this is try.dartlang.org.

823
00:28:58,440 --> 00:29:02,330
As Seth mentioned, this is
using dart2js, which has

824
00:29:02,330 --> 00:29:04,740
compiled itself to be able
to run in the browser.

825
00:29:04,740 --> 00:29:07,080
So this is the same compiler
that the editor and the

826
00:29:07,080 --> 00:29:09,030
command line applications use.

827
00:29:09,030 --> 00:29:10,840
So here we have a simple
little text editor.

828
00:29:10,840 --> 00:29:12,770
Notice we have some syntax
highlighting happening here

829
00:29:12,770 --> 00:29:14,170
because of dart2js.

830
00:29:14,170 --> 00:29:18,290
We're going to change this
to Hello Google I/O.

831
00:29:18,290 --> 00:29:20,400
And notice it's compiling
on the fly.

832
00:29:20,400 --> 00:29:21,640
And there we go.

833
00:29:21,640 --> 00:29:22,960
We see the output.

834
00:29:22,960 --> 00:29:24,455
Also notice that this is
running in Firefox.

835
00:29:24,455 --> 00:29:30,140
So it's important to note how
critical dart2js is to the

836
00:29:30,140 --> 00:29:32,860
deployment step here, and how
much it enables Dart to run on

837
00:29:32,860 --> 00:29:34,440
all of the modern web.

838
00:29:34,440 --> 00:29:36,660
SETH LADD: Nice improvements
also is this works offline.

839
00:29:36,660 --> 00:29:37,970
This works on your iPad.

840
00:29:37,970 --> 00:29:39,965
And you can also edit
HTML apps as well.

841
00:29:39,965 --> 00:29:42,570
So very nicely way for you to
try Dart, and then go pick an

842
00:29:42,570 --> 00:29:44,210
editing experience that
works for you.

843
00:29:44,210 --> 00:29:47,590

844
00:29:47,590 --> 00:29:49,070
OK, what else in tools
and ecosystem?

845
00:29:49,070 --> 00:29:51,800
Well, we have a nice unit
test library that

846
00:29:51,800 --> 00:29:52,650
comes out of the box.

847
00:29:52,650 --> 00:29:54,750
We also have a mock library
that comes out of the box.

848
00:29:54,750 --> 00:29:56,470
Here's a quick code sample
here at the top

849
00:29:56,470 --> 00:29:57,250
for our unit test.

850
00:29:57,250 --> 00:29:59,300
It looks familiar and I think
a lot of other unit test

851
00:29:59,300 --> 00:30:01,300
frameworks you might
have seen before.

852
00:30:01,300 --> 00:30:03,810
Also, happy to announce that
we a headless version of

853
00:30:03,810 --> 00:30:05,450
Chromium we call dump
render tree.

854
00:30:05,450 --> 00:30:10,150
But this allows you to run
HTML-based Dart tests in a

855
00:30:10,150 --> 00:30:11,440
headless browser.

856
00:30:11,440 --> 00:30:13,860
And say, then take that and
wire it into continuous

857
00:30:13,860 --> 00:30:17,140
integration services, like
Drone.io, who have native

858
00:30:17,140 --> 00:30:20,140
support for Dart and this
headless Chrome.

859
00:30:20,140 --> 00:30:23,270
So you can check in your code
into Bitpocket or GitHub, fire

860
00:30:23,270 --> 00:30:26,790
off a change which Drone.io
picks up, runs all of your

861
00:30:26,790 --> 00:30:29,530
tests from the command line,
runs all of your HTML tests or

862
00:30:29,530 --> 00:30:32,200
web tests in this headless
Chrome and reports back to you

863
00:30:32,200 --> 00:30:32,950
how everything's working.

864
00:30:32,950 --> 00:30:36,300
So you now start to see this
nice chain for really rich

865
00:30:36,300 --> 00:30:39,920
end-to-end development
experience.

866
00:30:39,920 --> 00:30:42,050
Also, been working on a
package manager, we

867
00:30:42,050 --> 00:30:43,375
affectionately call
Pub because you

868
00:30:43,375 --> 00:30:44,550
play darts in a pub.

869
00:30:44,550 --> 00:30:47,570
And with Pub, you can download
packages, manage the

870
00:30:47,570 --> 00:30:50,920
dependencies and the updates,
publish your own packages to

871
00:30:50,920 --> 00:30:54,290
Pub, and browse around
pub.dartlang.org, which is our

872
00:30:54,290 --> 00:30:57,280
hosting service, where there's
already over 200 packages out

873
00:30:57,280 --> 00:31:00,660
there ranging everything from
database drivers, to MVC

874
00:31:00,660 --> 00:31:04,190
frameworks, to encryption, to
parsers, game libraries, the

875
00:31:04,190 --> 00:31:05,310
list goes on and on and on.

876
00:31:05,310 --> 00:31:08,420
It's very easy for you guys to
publish your own packages into

877
00:31:08,420 --> 00:31:09,330
Pub as well.

878
00:31:09,330 --> 00:31:11,590
Pub works with our central
hosting service here.

879
00:31:11,590 --> 00:31:12,620
[? Git, ?]

880
00:31:12,620 --> 00:31:13,450
local file system.

881
00:31:13,450 --> 00:31:16,200
Very easy for you to reuse
and send out and share

882
00:31:16,200 --> 00:31:19,640
functionalities across
Dart apps.

883
00:31:19,640 --> 00:31:23,180
We're also really happy to
announce that the Flash Pro,

884
00:31:23,180 --> 00:31:27,000
the really rich animation
engine, game engine, or game

885
00:31:27,000 --> 00:31:31,300
editing tool from Adobe now can
export your animations and

886
00:31:31,300 --> 00:31:32,880
games to Dart.

887
00:31:32,880 --> 00:31:35,030
You can see a demo of this
up at our booth up

888
00:31:35,030 --> 00:31:36,160
in the Chrome area.

889
00:31:36,160 --> 00:31:37,600
So real quickly, you
don't have to

890
00:31:37,600 --> 00:31:38,690
write any action script.

891
00:31:38,690 --> 00:31:40,990
You can use the really rich
editing experience of the

892
00:31:40,990 --> 00:31:43,750
stage and the timeline and all
the asset managements of Flash

893
00:31:43,750 --> 00:31:46,430
Pro and go through their toolkit
here and export that

894
00:31:46,430 --> 00:31:49,380
all out to Dart code
and HTML5 APIs.

895
00:31:49,380 --> 00:31:51,790
Which means you can use their
really slick tools here, And

896
00:31:51,790 --> 00:31:54,160
then deploy that across the
modern web without any

897
00:31:54,160 --> 00:31:55,140
plug-ins at all.

898
00:31:55,140 --> 00:31:56,270
So if you guys are interested
in this, come

899
00:31:56,270 --> 00:31:57,520
check this out upstairs.

900
00:31:57,520 --> 00:31:59,880

901
00:31:59,880 --> 00:32:02,990
JUSTIN FAGNANI: OK, next let's
talk about things that are

902
00:32:02,990 --> 00:32:05,260
very important to
web developers--

903
00:32:05,260 --> 00:32:09,000
size and speed, or
performance.

904
00:32:09,000 --> 00:32:13,440
So the web has gone on a
continuous evolution path

905
00:32:13,440 --> 00:32:14,310
since it started.

906
00:32:14,310 --> 00:32:16,773
And one of the things that's
happened with JavaScript is

907
00:32:16,773 --> 00:32:20,540
that it initially enabled the
very first client-side apps.

908
00:32:20,540 --> 00:32:22,590
And JavaScript wasn't that
fast, but then JavaScript

909
00:32:22,590 --> 00:32:23,860
became faster.

910
00:32:23,860 --> 00:32:27,720
With the advent of fast VMs
like V8, applications that

911
00:32:27,720 --> 00:32:29,880
started rivaling desktop
applications were

912
00:32:29,880 --> 00:32:31,300
now suddenly possible.

913
00:32:31,300 --> 00:32:33,750
And the applications grew
to use this performance.

914
00:32:33,750 --> 00:32:36,210
So as all the VMs out there
got faster and faster, the

915
00:32:36,210 --> 00:32:39,380
applications took advantage of
that and became more complex.

916
00:32:39,380 --> 00:32:41,640
So we see this continual
advancement and

917
00:32:41,640 --> 00:32:44,180
power-hungriness of
applications.

918
00:32:44,180 --> 00:32:45,270
So we don't see that ending.

919
00:32:45,270 --> 00:32:47,360
Performance is still
important.

920
00:32:47,360 --> 00:32:49,970
Another reason why performance
really, really matters is

921
00:32:49,970 --> 00:32:51,180
because of mobile.

922
00:32:51,180 --> 00:32:54,170
Now, on your laptop you have a
fairly large battery, or on

923
00:32:54,170 --> 00:32:55,940
your desktop you're plugged
into the wall.

924
00:32:55,940 --> 00:32:57,500
But on your phone or your
tablet, you actually don't

925
00:32:57,500 --> 00:32:58,790
have that large of a battery.

926
00:32:58,790 --> 00:33:01,810
If you last a day, that
might be a good day.

927
00:33:01,810 --> 00:33:03,890
And performance directly
impacts that.

928
00:33:03,890 --> 00:33:06,670
The faster your application is,
the less CPU it's using,

929
00:33:06,670 --> 00:33:08,850
that means the less battery
it's using.

930
00:33:08,850 --> 00:33:12,360
Even a 10% increase in battery
life is a significant

931
00:33:12,360 --> 00:33:12,890
improvement.

932
00:33:12,890 --> 00:33:14,430
So this really matters.

933
00:33:14,430 --> 00:33:20,560
And yeah, so what we like to say
is that every performance

934
00:33:20,560 --> 00:33:23,310
improvement is a battery
improvement.

935
00:33:23,310 --> 00:33:25,160
So first let's talk about
dart2js here in

936
00:33:25,160 --> 00:33:26,390
terms of our tools.

937
00:33:26,390 --> 00:33:29,880
So as we said, the dart2js is
responsible for compiling Dart

938
00:33:29,880 --> 00:33:31,460
to JavaScript.

939
00:33:31,460 --> 00:33:33,660
Quickly, the way this works
is that we pull in your

940
00:33:33,660 --> 00:33:36,300
application and all the
libraries it imports.

941
00:33:36,300 --> 00:33:39,020
We run it through all the
optimizations and compilation

942
00:33:39,020 --> 00:33:42,550
steps that dart2js does to
minify your application.

943
00:33:42,550 --> 00:33:45,810
And then, we output a JavaScript
file, the compiled

944
00:33:45,810 --> 00:33:47,670
version of your app.

945
00:33:47,670 --> 00:33:49,480
SETH LADD: We also output a
source map to enable really

946
00:33:49,480 --> 00:33:52,560
easy debugging, which maps the
original Dart code to the

947
00:33:52,560 --> 00:33:53,610
compiled JavaScript code.

948
00:33:53,610 --> 00:33:55,950
And your Chrome DevTools can
read all that, so when set a

949
00:33:55,950 --> 00:33:58,660
break point in your Chrome
DevTools, it's actually

950
00:33:58,660 --> 00:34:00,850
setting a breakpoint from the
Dart code and mapping to the

951
00:34:00,850 --> 00:34:01,470
Javascript code.

952
00:34:01,470 --> 00:34:03,140
JUSTIN FAGNANI: Which also
works in browsers like

953
00:34:03,140 --> 00:34:06,700
Firefox, and I believe, IE.

954
00:34:06,700 --> 00:34:09,179
OK, so let's look at some of the
generated JavaScript, so

955
00:34:09,179 --> 00:34:11,870
you can see a little bit about
what the compiler is doing.

956
00:34:11,870 --> 00:34:13,310
So here's a very
simple example.

957
00:34:13,310 --> 00:34:16,179
We have a Dart program that's
using the HTML library and it

958
00:34:16,179 --> 00:34:18,860
Defines a simple class, person,
and then it uses that

959
00:34:18,860 --> 00:34:22,020
class in some simple way
in the main method.

960
00:34:22,020 --> 00:34:26,340
So here's a JavaScript output
that the dart2js has produced.

961
00:34:26,340 --> 00:34:28,950
And you can see that it actually
is very readable and

962
00:34:28,950 --> 00:34:32,250
kind of corresponds logically
to the Dart source code.

963
00:34:32,250 --> 00:34:35,080
In fact, in this case, there's
like a one-to-one

964
00:34:35,080 --> 00:34:37,219
correspondence between the lines
of Dart and the lines of

965
00:34:37,219 --> 00:34:39,110
JavaScript.

966
00:34:39,110 --> 00:34:41,464
But like we mentioned, Dart
has minification.

967
00:34:41,464 --> 00:34:44,020
And it has tree shaking, which
is dead code elimination.

968
00:34:44,020 --> 00:34:46,850
So it's important to produce the
smallest application sizes

969
00:34:46,850 --> 00:34:47,800
as possible.

970
00:34:47,800 --> 00:34:50,429
So when you turn minification
on, you can see that as part

971
00:34:50,429 --> 00:34:53,800
of the compilation process, we
renamed variables and inline

972
00:34:53,800 --> 00:34:55,800
functions and do interesting
things here to give you the

973
00:34:55,800 --> 00:34:58,860
most compact JavaScript
possible.

974
00:34:58,860 --> 00:35:00,400
SETH LADD: So Justin mentioned
tree shaking.

975
00:35:00,400 --> 00:35:01,340
Well, what's tree shaking?

976
00:35:01,340 --> 00:35:03,240
So if you look at the marketing
material, pretty

977
00:35:03,240 --> 00:35:05,150
much every JavaScript library
out there, the first and

978
00:35:05,150 --> 00:35:07,580
foremost thing they tell
you is how small it is.

979
00:35:07,580 --> 00:35:10,160
Instead, I, as a developer, care
how good it is and how it

980
00:35:10,160 --> 00:35:11,140
can help me.

981
00:35:11,140 --> 00:35:12,720
Well, you shouldn't have to
worry about how small the

982
00:35:12,720 --> 00:35:13,350
libraries are.

983
00:35:13,350 --> 00:35:14,540
You should let the tools
handle that kind

984
00:35:14,540 --> 00:35:15,420
of stuff for you.

985
00:35:15,420 --> 00:35:16,320
Here's an example here.

986
00:35:16,320 --> 00:35:17,650
Here's an application.

987
00:35:17,650 --> 00:35:20,110
You've written the stuff on your
left here and it pulls in

988
00:35:20,110 --> 00:35:22,040
a library-- the library
in the yellow.

989
00:35:22,040 --> 00:35:24,840
And one of your functions calls
just one function from

990
00:35:24,840 --> 00:35:26,480
the yellow library.

991
00:35:26,480 --> 00:35:28,480
And there's no reason why you
should have to pull in all

992
00:35:28,480 --> 00:35:30,770
that baggage if you can
determine only the functions

993
00:35:30,770 --> 00:35:34,120
or the features that you
actually need in your app.

994
00:35:34,120 --> 00:35:36,430
Well, dart2js performs a
tree-shaking functionality,

995
00:35:36,430 --> 00:35:38,810
which takes all the
dependencies, all the imports,

996
00:35:38,810 --> 00:35:41,960
all the libraries and can look
at the program and say, OK,

997
00:35:41,960 --> 00:35:45,120
these are the bits you actually
use and produce just

998
00:35:45,120 --> 00:35:47,210
the code that is required
to run your app.

999
00:35:47,210 --> 00:35:49,290
Notice how you don't have these
leaf nodes that you

1000
00:35:49,290 --> 00:35:50,530
never actually call.

1001
00:35:50,530 --> 00:35:54,030
This is another reason why
dart2js can produce smaller,

1002
00:35:54,030 --> 00:35:55,280
faster output for you.

1003
00:35:55,280 --> 00:35:57,640

1004
00:35:57,640 --> 00:35:58,650
JUSTIN FAGNANI: Let's
talk about the

1005
00:35:58,650 --> 00:36:01,120
performance of the Dart VM.

1006
00:36:01,120 --> 00:36:05,970
So if you saw Lars and Casper's
talk, they went into

1007
00:36:05,970 --> 00:36:08,220
great detail about why
the VM is faster.

1008
00:36:08,220 --> 00:36:11,880
But real quickly, Dart has more
explicit and static and

1009
00:36:11,880 --> 00:36:13,370
declarative structure.

1010
00:36:13,370 --> 00:36:15,830
This allows the VM to be
braver and make smarter

1011
00:36:15,830 --> 00:36:16,650
optimizations.

1012
00:36:16,650 --> 00:36:18,660
And it allows the VM
to be simpler.

1013
00:36:18,660 --> 00:36:20,620
We have real arrays
and real classes.

1014
00:36:20,620 --> 00:36:23,340
You can invoke a method without
having to call the

1015
00:36:23,340 --> 00:36:26,765
prototype chain to see if the
method has changed at all.

1016
00:36:26,765 --> 00:36:30,800
So these things allow the VM
to be much faster already.

1017
00:36:30,800 --> 00:36:35,670
And in addition to that, we're
able to use more of your CPU.

1018
00:36:35,670 --> 00:36:39,160
So we've added SIMD extensions,
recently, to Dart.

1019
00:36:39,160 --> 00:36:41,930
If you look at a modern CPU, a
significant portion of the die

1020
00:36:41,930 --> 00:36:45,070
is dedicated to these vector
processors, these SIMD

1021
00:36:45,070 --> 00:36:46,130
processors.

1022
00:36:46,130 --> 00:36:49,390
This is an ARM CPU and you can
see that almost a third of the

1023
00:36:49,390 --> 00:36:52,470
CPU is dedicated to the neon
and vector operations.

1024
00:36:52,470 --> 00:36:54,650
SETH LADD: Yeah, traditional web
programming today can not

1025
00:36:54,650 --> 00:36:57,530
unlock the full capabilities
of your CPU.

1026
00:36:57,530 --> 00:36:58,400
And that's a real shame.

1027
00:36:58,400 --> 00:37:01,730
And so the Dart VM says, yeah,
let's give you this power.

1028
00:37:01,730 --> 00:37:03,710
JUSTIN FAGNANI: So how does
that performance actually

1029
00:37:03,710 --> 00:37:04,440
manifest itself?

1030
00:37:04,440 --> 00:37:07,990
Well, we have a few benchmarks
that we've been publishing.

1031
00:37:07,990 --> 00:37:11,800
And you can see the blue bar
here is the Dart VM.

1032
00:37:11,800 --> 00:37:14,340
And yes, higher is better.

1033
00:37:14,340 --> 00:37:17,060
And so you can see on these
performance benchmarks here

1034
00:37:17,060 --> 00:37:20,670
that the VM has been beating
handwritten JavaScript.

1035
00:37:20,670 --> 00:37:23,540
And in fact, on the array
tracing example, it's almost

1036
00:37:23,540 --> 00:37:24,980
two times as fast.

1037
00:37:24,980 --> 00:37:27,630
And if you notice over here on
the left, on the Delta Blue

1038
00:37:27,630 --> 00:37:30,700
benchmark, there are cases
where dart2js actually

1039
00:37:30,700 --> 00:37:33,330
produces faster code than
handwritten JavaScript because

1040
00:37:33,330 --> 00:37:35,360
of the optimizations
it's able to make.

1041
00:37:35,360 --> 00:37:38,010
So here in Delta Blue, dart2js
is a little bit faster than

1042
00:37:38,010 --> 00:37:38,640
JavaScript.

1043
00:37:38,640 --> 00:37:40,160
SETH LADD: We should point out
that Dart is not even yet a

1044
00:37:40,160 --> 00:37:43,860
1.0 production release and we're
still doing pretty good.

1045
00:37:43,860 --> 00:37:45,440
But we have more work to go.

1046
00:37:45,440 --> 00:37:47,720
JUSTIN FAGNANI: I think V8 has a
four or five-year head start

1047
00:37:47,720 --> 00:37:50,750
on the Dart VM.

1048
00:37:50,750 --> 00:37:53,150
OK, now, Seth.

1049
00:37:53,150 --> 00:37:53,690
SETH LADD: Sure.

1050
00:37:53,690 --> 00:37:54,440
Let's talk about this one.

1051
00:37:54,440 --> 00:37:57,650
So the nice thing is these
charts here are all running on

1052
00:37:57,650 --> 00:37:59,110
this beefy MacBook Pro.

1053
00:37:59,110 --> 00:38:01,790
This guy's got like 87 cores
and 52 gigs of RAM.

1054
00:38:01,790 --> 00:38:03,220
So of course, these numbers
are going to look really

1055
00:38:03,220 --> 00:38:04,110
impressive.

1056
00:38:04,110 --> 00:38:06,350
But does it translate down to
mobile, which is what we're

1057
00:38:06,350 --> 00:38:08,660
all going to be developing
by this time next year?

1058
00:38:08,660 --> 00:38:11,480
So happy to say that yes, the
same kind of performance

1059
00:38:11,480 --> 00:38:14,010
characteristics when you use
the Dart VM as opposed to

1060
00:38:14,010 --> 00:38:16,660
handwritten code does
translate over.

1061
00:38:16,660 --> 00:38:19,920
So this is running on Chrome for
Android with the Dart VM

1062
00:38:19,920 --> 00:38:22,010
embedded inside on
an x86 phone.

1063
00:38:22,010 --> 00:38:23,960
You can see here the yellow
is handwritten JavaScript.

1064
00:38:23,960 --> 00:38:26,450
The middle guy is
just Dart VM.

1065
00:38:26,450 --> 00:38:31,230
And then the big tall blue bar
is Dart VM having ported the

1066
00:38:31,230 --> 00:38:34,330
NBody simulation over to use
the SIMD instructions.

1067
00:38:34,330 --> 00:38:37,470
So every performance matters
on mobile phones.

1068
00:38:37,470 --> 00:38:39,180
As Justin said, it's all
about battery there.

1069
00:38:39,180 --> 00:38:40,940
So you'll see the same
gains, even on the

1070
00:38:40,940 --> 00:38:42,190
little devices here.

1071
00:38:42,190 --> 00:38:44,700

1072
00:38:44,700 --> 00:38:47,350
JUSTIN FAGNANI: This basically
covers what we have for you

1073
00:38:47,350 --> 00:38:49,370
for new stuff, but there's
so much more.

1074
00:38:49,370 --> 00:38:51,120
There's a lot of things we
didn't get to cover.

1075
00:38:51,120 --> 00:38:52,730
SETH LADD: We asked for the
three-hour slot and they

1076
00:38:52,730 --> 00:38:53,375
didn't give it to us.

1077
00:38:53,375 --> 00:38:54,520
JUSTIN FAGNANI: Yeah,
the keynote.

1078
00:38:54,520 --> 00:38:57,120
We could have filled
the keynote.

1079
00:38:57,120 --> 00:38:59,500
So we have an entire server-side
story with Dart.

1080
00:38:59,500 --> 00:39:01,660
It's very similar to Node and
we have an I/O library.

1081
00:39:01,660 --> 00:39:03,620
As Seth mentioned
earlier, we have

1082
00:39:03,620 --> 00:39:05,540
extensive testing libraries.

1083
00:39:05,540 --> 00:39:08,890
We also have a concurrency and
safety story in isolates that

1084
00:39:08,890 --> 00:39:09,840
we didn't get to cover.

1085
00:39:09,840 --> 00:39:11,270
And a lot more stuff.

1086
00:39:11,270 --> 00:39:14,650
So you should really find
out more about Dart.

1087
00:39:14,650 --> 00:39:15,700
SETH LADD: How do you find
out more about it?

1088
00:39:15,700 --> 00:39:18,980
Well, many different ways
for you to try out Dart.

1089
00:39:18,980 --> 00:39:22,235
Download the Dart SDK and the
Dart Editor from dartlang.org.

1090
00:39:22,235 --> 00:39:24,780
We're active on Google+ and
Twitter, et cetera.

1091
00:39:24,780 --> 00:39:26,350
We're also on GitHub as well.

1092
00:39:26,350 --> 00:39:28,560
So we've received many patches
from the community in

1093
00:39:28,560 --> 00:39:29,240
[? poll requests. ?]

1094
00:39:29,240 --> 00:39:30,910
We have external committers
as well.

1095
00:39:30,910 --> 00:39:32,520
We're active on Stack
Overflow.

1096
00:39:32,520 --> 00:39:34,220
And it's important to
understand, Dart is an open

1097
00:39:34,220 --> 00:39:35,110
source project.

1098
00:39:35,110 --> 00:39:37,030
BSD license, very permissive.

1099
00:39:37,030 --> 00:39:39,480
And so it's easy for you guys
to get involved in any

1100
00:39:39,480 --> 00:39:40,980
different way that works
for you guys.

1101
00:39:40,980 --> 00:39:42,560
JUSTIN FAGNANI: We've broken
up a lot of the smaller

1102
00:39:42,560 --> 00:39:44,910
projects into their own
repositories on GitHub.

1103
00:39:44,910 --> 00:39:47,050
And we've had a lot of external
contributors come in

1104
00:39:47,050 --> 00:39:49,720
that way because it's very
easy to get started.

1105
00:39:49,720 --> 00:39:52,410
SETH LADD: Lots more about Dart
here at I/O. Later today,

1106
00:39:52,410 --> 00:39:53,680
the Dart HTML talk.

1107
00:39:53,680 --> 00:39:54,650
Definitely check that out.

1108
00:39:54,650 --> 00:39:55,870
We have a Code lab on Friday.

1109
00:39:55,870 --> 00:39:58,060
So if you want to get your hands
dirty here working with

1110
00:39:58,060 --> 00:40:00,130
all the latest and greatest,
join us on Friday.

1111
00:40:00,130 --> 00:40:01,940
We'll be at office
hours as well.

1112
00:40:01,940 --> 00:40:03,460
And the demo booth, you
can see a lot of

1113
00:40:03,460 --> 00:40:06,170
this stuff in action.

1114
00:40:06,170 --> 00:40:08,090
So to sum it up, what's
the main takeaway?

1115
00:40:08,090 --> 00:40:10,020
Well, Dart-- we've got a
stable language now.

1116
00:40:10,020 --> 00:40:12,320
We have stable core libraries.

1117
00:40:12,320 --> 00:40:15,290
Dart compiles a JavaScript and
runs across modern browsers.

1118
00:40:15,290 --> 00:40:17,240
And it's really been an
involved platform now.

1119
00:40:17,240 --> 00:40:18,560
We've been out for, what?

1120
00:40:18,560 --> 00:40:21,220
Almost two years, one
and a half years?

1121
00:40:21,220 --> 00:40:23,660
We've gotten tons of feedback
from external developers,

1122
00:40:23,660 --> 00:40:25,850
internal customers, external
customers.

1123
00:40:25,850 --> 00:40:27,040
They've been telling
us what they like,

1124
00:40:27,040 --> 00:40:27,460
what they don't like.

1125
00:40:27,460 --> 00:40:28,450
We've put that all in.

1126
00:40:28,450 --> 00:40:30,790
And so what you see today is
a nice evolved platform.

1127
00:40:30,790 --> 00:40:32,180
And Google is committed
to Dart.

1128
00:40:32,180 --> 00:40:36,140
We have internal high-priority
projects inside using Dart.

1129
00:40:36,140 --> 00:40:39,620
And we're going to see this,
so that you can make it--

1130
00:40:39,620 --> 00:40:41,330
Dart is ready for your app.

1131
00:40:41,330 --> 00:40:42,660
That's the main point here.

1132
00:40:42,660 --> 00:40:46,460
Hopefully you liked
what you saw.

1133
00:40:46,460 --> 00:40:49,150
And we'll be around to answer a
lot of your questions here.

1134
00:40:49,150 --> 00:40:50,510
I think we can probably take
one or two questions.

1135
00:40:50,510 --> 00:40:52,060
But we'll be up at
the office hours

1136
00:40:52,060 --> 00:40:53,220
immediately after this talk.

1137
00:40:53,220 --> 00:40:54,860
And we'd love to hear what
you guys are building.

1138
00:40:54,860 --> 00:40:58,820
So with that, we're all set.

1139
00:40:58,820 --> 00:40:59,185
JUSTIN FAGNANI: Thanks.

1140
00:40:59,185 --> 00:40:59,895
SETH LADD: Thank you.

1141
00:40:59,895 --> 00:41:08,640
[APPLAUSE]

1142
00:41:08,640 --> 00:41:10,000
SETH LADD: We could take
a question or two

1143
00:41:10,000 --> 00:41:10,910
if anyone has any.

1144
00:41:10,910 --> 00:41:12,480
OK, cool.

1145
00:41:12,480 --> 00:41:15,610
AUDIENCE: Do you think we'll
see Dart on App Engine?

1146
00:41:15,610 --> 00:41:17,260
SETH LADD: I would personally
love to see that happen.

1147
00:41:17,260 --> 00:41:19,380
There's a bug in the issue
tracker for App Engine.

1148
00:41:19,380 --> 00:41:23,606
Go ahead and star that
and let them know.

1149
00:41:23,606 --> 00:41:24,050
OK.

1150
00:41:24,050 --> 00:41:24,325
Thanks.

1151
00:41:24,325 --> 00:41:25,400
We'll be around here.

1152
00:41:25,400 --> 00:41:26,650
Thank you.

1153
00:41:26,650 --> 00:41:29,992

