1
00:00:01,589 --> 00:00:07,670
>>Paul Lewis: So this
is device agnostic development and I'm Paul

2
00:00:07,670 --> 00:00:14,190
Lewis. I'm the guy looking confused over on
the left. Mostly on the right right now. I

3
00:00:14,190 --> 00:00:19,140
spend -- I'm on the Chrome developer relations
team. I spend my days at talking about and

4
00:00:19,140 --> 00:00:21,970
rendering performance.
>>Pete Beverloo: I'm Peter Beverloo. I'm a

5
00:00:21,970 --> 00:00:26,130
software engineer on the Chrome team. I work
on Chrome for Android. I mostly spend my time

6
00:00:26,130 --> 00:00:33,130
pushing the web platform forward.
>>Paul Lewis: So we ran a small survey and

7
00:00:33,790 --> 00:00:39,600
we asked developers two questions amongst
many. The questions we asked them were, which

8
00:00:39,600 --> 00:00:46,600
form factors do you support versus prioritize?
Not surprisingly, 96% of people said we support

9
00:00:49,610 --> 00:00:54,690
desktop. Pretty much everybody. Two-thirds
of people went for phone and tablet. As you

10
00:00:54,690 --> 00:01:01,120
can see on the prioritization side, 81% of
the 200 or so developers that we asked said,

11
00:01:01,120 --> 00:01:08,120
you know what, desktop is our top priority.
This leads us to a question, if we prioritize

12
00:01:15,270 --> 00:01:20,849
a single form factor, what happens? The answer
is probably quite obvious, right? We start

13
00:01:20,849 --> 00:01:27,849
to build on the expectations of capability.
We build expecting that we're going to have

14
00:01:28,259 --> 00:01:33,509
desktop-like performance. That we're going
to expect to see big screens, good GPs, good

15
00:01:33,509 --> 00:01:40,509
CPs, a lot of memory. All those kinds of things.
>>Pete Beverloo: So along comes new form factor.

16
00:01:40,509 --> 00:01:46,399
Such as mobile. What does this mean? Well,
we have been creating web sites for desktop

17
00:01:46,399 --> 00:01:51,709
experiences for quite a long time now. Desktop
experiences give us a number of advantages

18
00:01:51,709 --> 00:01:58,709
over more limited platforms such as mobile
devices. As an example, there's this big screen

19
00:01:58,929 --> 00:02:04,499
available to you which has a lot of space
for you to put content on or to put data on.

20
00:02:04,499 --> 00:02:09,689
But on mobile, there's a difference. It's
not just a screen size, which is different.

21
00:02:09,689 --> 00:02:14,250
It's a lot smaller. But it's also in terms
of a number of additional constraints such

22
00:02:14,250 --> 00:02:18,950
computational power. We create web sites using
a lot of JavaScript, for example, for scrolling

23
00:02:18,950 --> 00:02:23,879
or concordance, and while this works fine
and acceptable on a desktop machine, on a

24
00:02:23,879 --> 00:02:30,879
mobile, this will look janky. So along comes
new form factor. It's not just about desktop

25
00:02:37,269 --> 00:02:41,219
and mobile. The web actually goes quite a
bit further than that. This is something we've

26
00:02:41,219 --> 00:02:47,219
only started to see quite recently. Back in
the days, there used to be mobile devices

27
00:02:47,219 --> 00:02:53,590
which were capable of internet using imodes
or similar systems. They weren't really internet.

28
00:02:53,590 --> 00:02:57,700
You could see a web page. You could talk to
a server but the experience was quite limited.

29
00:02:57,700 --> 00:03:02,680
These days, mobile devices such as phones
and tablets, they are basically on par with

30
00:03:02,680 --> 00:03:07,790
desktop devices and they just work just like
a desktop machine. Of course, with a number

31
00:03:07,790 --> 00:03:14,790
of additional constraints. Now, we're see
more and more come to televisions or consoles.

32
00:03:14,920 --> 00:03:18,709
On a television, the screen is a lot bigger
but we also know the user is sitting away

33
00:03:18,709 --> 00:03:24,430
from the screen quite a bit further than is
the case with mobile device and desktop machine.

34
00:03:24,430 --> 00:03:29,430
Which means that as developers we actually
have to change how we create web sites. With

35
00:03:29,430 --> 00:03:36,430
console, be it a portable one or be it a stationary
one next to your television, the story changes

36
00:03:36,709 --> 00:03:43,709
completely altogether again and with portable
devices, such as consoles, they can be similar

37
00:03:44,530 --> 00:03:49,540
to mobile, like a telephone. But they could
be entirely different as well with different

38
00:03:49,540 --> 00:03:55,519
forms of inputs and different types of managing
your data which come with it. We really don't

39
00:03:55,519 --> 00:04:00,700
know. Like what is the next device? We've
got desktops, mobile, televisions, consoles.

40
00:04:00,700 --> 00:04:06,279
What will come next? Are there going to be
wearable computers? Could be anything.

41
00:04:06,279 --> 00:04:12,269
>>Paul Lewis: So the point we are trying to
make with all this is that it's just the web.

42
00:04:12,269 --> 00:04:17,030
Okay? We have this propensity for talking
about the mobile web. We don't talk about

43
00:04:17,030 --> 00:04:22,240
the desktop web or the TV web or the console
web. We just talk about the mobile web. That's

44
00:04:22,240 --> 00:04:27,370
fair enough to some degree. What we need to
start realizing, I think, is it's just the

45
00:04:27,370 --> 00:04:33,710
web. It's consumed through a number different
devices. A good experience matters no matter

46
00:04:33,710 --> 00:04:40,710
what the device. So then, becoming device
agnostic. If we figure we will have people

47
00:04:42,319 --> 00:04:47,120
connecting to size and applications through
a bunch of different devices, how can we start

48
00:04:47,120 --> 00:04:54,120
actually being device agnostic? So the grand
unified theory of devices. Sounds good. We

49
00:04:57,389 --> 00:05:03,430
figured we can actually turn this on its head.
We can actually start figuring out what the

50
00:05:03,430 --> 00:05:10,430
constraints are. Okay? Instead of device capability,
what about looking at the device constraint?

51
00:05:10,949 --> 00:05:15,750
We figured there are these three constraints.
We can assess every device we know about,

52
00:05:15,750 --> 00:05:20,870
and the ones we don't know about, the ones
coming tomorrow, in the same way. Network.

53
00:05:20,870 --> 00:05:24,960
How quickly can it pull stuff down on the
wire? What's the latency? What's the bandwidth?

54
00:05:24,960 --> 00:05:29,319
It it's network constraint, it's going to
be slow.

55
00:05:29,319 --> 00:05:33,370
Compute constraint. So how quickly can it
process information? How much memory has it

56
00:05:33,370 --> 00:05:40,050
got? Is it good at calculating my styles and
laying out my page? What's the CPU like? The

57
00:05:40,050 --> 00:05:47,050
last one is a giant, shiny monkey head. How
quickly can it push pixels around the screen?

58
00:05:48,990 --> 00:05:55,289
Does it have a good GPU? When we start actually
start looking at it from this perspective,

59
00:05:55,289 --> 00:05:59,960
what we can start to realize is if we distance
ourselves from these constraints, if we start

60
00:05:59,960 --> 00:06:05,190
planning for these constraints, then what
we realize is that we are, in effect, becoming

61
00:06:05,190 --> 00:06:10,050
agnostic to them. So that when we hit a device
with one or more of these constraints, that

62
00:06:10,050 --> 00:06:15,250
we are not actually as bothered by it. So
instead of relying on the capabilities of

63
00:06:15,250 --> 00:06:19,949
a desktop, we are now going to spin it on
its head, look at these constraints in turn,

64
00:06:19,949 --> 00:06:24,599
figure out what comes up and how we can distance
ourselves from them.

65
00:06:24,599 --> 00:06:31,389
>>Pete Beverloo: So let's look at a few of
these device types and map them against constraints.

66
00:06:31,389 --> 00:06:36,379
This creates quite an interesting matrix.
I apologize to those of you in the back. It

67
00:06:36,379 --> 00:06:41,389
will be extremely hard to read. I'll just
name what's on the slides. On a desktop machine,

68
00:06:41,389 --> 00:06:46,289
the network will generally be quite good.
You will be connected to your home DSL connection

69
00:06:46,289 --> 00:06:52,009
which will be quite performant. Computational
power will be decent, even for older desktop

70
00:06:52,009 --> 00:06:56,689
machines while they are still better than
mobile. Rendering performance will be decent

71
00:06:56,689 --> 00:07:01,240
because they are multipurpose machines. They
are not just created for a single, streaming

72
00:07:01,240 --> 00:07:07,009
video. So they will be able to display web
sites. And the screen is big. Maybe not as

73
00:07:07,009 --> 00:07:12,770
big as a television in terms of physical size
but often you have a monitor of maybe 20 or

74
00:07:12,770 --> 00:07:18,800
24 inches width and, as a developer, that
gives you a lot of space to play with. On

75
00:07:18,800 --> 00:07:24,050
mobile it's a little bit different. With a
mobile device you can be on the move at any

76
00:07:24,050 --> 00:07:31,050
random time and you cannot rely on a network
connection to always be available. So network

77
00:07:31,139 --> 00:07:36,120
conditions are quite bad. Computational power
can be okay. There's different classes of

78
00:07:36,120 --> 00:07:43,120
mobile devices. Tablets are, of course, entirely
different from phones. But even within a single

79
00:07:43,330 --> 00:07:48,509
class, such as a phone, there can be quite
a lot of differences. We've got phones over

80
00:07:48,509 --> 00:07:55,509
$500, $600. There's phones for $50, and computational
power will rely a lot on the capabilities

81
00:07:55,599 --> 00:08:01,250
of the actual device. Rendering performance
will be quite bad. We are trying to get to

82
00:08:01,250 --> 00:08:06,330
60 frames per second, but it turns out to
be really difficult to get there on any platform.

83
00:08:06,330 --> 00:08:12,039
And the screen is quite small. That's the
physical screen size. While the actual logical

84
00:08:12,039 --> 00:08:16,530
screen size, so the number of pixels which
have to be shown to the user can be a lot

85
00:08:16,530 --> 00:08:22,490
bigger because we have got all these high
resolution fonts. For televisions, well, they

86
00:08:22,490 --> 00:08:27,830
are standing in your house. I don't often
walk around with a television behind my arm.

87
00:08:27,830 --> 00:08:33,060
>>Paul Lewis: What? I do.
>>Pete Beverloo: Okay. So the network conditions

88
00:08:33,060 --> 00:08:37,750
will generally be similar to your normal desktop
computer. Computational power is bad. It's

89
00:08:37,750 --> 00:08:42,580
meant for showing video, not for showing web
sites. Rendering performance will be bad for

90
00:08:42,580 --> 00:08:47,200
the same reasons because the device really
has been made for a single purpose. And the

91
00:08:47,200 --> 00:08:51,130
screen is pretty big but the resolution can
be smaller and in some cases even smaller

92
00:08:51,130 --> 00:08:57,400
than a mobile device. Now, for consoles, it's
quite similar to mobile. It depends on the

93
00:08:57,400 --> 00:09:01,780
kind of console really. You can be on the
move at all times. Computational power, they

94
00:09:01,780 --> 00:09:08,760
are meant for games for interactive imaging
while web sites can be static content. Rendering

95
00:09:08,760 --> 00:09:14,770
performance, again, it really depends on the
device. And the same goes for screen size.

96
00:09:14,770 --> 00:09:19,640
And for the new class of devices, we just
don't know. We have no idea what's it going

97
00:09:19,640 --> 00:09:22,160
to get us.
>>Paul Lewis: Actually, to be fair. If we

98
00:09:22,160 --> 00:09:27,730
take a step back. We actually don't know on
any of these because let's say desktop, take

99
00:09:27,730 --> 00:09:32,040
that for a second, it could be a laptop as
well. Now, we said good Internet network,

100
00:09:32,040 --> 00:09:35,300
but what if you have tethered your phone?
>>Pete Beverloo: Or what if you have a dial-up

101
00:09:35,300 --> 00:09:38,450
Internet connection?
>>Paul Lewis: Yeah. So at this point actually

102
00:09:38,450 --> 00:09:44,140
all bets are off, right? Because on any of
these you can find an exception. Okay?

103
00:09:44,140 --> 00:09:50,850
>>Pete Beverloo: So to set reality is that
everything in this matrix is a maybe. We just

104
00:09:50,850 --> 00:09:55,880
don't know. And the only real way to figure
out what you need to optimize for your web

105
00:09:55,880 --> 00:10:00,950
site is not to just blindly apply all the
best practices you can find around the Internet.

106
00:10:00,950 --> 00:10:05,530
You need to measure and you need to look at
your statistics. Go to whatever statistics

107
00:10:05,530 --> 00:10:11,340
you have. Look at the devices which your visitors
are actually using. Optimize for these devices.

108
00:10:11,340 --> 00:10:15,970
Use the number of available APIs which we
will come back to later in the presentation.

109
00:10:15,970 --> 00:10:22,970
Actually measure what your performance bottlenecks
are. One way of measure what's going on are

110
00:10:24,400 --> 00:10:30,710
your Chrome DevTools. This is built into Google
Chrome in all the release channels. It makes

111
00:10:30,710 --> 00:10:36,530
it entirely possible to accurately measure
any aspect at any time what's happening on

112
00:10:36,530 --> 00:10:42,580
your page in terms of network computational
requirements and rendering as well. We've

113
00:10:42,580 --> 00:10:47,310
got a series of videos available on YouTube.
Called the breakpoints. The screen shot here

114
00:10:47,310 --> 00:10:54,190
is showing Paul Irish on the first few seconds
of a presentation which gives you a video

115
00:10:54,190 --> 00:10:59,810
introduction to a number of the features available
on DevTools. There was a talk yesterday about

116
00:10:59,810 --> 00:11:05,060
Chrome DevTools resolution which will have
shown you about a number of new features which

117
00:11:05,060 --> 00:11:10,510
have recently become available. And we've
recently updated the DevTools documentation

118
00:11:10,510 --> 00:11:14,450
which you can definitely check out as well
and which contains a lot of information about

119
00:11:14,450 --> 00:11:17,960
how to measure exactly what's going on on
your pages.

120
00:11:17,960 --> 00:11:24,960
>>Paul Lewis: Okay. So we've established that
we can be on any device and we can't really

121
00:11:25,580 --> 00:11:30,500
predict exactly what the constraints are going
to be for that device. Now let's step into

122
00:11:30,500 --> 00:11:35,230
network computer rendering. This is actually
essentially a performance talk by the back

123
00:11:35,230 --> 00:11:40,010
door. If you have been up to the third floor
and seen in the Chrome area, we have a performance

124
00:11:40,010 --> 00:11:43,830
area and network computer rendering are in,
in fact, three areas. If you have not been,

125
00:11:43,830 --> 00:11:47,890
you should stop by. But what we are going
do is we are going to step through the common

126
00:11:47,890 --> 00:11:51,380
issues that we see on each of these three
areas and we are going to try to find ways

127
00:11:51,380 --> 00:11:56,140
of distancing ourselves from those constraints
so that irrespective of which device we are

128
00:11:56,140 --> 00:12:00,010
actually hitting, if we have hit that constraint
we have done everything that we possibly can

129
00:12:00,010 --> 00:12:06,880
to try to make that a non-issue.
>>Pete Beverloo: So the first thing to keep

130
00:12:06,880 --> 00:12:12,680
in mind is the page load time. This basically
describes the time it takes for the user to

131
00:12:12,680 --> 00:12:17,470
start a navigation action like clicking on
a link or entering a link interbrowser address

132
00:12:17,470 --> 00:12:22,050
bar until the time that they see the page
and that they are actually able to use it.

133
00:12:22,050 --> 00:12:28,790
Now, you've got all your visitors. If your
page on a mobile device takes more than three

134
00:12:28,790 --> 00:12:35,790
seconds to load, 57% of your visitors will
go away. They will just leave. They will go

135
00:12:36,460 --> 00:12:40,770
elsewhere. They might search for an alternative.
They may know of an alternative and they are

136
00:12:40,770 --> 00:12:47,310
gone for the day basically. Now it gets worse.
For all these visitors, if your page takes

137
00:12:47,310 --> 00:12:54,310
more than three seconds to load, 46% will
not return. They will find a competitor of

138
00:12:54,920 --> 00:12:58,870
yours. They will find an alternative source
of the data or the information which are giving

139
00:12:58,870 --> 00:13:04,930
to them and start preferring the other web
site just because it loads a little bit faster.

140
00:13:04,930 --> 00:13:11,240
And probably the worst statistic is that 22%
of your visitors will tell their friends to

141
00:13:11,240 --> 00:13:17,390
not use your web site. Now, let that sink
in for a little bit. That means that over

142
00:13:17,390 --> 00:13:23,500
one in five visitors of your mobile web site
will tell their friends to not visit your

143
00:13:23,500 --> 00:13:30,500
site if your page takes more than three seconds
to load. That's quite a lot of impact and

144
00:13:30,510 --> 00:13:35,260
one thing to keep in mind here is that the
perceived loading time of a web page is actually

145
00:13:35,260 --> 00:13:40,080
15% higher than the actual loading time. And
it gets worse because when they are talking

146
00:13:40,080 --> 00:13:46,880
to their friends about this, they will remember
loading time which is up to 35% slower of

147
00:13:46,880 --> 00:13:51,330
what it actually was. So while it actually
could have been three seconds, in their memory

148
00:13:51,330 --> 00:13:58,330
it may be up to five seconds or more. So there
are a few things we can do. Probably the biggest

149
00:13:59,670 --> 00:14:05,320
contributor to having a big load time for
your web pages is having a huge number of

150
00:14:05,320 --> 00:14:12,320
requests on your page. Now, for every request
to your page, we can look at costs implied

151
00:14:13,220 --> 00:14:18,750
by it and we can split it up in three different
ones. Firstly, there is the latency cost.

152
00:14:18,750 --> 00:14:23,040
For each of these requests, for the resources
which could be an image or style sheet, we

153
00:14:23,040 --> 00:14:28,510
need to make a connection to the server -- well,
in some cases because in other cases we may

154
00:14:28,510 --> 00:14:33,800
be able to re-use the connection. We need
to request the resource, get a reply and that

155
00:14:33,800 --> 00:14:38,070
could take a little bit of time, especially
if the resource is hosted on a different server,

156
00:14:38,070 --> 00:14:44,620
in which case a DNS lookup might be necessary.
Now, for big resources such as images, bandwidth

157
00:14:44,620 --> 00:14:51,620
may be a constraint. If I am on a 3G connection
and I'm sitting on a train, then it will take

158
00:14:53,230 --> 00:14:59,450
a while for that image to be available on
my mobile device. Of course, there is a financial

159
00:14:59,450 --> 00:15:05,560
cost. This is not just about visitors which
you may lose if your site takes quite a long

160
00:15:05,560 --> 00:15:10,850
time to load. But Paul and I are from the
United Kingdom and if we want to use the mobile

161
00:15:10,850 --> 00:15:16,430
Internet on our normal phones here in the
United States, then it costs us up to $8 per

162
00:15:16,430 --> 00:15:23,430
megabyte. You need to have a really good server
or web site if I want to use it that cost.

163
00:15:23,800 --> 00:15:28,380
So probably the easiest thing to do here is
obsolete a number of these requests. For every

164
00:15:28,380 --> 00:15:34,180
single one of the resources on your page,
ask yourself, do you really need it? Can you

165
00:15:34,180 --> 00:15:40,420
maybe get around by inlining it on the page?
By concatenating style sheets, so having several

166
00:15:40,420 --> 00:15:44,660
style sheets in a single file? Or can you
perhaps minimize them to reduce bandwidth

167
00:15:44,660 --> 00:15:51,060
cost? And making optimizations such as these
will often have a big impact in a base loading

168
00:15:51,060 --> 00:15:53,980
time performance of your web sites.
>>Paul Lewis: Now, a lot of people already

169
00:15:53,980 --> 00:15:58,730
do this one, right? Most people when you speak
to them, they say, yeah, we can concatenate

170
00:15:58,730 --> 00:16:05,730
min files. The next thing we want to talk
about is reducing the image overhead. Statistic

171
00:16:06,290 --> 00:16:10,540
that you may have heard of and if you haven't
and it's the first time, really good one to

172
00:16:10,540 --> 00:16:17,540
put in your head, 60% of web traffic, 60%
of the average web page is images. And that

173
00:16:18,640 --> 00:16:24,230
gives us a huge opportunity for optimizing
our network. Okay, can we change formats?

174
00:16:24,230 --> 00:16:31,110
Now, in the case of WebP, by switching to
it, the Chrome web store saved several terabytes

175
00:16:31,110 --> 00:16:36,670
of transfer every day. Now, it may not be
that it is going to save you that much of

176
00:16:36,670 --> 00:16:41,930
transfer. You can immediately realize that
actually instead of JPEG I should be using

177
00:16:41,930 --> 00:16:48,160
pings or pings instead of JPEG, or gifs maybe
or even WebP. It depends on the actual image

178
00:16:48,160 --> 00:16:53,150
and what you are trying to achieve and so
forth. But spend some time figuring out whether

179
00:16:53,150 --> 00:16:57,130
you can change formats, whether you can change
quality and that will potentially save you

180
00:16:57,130 --> 00:17:01,930
an awful lot of data. The next thing is actually
request images of the size you need. Responsive

181
00:17:01,930 --> 00:17:08,930
web design has become all the rage and it's
really quite cool. But there is this problem

182
00:17:09,299 --> 00:17:15,250
with it which is that people often request
their full-size images and then the user ends

183
00:17:15,250 --> 00:17:22,250
up paying a tax, as it were. We rely on client
side resizing to get it down but we end up

184
00:17:22,500 --> 00:17:27,240
requesting a much larger file in some cases
than we actually need. There are loads of

185
00:17:27,240 --> 00:17:32,370
things you can do on the server side to actually
let you scale down and cache a smaller version

186
00:17:32,370 --> 00:17:35,889
of the image. If you are not doing that, take
a look at that one. The last one is, do you

187
00:17:35,889 --> 00:17:42,889
even need an image? Controversial. You could
get away with SVG in some cases, web fonts

188
00:17:43,659 --> 00:17:50,480
with icon glyphs. Have a look at those and
play around. See if you can actually get rid

189
00:17:50,480 --> 00:17:54,779
of some of your images. 60% of the average
page is going to be images. So if you can

190
00:17:54,779 --> 00:18:01,259
get rid of that, that saves us a ton.
>>Peter Beverloo: One of the solutions available

191
00:18:01,259 --> 00:18:08,259
to you if you have control over your server
itself, is that you can look into using mod

192
00:18:09,029 --> 00:18:15,320
PageSpeed. Mod PageSpeed is a plug-in made
by Google which basically gives you a free

193
00:18:15,320 --> 00:18:20,279
pass to a quicker web site. What it does,
it looks at your web page before sending it

194
00:18:20,279 --> 00:18:26,879
to the user. It will look into ways to optimize
your page by inlining resources, by concatenating

195
00:18:26,879 --> 00:18:32,200
style sheet files together and by doing a
number of number of optimization steps which

196
00:18:32,200 --> 00:18:37,840
just generally make it faster. Of course,
this does require you to be in control of

197
00:18:37,840 --> 00:18:44,159
your web page -- of your web server, I'm sorry.
If you are not, there's another tool available

198
00:18:44,159 --> 00:18:51,000
called PageSpeed insights. Many of you will
work on the front end of a web site and this

199
00:18:51,000 --> 00:18:56,379
tool is as simple as enter the URL of your
page, click on a button, it will start downloading

200
00:18:56,379 --> 00:19:00,110
your page. It will start analyzing it. It
will show up with a number of suggestions

201
00:19:00,110 --> 00:19:07,110
and how to optimize the page itself and make
it faster to load and dissipate to the user.

202
00:19:07,360 --> 00:19:14,259
Now, of course these two tools will only do
-- will only optimize your page to the best

203
00:19:14,259 --> 00:19:19,419
of their abilities. But they do this by looking
at the average space, what they are doing,

204
00:19:19,419 --> 00:19:26,220
and applying these rules of your site. Now,
your web sites are not average. They are special

205
00:19:26,220 --> 00:19:31,350
because, in a way, there is no average web
site, and the only real way optimize the page

206
00:19:31,350 --> 00:19:37,340
itself by doing it yourself and looking at
what pieces of information or resources on

207
00:19:37,340 --> 00:19:43,080
your page actually impact or reduce performance.
Now, we have already spoken a little bit about

208
00:19:43,080 --> 00:19:48,980
DevTools which make it possible for you to
look at exactly which parts are taking a long

209
00:19:48,980 --> 00:19:53,330
time in the loading process of the web page.
But then there are API available to you as

210
00:19:53,330 --> 00:19:59,220
their resource timing API which exposes high-fidelity
information about most of the resources which

211
00:19:59,220 --> 00:20:03,870
you have included on the page itself and gets
you insight into how long it took to actually

212
00:20:03,870 --> 00:20:10,320
look up the DNS for that resource, to connect
to the server or to download to resource.

213
00:20:10,320 --> 00:20:14,539
And especially if you have blocking resources
such as scripts, it can be a great way to

214
00:20:14,539 --> 00:20:18,850
actually figure out which script is blocking
your page from showing up quickly.

215
00:20:18,850 --> 00:20:24,679
>>Paul Lewis: Okay. So we've talked about
the kind of things that you can get into for

216
00:20:24,679 --> 00:20:29,309
actually transferring your sites and apps
down to end users. Now we actually step into

217
00:20:29,309 --> 00:20:36,309
the runtime-y bit. It's actually running.
And this is the bit where we talk about compute.

218
00:20:36,470 --> 00:20:40,600
So we've got everything downloaded or we've
got enough to get going, and now we want to

219
00:20:40,600 --> 00:20:44,480
talk about what that actually involves to
solve for compute.

220
00:20:44,480 --> 00:20:48,080
So the first thing you need to do is define
this term "jank." Now, you've probably heard

221
00:20:48,080 --> 00:20:52,220
it over the course of the last few days. Let's
define it again just in case.

222
00:20:52,220 --> 00:20:57,830
Chrome is synchronized to the refresh rate
of the device. Now, that's 60 hertz. That

223
00:20:57,830 --> 00:21:03,929
means you've got just about 16 1/2 milliseconds
to get everything done. And that includes

224
00:21:03,929 --> 00:21:08,440
Chrome's housekeeping, it includes your code
-- and that's a bunch of things like layout,

225
00:21:08,440 --> 00:21:14,249
recalc style, paint, composite, JavaScript
-- all that stuff. 16 milliseconds. I don't

226
00:21:14,249 --> 00:21:18,669
get much done in 16 milliseconds, but Chrome
really, really does.

227
00:21:18,669 --> 00:21:25,629
We call this the frame budget, and if we don't
hit that frame budget, users notice. It's

228
00:21:25,629 --> 00:21:29,960
kind of this hitching. You know, when they
scroll and it hitches and hiccups? That's

229
00:21:29,960 --> 00:21:33,049
what we call "jank."
So when we talk about "jank" in the coming

230
00:21:33,049 --> 00:21:36,690
slides, that's what we're referring to. We're
talking about busting that frame budget of

231
00:21:36,690 --> 00:21:43,690
most likely 16 1/2 milliseconds.
So the first thing I want to talk about in

232
00:21:44,210 --> 00:21:50,490
the compute area is style recalculations.
Now, it's very common when we do apps that

233
00:21:50,490 --> 00:21:55,970
we change class on the body, okay? And you
do that for maybe state and you maybe even

234
00:21:55,970 --> 00:22:01,289
do it for styling. The problem is, the size
of the tree that's affected can be huge. Now,

235
00:22:01,289 --> 00:22:05,889
you see on the left-hand side -- hopefully
you can see -- I was changing a class on the

236
00:22:05,889 --> 00:22:12,450
body and I was affecting nearly twenty- -- just
over 23,000 elements by doing that. The recalculation

237
00:22:12,450 --> 00:22:17,009
style effort then was 20 milliseconds.
Now, this is Canary that's telling us the

238
00:22:17,009 --> 00:22:20,370
elements affected so if you haven't seen that
feature, it's a really useful thing when you're

239
00:22:20,370 --> 00:22:22,299
trying to figure out kind of what was the
impact.

240
00:22:22,299 --> 00:22:26,539
There's a corresponding one for layout as
well which tells you the scope and the size

241
00:22:26,539 --> 00:22:30,340
of the layout calculation.
So we've changed the body, 23,000 elements,

242
00:22:30,340 --> 00:22:35,320
20 milliseconds.
I knew that I actually wanted to affect 6

243
00:22:35,320 --> 00:22:37,970
and when I did that, it was a fraction of
a millisecond.

244
00:22:37,970 --> 00:22:42,690
Now, it sounds obvious but only change the
things that you need to change. Go and have

245
00:22:42,690 --> 00:22:49,330
a look at your app, see whether you're actually
overdoing your style recalculation.

246
00:22:49,330 --> 00:22:54,789
Layout thrashing. If you've not seen this
one before, this is quite a fascinating one,

247
00:22:54,789 --> 00:22:57,169
really.
So this little bit of JavaScript at the top

248
00:22:57,169 --> 00:23:02,049
allows us to get the target -- a thing called
"target" -- from the DOM, and what we're going

249
00:23:02,049 --> 00:23:05,669
to do is we're going to go through a bunch
of other elements and we're going to ask -- we're

250
00:23:05,669 --> 00:23:09,249
going to set their width to match the target's
width. Pretty trivial stuff to do. What is

251
00:23:09,249 --> 00:23:14,769
that, three lines of code plus a comment?
Okay. The first thing we need to notice is

252
00:23:14,769 --> 00:23:19,200
that asking for offset width is going to cause
Chrome to do a layout.

253
00:23:19,200 --> 00:23:22,669
So it goes off and it says, "All right. What's
the left, the top, the width, the height?

254
00:23:22,669 --> 00:23:26,129
What do I need to know about all the elements
in the page to be able to give you a good

255
00:23:26,129 --> 00:23:29,620
answer on offset width?"
So it goes off and it does that.

256
00:23:29,620 --> 00:23:36,549
The next thing is, that first element gets
its style width value set to the target's

257
00:23:36,549 --> 00:23:40,169
width.
The problem is, by doing that, we just invalidated

258
00:23:40,169 --> 00:23:44,679
the layout calculation that we've just done.
So then the next time around the loop, we

259
00:23:44,679 --> 00:23:47,940
ask Chrome to do a potentially very expensive
layout again.

260
00:23:47,940 --> 00:23:53,639
So we're doing this get, set, get, set, get,
set, get, set, get, set. And the problem is

261
00:23:53,639 --> 00:23:56,769
this adds up really quickly. Especially when
layout is expensive.

262
00:23:56,769 --> 00:24:02,769
What we should be doing is getting once and
setting many. And it probably makes sense

263
00:24:02,769 --> 00:24:07,409
when you hear it in that sense.
The thing is to realize that offset width

264
00:24:07,409 --> 00:24:11,909
is actually going to cause the layout to happen.
And you can Google that, how to not trigger

265
00:24:11,909 --> 00:24:18,379
a layout in Webkit, and you'll see a very
good blog post that will tell you which ones

266
00:24:18,379 --> 00:24:22,649
in Webkit and Blink will cause a layout to
happen.

267
00:24:22,649 --> 00:24:26,610
So avoid layout thrashing.
Two very simple things there: Layout and style

268
00:24:26,610 --> 00:24:32,179
calculations.
>>Peter Beverloo: So a browser has a very

269
00:24:32,179 --> 00:24:39,179
particular set of skills. Skills it has acquired
over a short, but quite eventful, career.

270
00:24:39,240 --> 00:24:44,889
You should not do in JavaScript in an imperative
way what you can do in a declarative way.

271
00:24:44,889 --> 00:24:50,499
Animations and transitions are excellent examples
of that. Five years ago, six years ago, perhaps

272
00:24:50,499 --> 00:24:56,480
even more, we had all these libraries such
as jQuery or Dojo, which are animation libraries,

273
00:24:56,480 --> 00:25:01,559
and it allowed you to animate items on your
page. It allows you to change the left property

274
00:25:01,559 --> 00:25:05,309
from -- from zero to a thousand and move an
element horizontally over your page without

275
00:25:05,309 --> 00:25:09,299
the user having to do anything at all, and
that's awesome.

276
00:25:09,299 --> 00:25:16,299
But this is really costly because every time
the frame does something -- and often a library

277
00:25:16,320 --> 00:25:21,869
internally sets the timer to try and match
the frame budget of the browser -- it needs

278
00:25:21,869 --> 00:25:25,899
to look at the position, it needs to do a
re-layout, and all of these are really expensive

279
00:25:25,899 --> 00:25:29,600
operations.
Now, there are excellent alternatives available

280
00:25:29,600 --> 00:25:34,230
to this in CSS, to do it in a declarative
way, and by using a declarative way, you're

281
00:25:34,230 --> 00:25:38,970
actually saying -- telling the browser what
you want it to do instead of telling the browser

282
00:25:38,970 --> 00:25:44,350
what it has to do.
And by telling the browser your goal, you're

283
00:25:44,350 --> 00:25:49,049
basically saying, "Okay. I want you to do
this effect, but please do it in the best

284
00:25:49,049 --> 00:25:56,049
way you can do it for me." And by using the
CSS transitions module or the CSS animation

285
00:25:56,399 --> 00:26:02,129
module, the browser is actually able to optimize
all this transcript code away from you. It

286
00:26:02,129 --> 00:26:06,249
can do these animations, in some cases, on
a different thread and this will look a lot

287
00:26:06,249 --> 00:26:13,230
better and a lot less janky for the user,
while also taking a lot less CPU and, well,

288
00:26:13,230 --> 00:26:17,970
it doesn't eat away from your frame budget
and it works regardless of many of the constraints

289
00:26:17,970 --> 00:26:23,590
of the device.
Up until a few years ago, fixed position was

290
00:26:23,590 --> 00:26:29,200
unreliable. It kind of could stick around
in the viewport. It could be janky if you

291
00:26:29,200 --> 00:26:33,879
were scrolling. Now, lately, in pretty much
all big mobile browsers, this has been fixed,

292
00:26:33,879 --> 00:26:36,950
and of course it works in all desktop browsers
as well.

293
00:26:36,950 --> 00:26:40,950
So if you have an element which should always
be available in the viewport of the page itself,

294
00:26:40,950 --> 00:26:47,480
just use position ficky -- sticky -- no, position
fixed and don't use JavaScript to keep it

295
00:26:47,480 --> 00:26:51,249
in exactly that position, using the scrolling
position, for example.

296
00:26:51,249 --> 00:26:54,409
>>Paul Lewis: But you could use position sticky.
What would you use position sticky for?

297
00:26:54,409 --> 00:26:57,909
>>Peter Beverloo: Well, position sticky actually
is a new experimental feature in Chrome.

298
00:26:57,909 --> 00:26:59,909
>>Paul Lewis: Really?
>>Peter Beverloo: Yeah. You can go to the

299
00:26:59,909 --> 00:27:05,200
Chrome flex page. You can enable it for Chrome
for Android as well. And position sticky is

300
00:27:05,200 --> 00:27:10,860
somewhat like a fixed position element, but
if the parent element is not inside of the

301
00:27:10,860 --> 00:27:15,249
viewport itself, so if it's scrolled away
somewhere, then it will just be an inflow

302
00:27:15,249 --> 00:27:20,389
element. If the parent element comes in the
page, then it will make sure that the element

303
00:27:20,389 --> 00:27:26,999
is -- that the sticky positioned element is
visible. But if the parent element kind of

304
00:27:26,999 --> 00:27:32,869
moves out of the viewport but still is visible,
then the element will stick around in the

305
00:27:32,869 --> 00:27:38,350
viewport as if it was fixed position. And
an example you might know which uses this

306
00:27:38,350 --> 00:27:43,690
quite a lot is an address book. If you have
a lot of names, then the header which contains

307
00:27:43,690 --> 00:27:47,909
the first letter of the names which are currently
being displayed may stick around at the top

308
00:27:47,909 --> 00:27:52,879
of the viewport for a little while until the
next letter is up.

309
00:27:52,879 --> 00:27:57,779
And the fourth big point is keep your invent
listener code to a minimum. Some event handlers

310
00:27:57,779 --> 00:28:02,769
such as scrolling events will be called many,
many, many times per second, sometimes even

311
00:28:02,769 --> 00:28:08,489
multiple times per frame, and any processing
you do in these handlers will eat away from

312
00:28:08,489 --> 00:28:14,549
your frame budget and this will definitely
limit the time Chrome has to display your

313
00:28:14,549 --> 00:28:17,639
Web page and, as a result, you might miss
frames.

314
00:28:17,639 --> 00:28:21,129
>>Paul Lewis: One thing you can definitely
do with that one is, say you're doing something

315
00:28:21,129 --> 00:28:25,909
in your scroll handler. Just get it to store
the last known value. Okay? And then schedule

316
00:28:25,909 --> 00:28:29,610
up a requestAnimationFrame. Because what will
happen is most of the time you have like four

317
00:28:29,610 --> 00:28:33,549
or five of these running, okay? You get like
four or five in the frame, but you actually

318
00:28:33,549 --> 00:28:38,139
only care about the last one, so you just
store the value and then set a requestAnimationFrame

319
00:28:38,139 --> 00:28:41,909
to actually deal with the last known value.
This is called de-bouncing in some places

320
00:28:41,909 --> 00:28:46,399
or -- yeah, "de-bouncing" is the most common
name for it. And just basically rather than

321
00:28:46,399 --> 00:28:52,139
running that expensive code in your scroll
handler, just keep the value and run one handler

322
00:28:52,139 --> 00:28:57,419
at the end.
Okay. So we've talked about network, we've

323
00:28:57,419 --> 00:29:02,629
talked about compute, so now let's take a
look at some of the stuff that happens inside

324
00:29:02,629 --> 00:29:09,110
of render.
Now, I have DevTools open here and it's captured

325
00:29:09,110 --> 00:29:14,019
something which is quite expensive on the
paint side of things, and if you look, we've

326
00:29:14,019 --> 00:29:19,039
twittled down one of the pane records and
we spent 13 milliseconds decoding a JPEG.

327
00:29:19,039 --> 00:29:25,710
Now, we have 16 milliseconds to do everything,
not just paint. And then we spent a further

328
00:29:25,710 --> 00:29:31,610
71 milliseconds dealing with the resize.
Now, this is what I was talking about before

329
00:29:31,610 --> 00:29:38,039
about responsive web design is that there's
potentially a second tax. And before, we talked

330
00:29:38,039 --> 00:29:41,519
about reducing image overhead but we talked
about it from the network constraint. We also

331
00:29:41,519 --> 00:29:46,159
have a render constraint because we actually
have to process these images.

332
00:29:46,159 --> 00:29:51,649
So actually, just getting the -- the smallest
possible image and in the correct dimensions

333
00:29:51,649 --> 00:29:58,590
is actually extremely advantageous.
So check out DevTools if you've not seen that

334
00:29:58,590 --> 00:30:02,869
feature. That's really useful to actually
find out your decodes and your resizes.

335
00:30:02,869 --> 00:30:08,940
Paint costs. So whenever you scroll or you're
interacting with your page, the things that

336
00:30:08,940 --> 00:30:13,139
change or the things that appear on screen,
they need to get painted. And since painting

337
00:30:13,139 --> 00:30:17,899
is actually quite an expensive thing, depending
on the styles that you apply, we have to keep

338
00:30:17,899 --> 00:30:20,559
it to a minimum.
So there are two things that are actually

339
00:30:20,559 --> 00:30:27,350
involved in reducing paint costs, the first
of which is actually reducing the size of

340
00:30:27,350 --> 00:30:30,700
the area that got painted.
So you see I've got show paint rectangle switched

341
00:30:30,700 --> 00:30:35,009
on here. So you go into DevTools, hit the
cog, switch on show paint rectangles, and

342
00:30:35,009 --> 00:30:37,970
then interact with your page.
Now, as I roll over these elements, you can

343
00:30:37,970 --> 00:30:41,399
see that they're flashing red which is Chrome's
saying, "I repainted those."

344
00:30:41,399 --> 00:30:46,779
But watch there. When I scrolled, the whole
page flashed red. Now, that should be a warning

345
00:30:46,779 --> 00:30:51,879
to you that the entire page needed painting,
and that's potentially an expensive thing

346
00:30:51,879 --> 00:30:55,950
and it's the kind of thing that gives you
those big green bars, okay? Now, there's a

347
00:30:55,950 --> 00:31:01,720
very specific reason for this one, but I'll
let you figure out what that is.

348
00:31:01,720 --> 00:31:05,440
The thing to know is that you're looking for
those smaller areas. The question you should

349
00:31:05,440 --> 00:31:09,600
be asking yourself is, "Am I seeing the bits
that are getting repainted that I thought

350
00:31:09,600 --> 00:31:13,879
were going to get repainted? Is it predictable
to me?" As in, "I rolled over this and I expected

351
00:31:13,879 --> 00:31:17,539
it to repaint. Yes, it did."
When I scrolled, I didn't expect to see the

352
00:31:17,539 --> 00:31:20,049
whole thing flash or the whole screen flash,
right? So there's something to look at there.

353
00:31:20,049 --> 00:31:27,049
The second thing, once we've reduced the size
of the paint areas is to then reduce the complexity

354
00:31:27,379 --> 00:31:32,999
of the paint areas, so we've got this other
tool that's fantastic. It's called -- called

355
00:31:32,999 --> 00:31:37,389
continuous page repainting. And what it does
is it puts Chrome into a mode where it forces

356
00:31:37,389 --> 00:31:42,629
Chrome to repaint the whole page every frame.
Okay? And you see it switched on there. It

357
00:31:42,629 --> 00:31:46,389
puts this little chart in the top right-hand
corner with the number of milliseconds that

358
00:31:46,389 --> 00:31:49,259
it took to paint the page.
Now, what we can do is we start switching

359
00:31:49,259 --> 00:31:54,649
off styles, and in this particular case, switching
off box shadow or border radius is the one

360
00:31:54,649 --> 00:31:58,279
that's actually dropping that time to paint
really far down.

361
00:31:58,279 --> 00:32:03,070
Now, I'd much rather you didn't walk out of
here saying "Box shadow is bad. Border radius

362
00:32:03,070 --> 00:32:06,769
is bad. We shan't do these." That's not what
we want you to do. What we want you to do

363
00:32:06,769 --> 00:32:12,980
is realize that your styles have a corresponding
cost and there is a tool in DevTools that

364
00:32:12,980 --> 00:32:17,690
will let you figure what the cost is.
And you can use that to your advantage to

365
00:32:17,690 --> 00:32:22,559
-- to move away from that constraint so that
you're not render-bound, okay? So reduce the

366
00:32:22,559 --> 00:32:26,450
paint size, then reduce the complexity of
your paints.

367
00:32:26,450 --> 00:32:32,399
>>Peter Beverloo: So far, we've talked about
technical constraints which apply to you as

368
00:32:32,399 --> 00:32:37,799
the developer, but eventually what we really
want is to give the right user experience

369
00:32:37,799 --> 00:32:41,879
to the end user, to the person who is actually
using your page.

370
00:32:41,879 --> 00:32:47,840
Now, one thing to realize is that the user
comes for your content. They come to your

371
00:32:47,840 --> 00:32:52,340
Web site with a specific person -- purpose.
That could be to get information. That could

372
00:32:52,340 --> 00:32:59,340
be to use your service. And they don't really
care about that big image header which you

373
00:32:59,369 --> 00:33:03,440
had at all of the top of your pages, which
basically just means that they have to scroll

374
00:33:03,440 --> 00:33:09,869
the page before they even get to the content.
You, as the developer, have all these constraints,

375
00:33:09,869 --> 00:33:15,889
but the user shouldn't have them.
And the main thing here, the main takeaway,

376
00:33:15,889 --> 00:33:20,919
is that if I, as a user, use my mobile device,
if I use a phone to look at your Web site,

377
00:33:20,919 --> 00:33:25,389
I really don't care about how well it works
on a web -- on a desktop machine because I

378
00:33:25,389 --> 00:33:30,960
use a mobile device. And the other way around,
the same goes.

379
00:33:30,960 --> 00:33:36,100
And while you probably want to offer the same
-- a different user experience, because after

380
00:33:36,100 --> 00:33:41,460
all they are different classes of devices,
you should offer the same functionality.

381
00:33:41,460 --> 00:33:45,859
And what this basically means is that the
content on your page, or the services, it's

382
00:33:45,859 --> 00:33:50,590
fine to refactor them or to reshape them in
a way that's more optimized for the device,

383
00:33:50,590 --> 00:33:56,440
as long as you don't offer that reduced functionality
such as a simple entry page, "Sorry, you can't

384
00:33:56,440 --> 00:34:02,259
use this feature at this time because it's
not optimized for mobile. Please use a desktop."

385
00:34:02,259 --> 00:34:08,500
That just scares away users.
When you develop a Web site for a desktop

386
00:34:08,500 --> 00:34:12,480
computer, you've got all this real estate
available to you. You can put content next

387
00:34:12,480 --> 00:34:17,320
to each other, you can put it on top of each
other, in any form that you want, for -- especially

388
00:34:17,320 --> 00:34:20,450
for text.
You can have a news article, you can have

389
00:34:20,450 --> 00:34:24,560
a bold introduction, you can have related
information about the company or the people

390
00:34:24,560 --> 00:34:29,290
who are mentioned in the article itself.
And this is nice because on a desktop, because

391
00:34:29,290 --> 00:34:34,640
there's all this space, even a relatively
big amount of text looks like moderate and

392
00:34:34,640 --> 00:34:39,780
it doesn't fill up your screen.
Now, for mobile devices, this is a problem.

393
00:34:39,780 --> 00:34:44,660
Or actually for devices with constrained screen
size this is a problem. Because if I look

394
00:34:44,660 --> 00:34:50,080
at exactly the same text, or maybe even one
paragraph of text on my mobile phone, then

395
00:34:50,080 --> 00:34:54,640
my entire screen is filled with text, and
that's quite intimidating.

396
00:34:54,640 --> 00:34:59,740
If I then start to scroll down and I get five
or six more paragraphs, then I have to scroll

397
00:34:59,740 --> 00:35:05,800
for several seconds before the text stops.
Even at relatively high scroll speeds.

398
00:35:05,800 --> 00:35:09,930
And this is intimidating and this could easily
scare away users.

399
00:35:09,930 --> 00:35:15,450
Now, we know that you're not always in control
of your content, so changing the text itself

400
00:35:15,450 --> 00:35:19,450
or changing the images might not always be
a feasible solution, but you can at least

401
00:35:19,450 --> 00:35:24,940
pass on the message that the users care a
lot more about getting an optimized experience

402
00:35:24,940 --> 00:35:30,090
and care about getting the same functionality
than they get for getting all of the text

403
00:35:30,090 --> 00:35:32,950
and all of the site information.
>>Paul Lewis: And one thing to notice here,

404
00:35:32,950 --> 00:35:38,350
just if you can go back, is at the bottom
of that that we've got an image that's kind

405
00:35:38,350 --> 00:35:42,100
of suggesting something is not responsive.
Just bear in mind if you do do this kind of

406
00:35:42,100 --> 00:35:46,070
responsive thing, just watch out for that
tax that I told you about earlier about resizing

407
00:35:46,070 --> 00:35:51,100
images down. Make sure you always request
the images at the right size.

408
00:35:51,100 --> 00:35:58,100
Okay. So we have a couple of suggestions,
as you've just seen, because we think it will

409
00:35:58,870 --> 00:36:02,820
be good to give you a couple of -- couple
of suggestions for your work workflow.

410
00:36:02,820 --> 00:36:08,930
The first one is assign somebody that you
used to like to your team as the sheriff.

411
00:36:08,930 --> 00:36:15,430
They'll probably become unpopular pretty quickly.
However, they perform a very important role

412
00:36:15,430 --> 00:36:18,680
for you.
As you can see, the idea is to clarify and

413
00:36:18,680 --> 00:36:21,780
set some constraints before you start. How
much time are we going to spend in garbage

414
00:36:21,780 --> 00:36:27,270
collection, paint, composite, layout, recalc
style? Where are we going to spend our time,

415
00:36:27,270 --> 00:36:31,110
on the assumption that we've got a network-constrained
device or a render-constrained device. Where

416
00:36:31,110 --> 00:36:33,930
are we actually going to spend our time?
Then that person is going to track it and

417
00:36:33,930 --> 00:36:37,110
they're going to stop you from shipping if
you don't hit it.

418
00:36:37,110 --> 00:36:41,530
Now, the question then becomes, "Well, what
number should we have?" And the honest answer

419
00:36:41,530 --> 00:36:47,600
is: It depends on your application.
But have that person -- a lot of times when

420
00:36:47,600 --> 00:36:53,540
we speak to developers, performance and this
-- this kind of stuff is often a bit like

421
00:36:53,540 --> 00:36:59,550
a unit test. Are we fast? No. Oops.
[ Laughter ]

422
00:36:59,550 --> 00:37:03,900
>>Paul Lewis: What we're talking about is
building it in from the start so that it's

423
00:37:03,900 --> 00:37:07,960
something that you're continually checking
all the way through and there's somebody who's

424
00:37:07,960 --> 00:37:12,520
owning and is responsible for that for you
as a team.

425
00:37:12,520 --> 00:37:19,140
Check out jankfree.org. That's a bunch of
slides. It's a bunch of articles. It's a bunch

426
00:37:19,140 --> 00:37:23,400
of videos. All of which are designed to help
you with these -- the things that we've talked

427
00:37:23,400 --> 00:37:27,900
about and in a lot more detail than we've
been able to cover so that's a fantastic resource

428
00:37:27,900 --> 00:37:32,570
that you can track.
So should we conclude? We should because it

429
00:37:32,570 --> 00:37:34,570
says "Conclusion" on the screen.
>>Peter Beverloo: Yes.

430
00:37:34,570 --> 00:37:37,240
>>Paul Lewis: Super.
>>Peter Beverloo: It's not about the device

431
00:37:37,240 --> 00:37:41,350
which users are able to access your Web sites.
It's about the content and the experience

432
00:37:41,350 --> 00:37:44,920
which you're delivering to them. And while
the content and the functionality should be

433
00:37:44,920 --> 00:37:49,180
the same, you can optimize them to create
a user experience specific to the different

434
00:37:49,180 --> 00:37:51,540
devices.
>>Paul Lewis: The devices you're going to

435
00:37:51,540 --> 00:37:56,710
deal with, they're going to probably have
at least one constraint at some point.

436
00:37:56,710 --> 00:38:00,310
Even on a desktop you might have multiple
processes running. There's no guarantee that

437
00:38:00,310 --> 00:38:04,570
you're going to be good. So you figure out
ways to actually just reduce the load, fight

438
00:38:04,570 --> 00:38:10,510
against those constraints, and you will be
agnostic. Mostly, let the browser do what

439
00:38:10,510 --> 00:38:13,790
it's good at doing. If you're doing stuff
with JavaScript and you don't need to do it,

440
00:38:13,790 --> 00:38:18,730
don't do it. Let the browser do it for you.
>>Peter Beverloo: And just to reiterate on

441
00:38:18,730 --> 00:38:23,330
the content a little bit more, users come
to your page for content. I've said it a number

442
00:38:23,330 --> 00:38:30,020
of times and I just say it again.
Refactor your content in a more direct and

443
00:38:30,020 --> 00:38:35,050
concise way to get it to them in the fastest
way possible, because, after all, that's why

444
00:38:35,050 --> 00:38:42,050
they're there.
>>Paul Lewis: Thank you very much.

445
00:38:42,810 --> 00:38:47,400
[ Applause ]
>>Paul Lewis: We have a tiny amount of time

446
00:38:47,400 --> 00:38:51,290
for one or two questions, maybe, so if you
have a question, go up to the mic and we'll

447
00:38:51,290 --> 00:38:54,770
see if we can get through any of them. And
then if you want to find us after, we're going

448
00:38:54,770 --> 00:39:00,120
to be upstairs in the Chrome area, probably
in the -- I'll at the for performance booth,

449
00:39:00,120 --> 00:39:02,830
if you're interested.
>>> I'm curious. The last couple I/Os, we've

450
00:39:02,830 --> 00:39:06,430
seen a lot about getting rid of jank and using
the de-bouncing technique that you guys have

451
00:39:06,430 --> 00:39:12,190
talked to do so, which strikes me as a bug
in the spec because I don't know why anyone

452
00:39:12,190 --> 00:39:19,190
would ever care about getting 200 touch or
scroll events per frame and yet every single

453
00:39:19,910 --> 00:39:23,940
application that any developer here is going
to write means that we have to take all this

454
00:39:23,940 --> 00:39:29,050
data, persist it somewhere, use it in yet
another function and let it be garbage collected

455
00:39:29,050 --> 00:39:30,940
later.
Is that something that we should address at

456
00:39:30,940 --> 00:39:34,440
a lower level than the JavaScript that we
write?

457
00:39:34,440 --> 00:39:37,910
>>Paul Lewis: Well, I think if that's how
you feel, definitely involve yourself in the

458
00:39:37,910 --> 00:39:44,910
spec process for sure. It's something that
we're trying to watch and I'm interested in

459
00:39:45,280 --> 00:39:49,630
it because especially, as I said, I see a
lot of code going to scroll handlers and touch

460
00:39:49,630 --> 00:39:54,340
handlers that doesn't need to be there. So
there's a certain amount of "should this be

461
00:39:54,340 --> 00:39:59,360
spec, should this be developer required."
I haven't got a good use case for multiple

462
00:39:59,360 --> 00:40:04,690
scroll handler -- or multiple calls to the
scroll handler, for example, inside a single

463
00:40:04,690 --> 00:40:08,920
frame, but I wouldn't like to presume that
nobody does, but I'm not saying that they

464
00:40:08,920 --> 00:40:13,360
do either, so I guess it could be something
that should be spec'd, and I'd involve yourself

465
00:40:13,360 --> 00:40:15,160
in the spec process and see if we can hash
it out.

466
00:40:15,160 --> 00:40:19,280
>>Peter Beverloo: Well, a lot of specifications
already keep this in mind by offering asynchronous

467
00:40:19,280 --> 00:40:23,450
functionality rather than synchronous ones.
And even though this is often not the case

468
00:40:23,450 --> 00:40:28,760
for event handlers yet, for -- for getting
many kinds of data, it will allow it to do

469
00:40:28,760 --> 00:40:33,500
on the background thread, not block any other
processing and just come back when everything

470
00:40:33,500 --> 00:40:36,910
is available.
We've gone a little bit over time.

471
00:40:36,910 --> 00:40:40,420
>>Paul Lewis: Yeah. So I'm afraid if you've
got any questions, just come and find us upstairs.

472
00:40:40,420 --> 00:40:41,590
Thank you.

