1
00:00:00,659 --> 00:00:04,380
>>Ilya Grigorik: Hi, everyone. My name is
Ilya Grigork. I'm a developer advocate on

2
00:00:04,380 --> 00:00:09,450
the Make the Web Fast Team at Google. Today
I want to talk to you about mobile performance

3
00:00:09,450 --> 00:00:14,730
from radio up, which is to say taking a lower
level look at how the radio works and what

4
00:00:14,730 --> 00:00:19,939
we can learn about it to make our apps -- mobile
apps and Web pages with more performance.

5
00:00:19,939 --> 00:00:24,090
These are some tricks and tips I have learned
from working with different Google properties,

6
00:00:24,090 --> 00:00:27,740
helping them optimize their applications,
and some general best practices.

7
00:00:27,740 --> 00:00:32,119
So, first, I think we should start with the
obvious which is -- or maybe it is not so

8
00:00:32,119 --> 00:00:36,469
obvious to many of us -- which is wireless
is fundamentally different than wired. There

9
00:00:36,469 --> 00:00:41,190
are different constraints. The technology,
the underlying technology, is, in fact, very

10
00:00:41,190 --> 00:00:45,539
different.
And, fortunately, or unfortunately, I'm not

11
00:00:45,539 --> 00:00:50,890
quite sure yet, our platform actually abstracts
that, right?

12
00:00:50,890 --> 00:00:54,850
TCP and our browsers make it seem like it
is all the same, whether you are accessing

13
00:00:54,850 --> 00:00:58,969
over a wireless network, whether it is WiFi
or mobile network or wired network. It feels

14
00:00:58,969 --> 00:01:02,329
like all the same.
But once you actually dig a little bit deeper,

15
00:01:02,329 --> 00:01:05,910
you will realize that there are different
design constraints within -- even within the

16
00:01:05,910 --> 00:01:11,470
different wireless standards. And that actually
dictates how you need to design your applications

17
00:01:11,470 --> 00:01:17,700
to make them feel performant.
So, first of all, why do we care? It turns

18
00:01:17,700 --> 00:01:23,940
out that performance is a top criteria for
all applications, mobile especially. And there's

19
00:01:23,940 --> 00:01:27,760
a number of great studies that have been done
about performance on mobile.

20
00:01:27,760 --> 00:01:33,600
And the first take-away is that users expect
mobile sites to perform just as well, if not

21
00:01:33,600 --> 00:01:38,130
better, on mobile than they do on desktop.
We don't kind of have more relaxed expectations

22
00:01:38,130 --> 00:01:42,190
on mobile. If anything, it should be faster.
You're on the go. You are trying to check

23
00:01:42,190 --> 00:01:46,090
something quickly. You don't have much time.
You want it to perform well.

24
00:01:46,090 --> 00:01:51,360
Now, out of all of these users that have asked
these questions, more than half actually reported

25
00:01:51,360 --> 00:01:56,600
feeling frustrated about having a problem
when accessing a site or an app over a mobile

26
00:01:56,600 --> 00:02:02,890
network. And most of those, the number one
complaint has been the slow load time for

27
00:02:02,890 --> 00:02:08,020
their applications.
So -- and after that, almost half of them

28
00:02:08,020 --> 00:02:12,610
said, If I had a problem, I couldn't get the
page to load fast enough. It didn't react

29
00:02:12,610 --> 00:02:17,310
fast enough. They wouldn't come back. So you
have lost that user and they're not returning

30
00:02:17,310 --> 00:02:20,030
to your site, which is the worst possible
outcome.

31
00:02:20,030 --> 00:02:24,880
And, of course, this also translates to dollars
and cents and even millions of dollars. So

32
00:02:24,880 --> 00:02:29,690
this is another great case study that I would
like to share. This was done by Aberdeen Group.

33
00:02:29,690 --> 00:02:36,200
They looked at a whole number, 100-plus e-commerce
sites and they realized that adding one second

34
00:02:36,200 --> 00:02:41,810
of delay to their pages and to their applications
dropped their conversions significantly. So

35
00:02:41,810 --> 00:02:48,170
this is your actual purchases. People viewed
fewer pages. And, of course, customer satisfaction

36
00:02:48,170 --> 00:02:53,320
decreased as well. So this is just a thousand
milliseconds of latency added to your application.

37
00:02:53,320 --> 00:02:58,350
So it is not just dollars and cents. For many
sites, large sites, it's literally millions

38
00:02:58,350 --> 00:03:02,000
of dollars.
So our agenda today is to actually look at

39
00:03:02,000 --> 00:03:08,000
radio performance 101. It is kind of a propeller-hat
talk a little bit. And, specifically, we'll

40
00:03:08,000 --> 00:03:11,740
compare WiFi and mobile. And you will see
why, because it is important to understand

41
00:03:11,740 --> 00:03:16,580
that even something like WiFi and mobile networks
are fundamentally different in how we schedule

42
00:03:16,580 --> 00:03:22,210
how the communication is done and how we design
our applications or what we can even do to

43
00:03:22,210 --> 00:03:26,080
optimize our applications.
And we'll also look at some practical tips

44
00:03:26,080 --> 00:03:30,140
for what you can do in your applications to
design for this. And then I'll leave the last

45
00:03:30,140 --> 00:03:34,420
part for you, which is to optimize the profit
part.

46
00:03:34,420 --> 00:03:39,600
So there are tons and tons of techniques for
how to make your applications more performant.

47
00:03:39,600 --> 00:03:44,370
There is application optimizations. There
is PageSpeed-specific optimizations or Speed

48
00:03:44,370 --> 00:03:48,330
1-specific optimizations. We are not going
to touch on those. We are going to mention

49
00:03:48,330 --> 00:03:51,200
them at the very end. We will are actually
going to go a little bit deeper.

50
00:03:51,200 --> 00:03:56,200
We are going to go below the application layer,
even below the TCP layer, and kind of look

51
00:03:56,200 --> 00:04:01,020
at how does the radio actually work, right?
So we will put the wired stuff aside, look

52
00:04:01,020 --> 00:04:07,750
at the radio and dive into WiFi and mobile.
So 3G and 4G, what's so special about that?

53
00:04:07,750 --> 00:04:12,080
How does battery life play into this? It turns
out that battery life is kind of the central

54
00:04:12,080 --> 00:04:17,440
component. There is the radio, and then there
is a battery. Those are two connected components

55
00:04:17,440 --> 00:04:22,350
that we need to think about. And what is the
radio resource controller? Our friend and

56
00:04:22,350 --> 00:04:26,440
foe.
So let's dive right in. First of all, wireless

57
00:04:26,440 --> 00:04:32,470
or WiFi came around in the early '90s. That's
when the first standards were published. Really,

58
00:04:32,470 --> 00:04:39,000
it only became popular in the late '90s with
the release of the 802.11b, which is the 11-megabits-per-second

59
00:04:39,000 --> 00:04:41,510
standard.
And the thing to realize about WiFi is it

60
00:04:41,510 --> 00:04:47,070
was literally designed as an extension to
your local area network, your LAN. So we re-use

61
00:04:47,070 --> 00:04:51,320
all of the same framing, protocols, mechanisms,
and all the rest of them, basically added

62
00:04:51,320 --> 00:04:58,090
a wireless interface to it. So it is not designed
for a mobile device, which is to say a device

63
00:04:58,090 --> 00:05:02,530
with limited battery. It was designed for
your desktop computer, your laptop computer,

64
00:05:02,530 --> 00:05:05,540
right?
We weren't constrained by power at the time.

65
00:05:05,540 --> 00:05:11,080
Think back to the phone that you had in 1999.
Right? We weren't thinking about the kinds

66
00:05:11,080 --> 00:05:14,300
of applications that we were delivering at
the time.

67
00:05:14,300 --> 00:05:19,419
And the thing about WiFi is we need to understand
how we actually schedule how we communicate

68
00:05:19,419 --> 00:05:24,490
over WiFi, right? So when we are communicating
over a wired connection, we have a switch

69
00:05:24,490 --> 00:05:30,080
or a router which routes all of the packets
between the destination -- or the client and

70
00:05:30,080 --> 00:05:34,449
server, for example.
In WiFi, we share the radio channel. And the

71
00:05:34,449 --> 00:05:38,850
radio channel is a shared medium between all
of us, right? All of us can't talk at the

72
00:05:38,850 --> 00:05:42,230
same time. That would just generate a lot
of noise. So we need some sort of mechanism

73
00:05:42,230 --> 00:05:46,090
to figure out who is going to talk when. And
WiFi takes a very hands-off approach about

74
00:05:46,090 --> 00:05:51,980
this. It basically says let's use a very simple
algorithm, which is if you want to talk first,

75
00:05:51,980 --> 00:05:56,610
listen if nobody else is talking. If nobody
else is talking, then start talking, right?

76
00:05:56,610 --> 00:06:00,860
And if another person starts talking while
you're talking, well, then both of you stop,

77
00:06:00,860 --> 00:06:04,550
wait for random interval of time and repeat
the whole process, right? So it is kind of

78
00:06:04,550 --> 00:06:10,639
like this party algorithm of, We'll just trust
that all of you behave nicely and you will

79
00:06:10,639 --> 00:06:16,919
all respect each other and we will just kind
of share this medium. That's WiFi.

80
00:06:16,919 --> 00:06:22,570
Now, you can actually model this and prove
that the channel load or the amount of traffic

81
00:06:22,570 --> 00:06:27,169
needs to be kept fairly low. In fact, the
load of the network needs to be below 10%

82
00:06:27,169 --> 00:06:31,050
in order to achieve good performance. Like,
you're always going to have retransmissions.

83
00:06:31,050 --> 00:06:33,800
There will always be the case when I start
talking and you start talking a little bit

84
00:06:33,800 --> 00:06:38,229
later and we collide. That's okay because
we will wait and then we will retransmit data

85
00:06:38,229 --> 00:06:41,169
and everything is okay. You can get pretty
good performance.

86
00:06:41,169 --> 00:06:45,300
But after a while, you basically run into
the case where there are too many devices

87
00:06:45,300 --> 00:06:50,040
trying to compete for the same medium and
the network basically collapses. There is

88
00:06:50,040 --> 00:06:54,620
no way to recover from this state.
And I'm pretty sure all of us have experienced

89
00:06:54,620 --> 00:07:01,620
this at some point, right? WiFi in a large
group of people and a room, not a good combination

90
00:07:02,100 --> 00:07:08,880
oftentimes. So that's in part why.
And we can dig a little bit deeper and actually

91
00:07:08,880 --> 00:07:14,729
look at how it's implemented. So in the 2.4-gigahertz
spectrum, we actually have a limited amount

92
00:07:14,729 --> 00:07:19,120
of spectrum. Like, let's say 60 megahertz.
Within that 60 megahertz, we can actually

93
00:07:19,120 --> 00:07:24,770
have three channels, which is to say up to
three devices can talk in parallel and they

94
00:07:24,770 --> 00:07:28,160
won't interfere with each other, right? So
these are the channels. If you guys have ever

95
00:07:28,160 --> 00:07:32,820
dug into your settings on your WiFi router,
that would be your, like, channel 1, channel

96
00:07:32,820 --> 00:07:39,710
6 or channel 11 or something to that extent.
Now, the problem is -- this is nice and pretty.

97
00:07:39,710 --> 00:07:43,949
This is a little chart that I pulled up on
my own home network. And you can see that

98
00:07:43,949 --> 00:07:47,949
there is over a dozen networks, right? And
they're all overlapping. We are all trying

99
00:07:47,949 --> 00:07:53,889
to talk over each other. And, basically, WiFi,
to some degree, is a victim of its own success.

100
00:07:53,889 --> 00:07:59,380
It has become so ubiquitous, there are so
many WiFi routers out there, that it's just

101
00:07:59,380 --> 00:08:04,240
-- it is very hard to get a slot to talk to
somebody without interfering with anybody,

102
00:08:04,240 --> 00:08:07,039
right?
So your neighbor, when they start streaming

103
00:08:07,039 --> 00:08:12,539
that HD Netflix movie, they are interfering
with you as well even though it is a different

104
00:08:12,539 --> 00:08:16,360
access point. They are still using the same
shared spectrum.

105
00:08:16,360 --> 00:08:23,360
So there is limited capacity. And most networks
have tens or even more than dozens of overlapping

106
00:08:24,740 --> 00:08:27,729
networks.
So here's a fun experiment. I ran this at

107
00:08:27,729 --> 00:08:32,509
my house. This is not definitive data, but
this is an example of a data point. There's

108
00:08:32,509 --> 00:08:38,669
about 15 access points just in and around
my apartment. And I ran a very simple test.

109
00:08:38,669 --> 00:08:43,069
I took my laptop and I had my router which
was about 15 feet away and I was staring right

110
00:08:43,069 --> 00:08:48,220
at it. And I figured, hey, how long does it
take for one packet to get from my laptop

111
00:08:48,220 --> 00:08:52,639
to the router? What is the latency of that
first hop?

112
00:08:52,639 --> 00:08:57,040
And I gathered data for several hours. So
this is, you know, a good sample of data.

113
00:08:57,040 --> 00:09:03,389
And if you look at the numbers here, the 95th
percentile is about 50 milliseconds. So to

114
00:09:03,389 --> 00:09:08,199
travel 15 feet from my laptop to my router,
it was taking about 50 milliseconds, which

115
00:09:08,199 --> 00:09:12,889
is crazy because 50 milliseconds is about
the amount of time that it takes to travel

116
00:09:12,889 --> 00:09:18,670
from the West Coast to the East Coast, right?
So here I am trying to, like, shuttle a packet

117
00:09:18,670 --> 00:09:24,529
15 feet away to my router. This is a function
of there is just a lot of other activity in

118
00:09:24,529 --> 00:09:27,610
the vicinity. So we were competing for the
same spectrum.

119
00:09:27,610 --> 00:09:31,670
So then I tried something different. I actually
went out and bought a different router, which

120
00:09:31,670 --> 00:09:37,300
is using the new -- the new 802.11n standard
and it's running on the 5-gigahertz band.

121
00:09:37,300 --> 00:09:43,329
And the 5-gigahertz band gives us more bandwidth.
And by the function that it is also new, not

122
00:09:43,329 --> 00:09:48,550
many people are using it, right? So I was
like the lone person on that channel.

123
00:09:48,550 --> 00:09:55,480
And I ran the same test and there you go.
My 95th percentile latency is down to 2 milliseconds.

124
00:09:55,480 --> 00:09:59,509
So as far as I'm concerned that was a fantastic
investment. So if nothing else, you can go

125
00:09:59,509 --> 00:10:04,470
back home, upgrade your router to 5 gigahertz,
and hope that not many of you are living in

126
00:10:04,470 --> 00:10:06,550
the same neighborhood, and you are not competing
with each other.

127
00:10:06,550 --> 00:10:08,459
[ Laughter ]
>>Ilya Grigorik: And then you will get much

128
00:10:08,459 --> 00:10:12,639
better performance -- Web performance. We
just cut 50 milliseconds of latency. That

129
00:10:12,639 --> 00:10:19,079
is huge for performance.
So some take-aways from this. First of all,

130
00:10:19,079 --> 00:10:24,350
WiFi makes no guarantees about the bandwidth
or the data rate that you are going to get.

131
00:10:24,350 --> 00:10:29,899
Anybody else can start transmitting at any
point in time, so it is unpredictable.

132
00:10:29,899 --> 00:10:36,399
One way to adapt to this is to -- well, one
way to deal with this is to adapt to the variable

133
00:10:36,399 --> 00:10:41,019
bandwidth. Not to predict it, you can't predict
it. You can only adapt to it.

134
00:10:41,019 --> 00:10:45,970
We leverage this to, for example, serve video.
Like, when we serve video on YouTube, we serve

135
00:10:45,970 --> 00:10:51,790
it in small chunks, like, 5 to 10-second chunks,
where we stream a chunk of video. We see if

136
00:10:51,790 --> 00:10:56,259
you can download it fast enough. If you can
download it fast enough, we can upgrade you

137
00:10:56,259 --> 00:11:01,709
to a higher-quality stream. Vice versa, if
your bandwidth was all of a sudden cut in

138
00:11:01,709 --> 00:11:06,119
half because somebody else is streaming a
video, we will downgrade you seamlessly to

139
00:11:06,119 --> 00:11:11,559
a lower resolution video. So that's adaptive
streaming. And that's something that you can

140
00:11:11,559 --> 00:11:15,670
do as well if you're streaming music, streaming
video, or other things.

141
00:11:15,670 --> 00:11:20,360
The other variable that you can't really control
with WiFi is, of course, latency and jitter,

142
00:11:20,360 --> 00:11:25,809
right? So because we have these collisions
all the time. Your packets need to be retransmitted,

143
00:11:25,809 --> 00:11:29,189
and there is not much you can do. WiFi provides
no guarantees about this. If you have ever

144
00:11:29,189 --> 00:11:36,189
tried to implement a real-time chat or real-time
voice and video over WiFi, you have certainly

145
00:11:36,749 --> 00:11:40,800
run into this problem.
So perhaps the only thing you can really do

146
00:11:40,800 --> 00:11:46,179
is start looking into something like WebRTC
which allows you to leverage unreliable delivery

147
00:11:46,179 --> 00:11:50,470
and basically UDP in the browser.
And we had a great session on WebRTC earlier

148
00:11:50,470 --> 00:11:55,379
today. So if you guys have missed it, check
out the video for that.

149
00:11:55,379 --> 00:12:02,379
So that's WiFi, right? So that's just a baseline.
Now let's take a look at 2G, 3G and 4G networks.

150
00:12:02,429 --> 00:12:09,059
How do they work and how are they different?
So, first of all, when the mobile carriers

151
00:12:09,059 --> 00:12:15,939
or the mobile standards started, you know,
they set aside some specific constraints that

152
00:12:15,939 --> 00:12:22,049
they needed to optimize for. First, they needed
to guarantee some level of performance.

153
00:12:22,049 --> 00:12:26,509
So they wanted to make sure that they don't
have this congestion collapse scenario which

154
00:12:26,509 --> 00:12:30,529
is present in WiFi, right? And they wanted
to have some knobs to tweak to say, like,

155
00:12:30,529 --> 00:12:34,360
if this is really overloading a network, we
will lower the data rates for everybody. But

156
00:12:34,360 --> 00:12:38,829
you can still sort of get a lower data rate.
We want to be able to control that, and we

157
00:12:38,829 --> 00:12:43,879
need some knobs for that. That's number one.
Second is, of course, we're covering a much

158
00:12:43,879 --> 00:12:48,989
larger geographical area which means that,
once again, we need to handle more clients.

159
00:12:48,989 --> 00:12:54,420
And that's something we need to account for.
And the second one is our battery life. So

160
00:12:54,420 --> 00:12:59,129
it turns out when you're optimizing for mobile
devices, you really need to think about battery

161
00:12:59,129 --> 00:13:05,600
life. I think for many of us, you know, if
we use our phone actively, or our mobile device

162
00:13:05,600 --> 00:13:12,040
actively, you will find that your battery
is draining very, very quickly. So, radio

163
00:13:12,040 --> 00:13:16,869
is a very important component of that.
You add these two things together and you

164
00:13:16,869 --> 00:13:23,749
get the radio resource controller. And what
is the radio resource controller? So, mobile

165
00:13:23,749 --> 00:13:29,239
networks, the 2G, 3G and 4G standards take
a different approach as to how they schedule

166
00:13:29,239 --> 00:13:34,839
when you can communicate. Instead of doing
this freebie approach of you just start talking

167
00:13:34,839 --> 00:13:38,910
when you think nobody else is talking, they're
actually employing a moderator, which is to

168
00:13:38,910 --> 00:13:42,249
say the radio tower actually tells you when
you can speak.

169
00:13:42,249 --> 00:13:46,339
You tell the radio tower that, Hey, I would
like to send some data and then the radio

170
00:13:46,339 --> 00:13:51,449
tower consults its schedule and tells you,
okay, I've got these five people that are

171
00:13:51,449 --> 00:13:56,259
queued up. You're this far away, so you start
transmitting at this point in time with this

172
00:13:56,259 --> 00:14:00,639
signal power with these parameters, with this
encoding and then you have this amount of

173
00:14:00,639 --> 00:14:05,369
time, right?
So it is a very different scheduling mechanism.

174
00:14:05,369 --> 00:14:09,939
And as you can imagine, this adds a lot more
overhead, but it allows us to schedule resources

175
00:14:09,939 --> 00:14:14,839
more efficiently within the network. And this
obviously has its pros and cons.

176
00:14:14,839 --> 00:14:21,839
So the radio resource controller lives within
a different component of the network infrastructure

177
00:14:23,209 --> 00:14:27,519
in 2G and 3G networks. It was actually living
in the core network. In the latest networks,

178
00:14:27,519 --> 00:14:31,629
it is living right at the radio tower, which
is one of the ways of how we are improving

179
00:14:31,629 --> 00:14:37,069
performance in 4G networks. By moving it closer
to you, we are reducing the latency.

180
00:14:37,069 --> 00:14:43,670
But the radio resource controller has a number
of implications. So first of these is the

181
00:14:43,670 --> 00:14:50,670
difference -- and the distinction between
the control and the user-plane latency. So

182
00:14:51,299 --> 00:14:55,230
whenever you talk to anybody that's working
in the mobile space, they'll often throw this

183
00:14:55,230 --> 00:14:59,410
out and mention the control and user-plane
latency. What is it?

184
00:14:59,410 --> 00:15:03,850
Recall that we need to talk to the radio tower
to figure out when we're allowed to transmit

185
00:15:03,850 --> 00:15:08,389
data. This is what happens first. You send
a message to the radio tower and say, I would

186
00:15:08,389 --> 00:15:13,689
like to send data. The radio tower determines
when you can talk. And then it sends you a

187
00:15:13,689 --> 00:15:20,689
message back. That is the control plane latency.
In 3G networks, this can take up to 2 1/2

188
00:15:20,809 --> 00:15:26,709
seconds. 2 1/2 seconds just -- we haven't
even sent a packet of data, application data,

189
00:15:26,709 --> 00:15:31,249
from your phone. We're basically trying to
get a resource assignment from the radio tower.

190
00:15:31,249 --> 00:15:36,529
In 4G networks and the latest generation networks,
this time is significantly improved. It's

191
00:15:36,529 --> 00:15:41,639
under 100 milliseconds. But, nonetheless,
every millisecond counts and 100 milliseconds

192
00:15:41,639 --> 00:15:46,419
is a significant amount of time.
And then only after we've incurred this cost

193
00:15:46,419 --> 00:15:51,600
and we have gotten a resource assignment,
can we then trance -- start transmitting data

194
00:15:51,600 --> 00:15:56,809
from our phone to the radio tower?
And that is known as the user-plane latency.

195
00:15:56,809 --> 00:16:02,579
And, for example, in 4G networks that can
be about 10 milliseconds, right? We're definitely

196
00:16:02,579 --> 00:16:07,339
in the weeds here looking at how the mobile
radio works, but some important take-aways

197
00:16:07,339 --> 00:16:11,389
there.
Let's take this from the ground up. Your phone

198
00:16:11,389 --> 00:16:16,579
is idle. It has been asleep. You take it out
of your pocket. You start typing in an URL.

199
00:16:16,579 --> 00:16:21,379
You hit "go." What happens?
We -- so this is a 4G network. First, we need

200
00:16:21,379 --> 00:16:26,149
to talk to the tower. So we're going to incur
at least 100 milliseconds of latency. Then

201
00:16:26,149 --> 00:16:30,649
our phone is active and starts transmitting
data or the radio was active and it starts

202
00:16:30,649 --> 00:16:36,019
transmitting data.
After some time, it will actually downgrade

203
00:16:36,019 --> 00:16:41,989
your radio into a short sleep cycle which
is to say it is not going to listen for transmissions

204
00:16:41,989 --> 00:16:47,359
all the time. It will sleep for some time
and then it will wake up periodically to save

205
00:16:47,359 --> 00:16:51,720
power. It turns out that the radio is the
second most expensive component in terms of

206
00:16:51,720 --> 00:16:55,790
power or energy use in your phone after the
screen.

207
00:16:55,790 --> 00:17:01,009
So this is why we want to turn off the radio
as quickly as possible. And in the case of

208
00:17:01,009 --> 00:17:05,620
4G networks, this is usually done after 100
milliseconds of inactivity on your radio.

209
00:17:05,620 --> 00:17:09,900
So we've transmitted some data. We wait for
a 100-millisecond pause and then we downgrade

210
00:17:09,900 --> 00:17:14,600
your radio into this half sleep state.
And at that point, if you want to transmit

211
00:17:14,600 --> 00:17:19,709
data again, we need to go through that whole
control plane cycle once more. So you're,

212
00:17:19,709 --> 00:17:26,270
once again, incurring this same cost.
But then if your phone continues to be idle,

213
00:17:26,270 --> 00:17:31,420
we wait for another 100 milliseconds. We go
into the second, the long sleep mode, and

214
00:17:31,420 --> 00:17:35,890
only after then -- after about 10 seconds,
we will go back into the idle mode.

215
00:17:35,890 --> 00:17:41,460
Right? So a kind of pretty complicated flowchart.
But effectively what this says is, first,

216
00:17:41,460 --> 00:17:46,050
we have to incur the cost to upgrade the radio
and then it takes roughly 10 seconds to get

217
00:17:46,050 --> 00:17:51,980
back to idle mode. And this is very important,
as you will see in a second.

218
00:17:51,980 --> 00:17:55,610
So let's put this together, right? This is
pretty low level. How does this affect an

219
00:17:55,610 --> 00:18:01,400
actual data transfer, something like an hspeed
edit data transfer. Let's start from the beginning.

220
00:18:01,400 --> 00:18:04,850
We want to send the request which means we
need to do a DNS lookup. We may need to do

221
00:18:04,850 --> 00:18:09,320
a DNS lookup. We need to do a TCP handshake
followed by the dispatching the actual hspear

222
00:18:09,320 --> 00:18:14,270
request and then we actually need to fetch
the content and maybe optionally we need to

223
00:18:14,270 --> 00:18:21,270
do the TLS handshake for another -- up to
two round trips there.

224
00:18:22,520 --> 00:18:28,110
So let's add up all of these numbers. First
of all, we have the control plane latency,

225
00:18:28,110 --> 00:18:31,370
which is the time to wake up the radio and
get into the active state.

226
00:18:31,370 --> 00:18:37,350
So I'm using HSPA here, which is a 3G network.
And I'm using an average round trip time of

227
00:18:37,350 --> 00:18:42,850
about 200 milliseconds, which is roughly the
time that we see at Google for 3G networks.

228
00:18:42,850 --> 00:18:47,550
And then for 4G networks, these new-generation
networks, let's use 80 milliseconds, which

229
00:18:47,550 --> 00:18:54,550
is actually fairly aggressive.
So 200 to 2.5 seconds -- so 200 milliseconds

230
00:18:56,150 --> 00:19:01,510
to 2 1/2 seconds just to get out of the control
plane for the 3G network and then we have

231
00:19:01,510 --> 00:19:06,050
these round trips to fetch the DNS, to establish
TCP and all the rest. And very quickly you

232
00:19:06,050 --> 00:19:11,950
add up all the numbers, and this is without
your server response time, we already have

233
00:19:11,950 --> 00:19:17,850
over half a second of just network latency.
And this is very important if you're trying

234
00:19:17,850 --> 00:19:22,850
to design a responsive application that feels
responsive to the user. So the good news is,

235
00:19:22,850 --> 00:19:27,400
things are definitely getting better with
4G. We are down into hundreds of milliseconds

236
00:19:27,400 --> 00:19:32,610
and half a second territory. But we also can't
rely on 4G as you will see in a second. So

237
00:19:32,610 --> 00:19:38,330
really you should assume that there's literally
seconds of latency -- of network latency overhead

238
00:19:38,330 --> 00:19:45,330
when you design your applications.
So the first take-away here is we know that

239
00:19:45,670 --> 00:19:51,820
there are some constants that good applications
need to follow. A number of different user

240
00:19:51,820 --> 00:19:56,470
experience research studies have shown that
in order for an app to feel instant, it needs

241
00:19:56,470 --> 00:20:02,050
to respond to the user, knowledge user input
within hundreds of milliseconds. We just saw

242
00:20:02,050 --> 00:20:06,750
in that, even on the latest 4G network, you
are incurring 300 to 500 milliseconds. Which

243
00:20:06,750 --> 00:20:11,930
means that you basically -- you cannot wait
for the http request or any request to complete.

244
00:20:11,930 --> 00:20:18,930
You need to acknowledge the user input independently
of dispatching the request. That's the only

245
00:20:20,670 --> 00:20:27,670
way you will have an application that feels
instant to the user. All communication should

246
00:20:29,170 --> 00:20:35,440
be asynchronous.
Similarly, you should anticipate the RRC latency.

247
00:20:35,440 --> 00:20:40,410
It is a very common complaint about mobile
networks. Oh, my God, they are so unpredictable.

248
00:20:40,410 --> 00:20:45,290
The variability is so high. Turns out, once
you are aware of the control playing latency

249
00:20:45,290 --> 00:20:49,490
or listening negotiation at the beginning
which is the time to wake up your radio, you

250
00:20:49,490 --> 00:20:55,370
can model the stuff very well. You can build
and you can bake these things into the design

251
00:20:55,370 --> 00:20:59,260
process of your application. Once you talk
to your designers and let them know, hey,

252
00:20:59,260 --> 00:21:03,910
it may actually take two seconds before we
can do anything like even send an application

253
00:21:03,910 --> 00:21:09,080
packet, they can design their application
in a way that provides some sort of feedback

254
00:21:09,080 --> 00:21:15,940
to the user that, hey, we are working on processing
your input but it may take a while.

255
00:21:15,940 --> 00:21:22,940
All right. So moving on. We talked about energy.
So this is another gotcha that I think is

256
00:21:24,260 --> 00:21:30,250
top of mind for a lot of applications that
are native applications but is not top of

257
00:21:30,250 --> 00:21:37,050
mind for web applications but it certainly
will be soon. So notice that in our earlier

258
00:21:37,050 --> 00:21:42,190
diagram we said it takes about ten seconds
to cycle from a high-power state to a low-power

259
00:21:42,190 --> 00:21:47,170
state. This actually causes what is known
as an energy tail where it doesn't matter

260
00:21:47,170 --> 00:21:52,490
how much data you have transferred, the radio
will be active for a certain period of time.

261
00:21:52,490 --> 00:21:57,340
Like it could have transferred one bit or
one byte of data. It doesn't matter, right?

262
00:21:57,340 --> 00:22:00,970
Or you could have transferred 10 kilobytes
or 100 kilobytes for data. The radio is going

263
00:22:00,970 --> 00:22:07,970
to be on effectively for ten seconds after
that. So you are not going to save much by

264
00:22:08,010 --> 00:22:12,350
kind of sending data bit by bit. What you
want do is you want to send as much data as

265
00:22:12,350 --> 00:22:19,200
possible as early as possible. And, in fact,
intermittent data transfers is a huge, huge

266
00:22:19,200 --> 00:22:24,730
anti-pattern, performance anti-pattern on
mobile. So I have an example of this. And

267
00:22:24,730 --> 00:22:29,550
average mobile device today has about five
watt hours of battery capacity. Don't worry

268
00:22:29,550 --> 00:22:34,410
about the units too much. This is just to
illustrate the point. Five watt hours is about

269
00:22:34,410 --> 00:22:40,450
18,000 joules. It turns out that an average
phone today, a4G connection, in order to cycle

270
00:22:40,450 --> 00:22:47,280
to a low state to high state back to low state
will take about ten joules of energy. All

271
00:22:47,280 --> 00:22:52,750
right. Let's do our math. Let's say we have
a one-minute pulling interval. So I built

272
00:22:52,750 --> 00:22:57,750
an application like a gmail application which
every minute will wake up and just ping the

273
00:22:57,750 --> 00:23:03,770
server, say, do I have any mail? Are there
any messages for me? You multiply that out.

274
00:23:03,770 --> 00:23:09,940
It turns out that this application will consume
3% of battery life per hour. Right? Now you

275
00:23:09,940 --> 00:23:14,700
have a couple of these applications running
on your phone. They have nonoverlapping intervals.

276
00:23:14,700 --> 00:23:18,340
You have your phone in your pocket for half
a day. You take it out. Your battery is at

277
00:23:18,340 --> 00:23:23,180
20%. You wonder what the heck happened there?
That's what happened there. We're doing these

278
00:23:23,180 --> 00:23:27,430
intermittent pings and that's what's draining
the battery. So intermittent data transfers

279
00:23:27,430 --> 00:23:33,070
are extremely expensive. There's a really
cool case study that was done as a joint case

280
00:23:33,070 --> 00:23:40,070
study between AT&T and Pandora. They analyzed
the native Pandora application, which is,

281
00:23:40,290 --> 00:23:43,780
of course, a music streaming application.
And they discovered something interesting.

282
00:23:43,780 --> 00:23:47,460
Pandora was doing all the right things when
they were streaming the music. You start playing

283
00:23:47,460 --> 00:23:52,680
the song. They would stream the entire song
down to the client. Play the whole thing,

284
00:23:52,680 --> 00:23:59,680
and turn off the radio which is exactly what
you want to do. But then about every 58 seconds

285
00:23:59,710 --> 00:24:05,200
or 60 seconds, Pandora would fire an analytics
beacon which was reporting, like, how far

286
00:24:05,200 --> 00:24:11,270
along did you listen in a song and did you
like the song and all the rest. It seems reasonable.

287
00:24:11,270 --> 00:24:16,720
They analyze it and realized that those data
transfers were accounting to .2% of the total

288
00:24:16,720 --> 00:24:23,590
bytes transferred but it was 46% of the battery
life of that application. So -- which is a

289
00:24:23,590 --> 00:24:30,590
huge, of course, huge performance problem.
So all they had to do was to move -- these

290
00:24:31,300 --> 00:24:35,250
are not critical beacons. Right? They could
simply defer that until later until the next

291
00:24:35,250 --> 00:24:39,490
song data transfer. They could accumulate
this data. They did exactly that and they

292
00:24:39,490 --> 00:24:45,060
significantly improved the performance of
their application. So here are a couple of

293
00:24:45,060 --> 00:24:49,900
examples. It's a little bit small but I was
looking at, for example, CNN.com here. And

294
00:24:49,900 --> 00:24:54,490
I notice that they have a realtime Analytics
beacon installed in their site. So whenever

295
00:24:54,490 --> 00:25:00,090
you're reading a CNN article on your mobile
phone, about every five seconds chart beat

296
00:25:00,090 --> 00:25:05,720
sends a beacon saying, yep, I'm still here.
Yep, I'm still here. Yep, I'm still alive.

297
00:25:05,720 --> 00:25:10,840
And guess what? As you're reading CNN, you're
draining your battery, which is not a great

298
00:25:10,840 --> 00:25:16,990
experience. So in Google Analytics, we actually
caught this problem early and fixed it and

299
00:25:16,990 --> 00:25:22,190
we don't do this. We will actually -- we have
a different way to provide realtime Analytics

300
00:25:22,190 --> 00:25:27,410
but we have a way to do that without requiring
these beacons. So the short take-away is if

301
00:25:27,410 --> 00:25:31,850
you are sending these kinds of beacons in
your application, web or native, definitely

302
00:25:31,850 --> 00:25:38,500
something to reconsider because it's extremely
expensive. Now, unfortunately today I don't

303
00:25:38,500 --> 00:25:45,060
think many platforms provide very good instrumentation
or visibility into how much energy does my

304
00:25:45,060 --> 00:25:51,160
application consume? Whether that's web or
native, but one tool that is actually very

305
00:25:51,160 --> 00:25:57,680
good is the AT&T's error tool. It is a free
and open source tool. I will show you a quick

306
00:25:57,680 --> 00:26:04,680
demo of this. What it allows you to do, it
allows you to capture a trace file. It can

307
00:26:05,670 --> 00:26:10,900
actually record -- you can install an application
on your Android device. You hit record. You

308
00:26:10,900 --> 00:26:14,910
interact with your application. Then you export
a trace and you can analyze it with this analyzer

309
00:26:14,910 --> 00:26:20,680
tool. I have already prerecorded a trace.
I will show it to you guys here. So let me

310
00:26:20,680 --> 00:26:27,680
load this app here. And you can also run it
in emulator, but I prefer do it on my phone.

311
00:26:29,680 --> 00:26:34,159
I loaded a web site. I have this trace. One
of the cool things it provides is it will

312
00:26:34,159 --> 00:26:38,810
-- it can also record your screen. Here I'm
starting collector and I will fast forward

313
00:26:38,810 --> 00:26:44,510
a little bit. So I'm loading the site Red
Robin here. It can look at the diagnostics

314
00:26:44,510 --> 00:26:51,510
here. This is us downloading the images, downloading
the page. You can see the through put, different

315
00:26:52,680 --> 00:26:57,810
RCC states or the states of the radio and
the energy consumption of your app. So let

316
00:26:57,810 --> 00:27:04,810
me pause this. And one of the cool things
about this tool it will actually also analyze

317
00:27:04,860 --> 00:27:10,440
the content that you are downloading and point
out common performance anti-patterns. Things

318
00:27:10,440 --> 00:27:16,490
like, hey, you're not caching the data. Or
you have intermittent data transfers. But

319
00:27:16,490 --> 00:27:22,800
then on top of all of that, it will also tell
you the energy consumed during this session

320
00:27:22,800 --> 00:27:26,980
that you have recorded, right? So you can
actually model this. Now, one thing to call

321
00:27:26,980 --> 00:27:31,850
out is this is not an exact measurement. This
is based on a model. So it has some assumptions

322
00:27:31,850 --> 00:27:35,320
about the phone that you are using and the
network type you are on. You can actually

323
00:27:35,320 --> 00:27:41,630
switch those and you say, I want to run this
model on the 3G network versus a 4G network.

324
00:27:41,630 --> 00:27:46,650
So if nothing else, this is a great tool to
play with and I encourage you guys to check

325
00:27:46,650 --> 00:27:52,110
it out. I hope that in the future we will
have more tools like this baked right into

326
00:27:52,110 --> 00:27:58,809
our, kind of day-to-day DevTools both on native
and web platforms.

327
00:27:58,809 --> 00:28:03,520
So it is all about the battery. It literally
is all about the battery. Whenever you're

328
00:28:03,520 --> 00:28:08,710
wondering, why does my mobile radio behave
in a certain way? Always ask the question

329
00:28:08,710 --> 00:28:14,120
of, how does it impact my battery life and
you will often find the answer there. Radio

330
00:28:14,120 --> 00:28:18,730
at full power, if it is on all the time, will
literally drain your battery in a matter of

331
00:28:18,730 --> 00:28:25,550
hours. If you have ever had your phone burning
your leg, you know how that feels. What's

332
00:28:25,550 --> 00:28:31,580
usually happening there is you can't get a
connection and some application is just continuously

333
00:28:31,580 --> 00:28:37,260
trying to reconnect and that turns on the
radio at full power. It drains your battery

334
00:28:37,260 --> 00:28:44,130
like there's no tomorrow. And the actual transfer
size does not matter. It doesn't matter if

335
00:28:44,130 --> 00:28:48,870
you're transferring one byte or a hundred
kilobytes. That's the other important take-away.

336
00:28:48,870 --> 00:28:54,940
So the consequence of that is you want to
pre-fetch data. You don't want to fetch -- I'll

337
00:28:54,940 --> 00:29:01,420
fetch the previews and thumbnails of my awesome
application and then as you scroll, I will

338
00:29:01,420 --> 00:29:05,059
fetch the rest. That's an anti-pattern in
mobile. You want to pre-fetch as much data

339
00:29:05,059 --> 00:29:11,090
as possible. Turn off the radio and hopefully
keep it off for as long as possible. We talked

340
00:29:11,090 --> 00:29:15,880
about periodic data transfers. What can you
do that? You can defer the request until later.

341
00:29:15,880 --> 00:29:21,860
You can combine them. You can log that data
into a local database like localstorage and

342
00:29:21,860 --> 00:29:28,240
then fire the request later. Of course, we
provide some tools for this, both on Android

343
00:29:28,240 --> 00:29:33,250
and Chrome. So Google Cloud Messaging is definitely
something that you guys should check out and

344
00:29:33,250 --> 00:29:39,150
leverage. What it allows you to do is you
can push notifications to our servers, through

345
00:29:39,150 --> 00:29:43,720
the Google Cloud Messaging servers, and then
those servers determine a optimal strategy

346
00:29:43,720 --> 00:29:49,570
for delivering those messages to your form
by limiting the number of data transfers.

347
00:29:49,570 --> 00:29:55,930
So for example, we just launched this support
on Chrome. We don't have future parity with

348
00:29:55,930 --> 00:30:02,930
Android. I hope we get there quick. On Android,
you can mark a message as delay while idle,

349
00:30:03,940 --> 00:30:09,990
which is to say, if the user's phone is idle,
don't push it right now. But when they wake

350
00:30:09,990 --> 00:30:14,520
up their phone, push the message there. And
not only that, but if you are going to delay

351
00:30:14,520 --> 00:30:18,980
the message, this is the time to live. Like
if the user doesn't wake up their phone within

352
00:30:18,980 --> 00:30:23,080
the next hour, just drop the message on the
floor. It's no longer relevant, right? It's

353
00:30:23,080 --> 00:30:28,260
an combination of these things that allow
you to build efficient applications with efficient

354
00:30:28,260 --> 00:30:33,010
delivery of messages to the phone without
necessarily having to wake up the phone or

355
00:30:33,010 --> 00:30:37,700
having your phone wake up periodically and
query our service. Which clearly does not

356
00:30:37,700 --> 00:30:43,040
scale.
So that's a little bit about how the network

357
00:30:43,040 --> 00:30:49,520
-- or how the radio works on the phone itself.
Now let's take a deep dive into how the mobile

358
00:30:49,520 --> 00:30:55,309
network, the core network actually works and
what implication it is has on performance.

359
00:30:55,309 --> 00:31:02,260
So at a very high level, the mobile network
effectively has a couple of important components.

360
00:31:02,260 --> 00:31:06,970
The first one is packet gateway. The way to
think about packet gateway, is basically like

361
00:31:06,970 --> 00:31:12,940
your wireless router or your router at your
us, right? It's a nat device which accepts

362
00:31:12,940 --> 00:31:16,900
all of the connections. It terminates all
the connections and then it forwards the packets

363
00:31:16,900 --> 00:31:23,900
to your device. In this case, a mobile device.
And there's an important pause here which

364
00:31:23,910 --> 00:31:29,780
is your connection or the connection to your
phone between the server and your phone is

365
00:31:29,780 --> 00:31:34,730
not an end-to-end connection. It is being
terminated by this router. So just the fact

366
00:31:34,730 --> 00:31:38,240
that you are turning off your radio or you're
pressing the power button on your phone does

367
00:31:38,240 --> 00:31:44,150
not terminate the TCP connection which I think
is a common misconception. And if you are

368
00:31:44,150 --> 00:31:48,559
ever seeing this kind of pattern where you
have your code basically saying, look, if

369
00:31:48,559 --> 00:31:52,440
I turn off the radio, I'm going to lose my
web socket connection or something else, that

370
00:31:52,440 --> 00:31:57,460
is not true. Because the connection is still
maintained by the radio network and it will

371
00:31:57,460 --> 00:32:02,760
wake up your radio when it's necessary. So
if you have code like this in your application,

372
00:32:02,760 --> 00:32:07,620
you definitely want to turn that off. Most
carriers have actually timeouts of anywhere

373
00:32:07,620 --> 00:32:14,620
between five to 30 minutes for a TCP connection.
If anything, I found that by working with

374
00:32:14,670 --> 00:32:20,440
many different apps, it's usually the applications
server on your side that's terminating the

375
00:32:20,440 --> 00:32:25,700
connection early on. Like you have aggressive
timeouts of 60 seconds. And then because of

376
00:32:25,700 --> 00:32:30,880
that, your app needs to periodically pull
your server to keep it open. So make sure

377
00:32:30,880 --> 00:32:36,410
that that plumbing is correct. It's not the
carriers in most cases.

378
00:32:36,410 --> 00:32:42,380
Okay. So we've got the packet gateway. Packet
gateway has no idea about the location of

379
00:32:42,380 --> 00:32:47,330
your device. What it actually does is it sends
-- it forwards the packets to the serving

380
00:32:47,330 --> 00:32:54,330
gateway. The serving gateway needs to figure
out, where are you? Where is your device?

381
00:32:54,740 --> 00:32:58,130
The trick is, the serving gateway actually
doesn't know that either. It basically needs

382
00:32:58,130 --> 00:33:04,420
to query a database like a user database to
say which radio tower are you currently associated

383
00:33:04,420 --> 00:33:08,950
with and how is your billing status? Should
I be even forwarding this packet to begin

384
00:33:08,950 --> 00:33:14,480
with? That's this mobility management entity.
It's like a user database. That's all it is.

385
00:33:14,480 --> 00:33:21,480
All right. So let's try this. Let's say we
want to send a data packet from your phone.

386
00:33:24,860 --> 00:33:29,620
We can actually connect all the pieces together
now. First my device is going to wake up and

387
00:33:29,620 --> 00:33:33,110
the first component is it is going to talk
to the radio tower. It is going to negotiate

388
00:33:33,110 --> 00:33:38,340
the time when it can send data. That will
take hundreds of milliseconds or up to two

389
00:33:38,340 --> 00:33:42,840
seconds on 3G networks. After that, it will
transfer data to the radio tower. The radio

390
00:33:42,840 --> 00:33:47,130
tower will transfer it to the serving gateway
which will forward it to the packet gateway.

391
00:33:47,130 --> 00:33:51,230
Only then will it hit the external network.
This is when the data is transferred to the

392
00:33:51,230 --> 00:33:57,420
server and all the rest. The latencies for
this end-to-end transferring here without

393
00:33:57,420 --> 00:34:01,750
the external network is anywhere between 50
milliseconds to hundreds of milliseconds on

394
00:34:01,750 --> 00:34:07,250
different networks. I pulled out these numbers
from the AT&T technical FAQ. Right? Basically

395
00:34:07,250 --> 00:34:12,759
the take-away here is 4G, 50 milliseconds
plus the transfer time to your server. On

396
00:34:12,759 --> 00:34:19,759
3G, as high as 400 milliseconds and much,
much worse for 2G networks. Turns out that's

397
00:34:20,559 --> 00:34:26,019
a simple case. Let's try the more complicated
case. I hope you guys stay with me here. Let's

398
00:34:26,019 --> 00:34:30,119
say we actually want to push a packet to the
device. Right? So we are trying to wake up

399
00:34:30,119 --> 00:34:36,690
the device. Our server pushes a packet to
the mobile carrier. It hits the packet gateway.

400
00:34:36,690 --> 00:34:41,149
That goes to the serving gateway. The serving
gateway, once again, has no idea where you

401
00:34:41,149 --> 00:34:44,909
are. Right? Once of the nice properties in
mobile networks, you guys are mobile. You

402
00:34:44,909 --> 00:34:48,309
hop into a car accident now you are on your
way out of San Francisco. We have no idea

403
00:34:48,309 --> 00:34:54,359
where you are. The serving gateway talks to
the mobility management here and it says,

404
00:34:54,359 --> 00:34:59,680
okay, I need to send this packet to this user.
Tell me where to forward the packet to. The

405
00:34:59,680 --> 00:35:05,900
mobility interface doesn't actually know your
current physical location. It knows geographically

406
00:35:05,900 --> 00:35:10,880
where you are. Okay, last time he checked
in, he was in San Francisco. So it sends a

407
00:35:10,880 --> 00:35:15,549
ping to all of the radio towers in the vicinity
and says just flood the entire network with

408
00:35:15,549 --> 00:35:21,499
a beacon that says, hey you, user number blah
blah blah, there's a packet waiting for you.

409
00:35:21,499 --> 00:35:26,710
Identify yourself, please. Your radio wakes
up. It gets that packet. It then talks to

410
00:35:26,710 --> 00:35:32,410
the tower and says, I'm here. I'm associated
with you right now. That data gets transferred

411
00:35:32,410 --> 00:35:36,400
back, goes back to the serving gateway and
now can transfer the data back to the tower

412
00:35:36,400 --> 00:35:43,400
and to your device. This is pretty complicated,
right? The reason I'm pointing this out is

413
00:35:43,950 --> 00:35:47,950
oftentimes there's a question of, like, why
does it take 200 milliseconds to do this?

414
00:35:47,950 --> 00:35:51,849
But clearly this is a pretty complicated problem
to solve, right? So the fact that we can do

415
00:35:51,849 --> 00:35:58,849
this in 40 to 50 milliseconds in 4G is actually
rather impressive to be honest.

416
00:35:58,930 --> 00:36:05,930
All right, so, this is a little crazy. But
is it worth it? I think this is a valid question

417
00:36:06,319 --> 00:36:11,539
to ask. We went from Wi-Fi where we had nothing.
Right? We had just talk. We hoped for the

418
00:36:11,539 --> 00:36:16,999
best. Cross our fingers. We went to this 4G
network interface where we now have all these

419
00:36:16,999 --> 00:36:23,999
routers. Radio towers talking to each other.
It's all crazy. Where are we going? So this

420
00:36:25,420 --> 00:36:32,420
is a great case study that was done a couple
years back actually in 2011. Where they measured

421
00:36:32,829 --> 00:36:39,829
performance of Wi-Fi networks, typical whole
router networks. I think this was 802.11G,

422
00:36:40,059 --> 00:36:47,059
so fairly new standard. They compared it against
LTE. So just focus on these two clusters here.

423
00:36:47,739 --> 00:36:52,940
What I want to point out, first of all the
through put is better. Most importantly is

424
00:36:52,940 --> 00:36:59,940
this graph right here, the round trip time
for our packets. With Wi-Fi, there's no guaranties

425
00:37:01,579 --> 00:37:06,160
about the latency of the delivery of your
packets. That's why you have these giant tails

426
00:37:06,160 --> 00:37:11,210
here. Generally speaking, the latency is fairly
low. But then you have these outliers which

427
00:37:11,210 --> 00:37:18,049
is why this line is stretched. With LTE, even
though it is seemingly more complicated -- not

428
00:37:18,049 --> 00:37:24,739
seemingly, it is more complicated, we can
deliver more reliable latency and lower jitter

429
00:37:24,739 --> 00:37:31,739
across the network. So this is good. Right?
This is, like, great. 4G will make things

430
00:37:32,089 --> 00:37:39,089
better.
So a couple of things. Mobile radio is optimized

431
00:37:41,930 --> 00:37:48,930
for burst data transfers. It is not optimized
for sending bits in small chunks, right? If

432
00:37:50,079 --> 00:37:55,809
what you want to do is transfer as much data
as possible and then turn off the radio. In

433
00:37:55,809 --> 00:38:02,079
fact, the latest 4G networks can transfer
on the order of tens of megabits per second,

434
00:38:02,079 --> 00:38:08,059
which is really high data rates. But it will
do so in very small assignments. In fact,

435
00:38:08,059 --> 00:38:13,549
the bandwidth assignments are done in millisecond
and lower chunks. All right? So you get a

436
00:38:13,549 --> 00:38:18,829
chunk of space, air space, for about one millisecond.
You can transfer huge amounts of data. So

437
00:38:18,829 --> 00:38:25,829
pack as much data as you can. Group your requests.
Don't delay requests. The not so good news

438
00:38:27,869 --> 00:38:34,059
part of the 4G world is that 4G will take
a while to come. Despite the fact that there

439
00:38:34,059 --> 00:38:39,720
is ads everywhere across all the highways
and everywhere else that 4G will save all

440
00:38:39,720 --> 00:38:45,349
things, 4G will take a while to deploy. Current
carriers have deployed a lot of infrastructure

441
00:38:45,349 --> 00:38:50,200
for 3G and they are continuing to improve
that in part because they can and in part

442
00:38:50,200 --> 00:38:56,960
because it's very expensive. So the dominant
network type of this decade -- not just this

443
00:38:56,960 --> 00:39:02,269
year or in the coming year -- of this decade
will be 3G networks. Granted, they are being

444
00:39:02,269 --> 00:39:09,099
enhanced to deliver higher data rates. But
nevertheless, you can see overall growth projections

445
00:39:09,099 --> 00:39:15,200
are for 3G networks. The good news is, at
least within North America, LTE and HSPA,

446
00:39:15,200 --> 00:39:19,249
which are 4G networks, are actually taking
off quite well. In fact, we are way ahead

447
00:39:19,249 --> 00:39:25,950
of the curve compared to all the other countries.
But nonetheless, you have to basically assume

448
00:39:25,950 --> 00:39:31,619
that your users will be using a mix of 3G
and 4G networks. Right? Even if you have a

449
00:39:31,619 --> 00:39:38,619
4G network data plan on your phone, your phone
is switching between 4G and 3G all the time

450
00:39:39,220 --> 00:39:45,480
and depending on coverage or where you currently
are and load within the network. So because

451
00:39:45,480 --> 00:39:51,349
of that, you have to design for variable network
performance and availability. It is truly

452
00:39:51,349 --> 00:39:56,220
a multi-generation future. You can't assume
that you will get great performance with 4G.

453
00:39:56,220 --> 00:40:01,710
You need to plan for 3G networks as well.
Bandwidth and latency are variable and, of

454
00:40:01,710 --> 00:40:06,739
course, as we have all experienced, connectivity
is intermittent. So if you are building a

455
00:40:06,739 --> 00:40:11,869
mobile application or an application for the
mobile web, you have to assume that there

456
00:40:11,869 --> 00:40:18,869
should be an offline mode or some fallback
to say what happens when I can't actually

457
00:40:19,259 --> 00:40:25,450
connect. And I mentioned this before, but
I think this is an important point to make

458
00:40:25,450 --> 00:40:32,450
once again. You should have some sort of a
back-off strategy. Oftentimes the reason we

459
00:40:34,059 --> 00:40:41,059
have poor battery performance is because some
application does not plan for intermittent

460
00:40:41,460 --> 00:40:45,670
connectivity or the fact that there is no
connectivity and it just continues to pull

461
00:40:45,670 --> 00:40:50,809
the server to say, are you there yet? Are
you there yet? Are you there yet? And that's

462
00:40:50,809 --> 00:40:56,880
what's burning your leg and burning the battery
on your device. What you want to do instead

463
00:40:56,880 --> 00:41:03,720
is to say, I'm going to try to connect now
and then every time I fail, I will just punt

464
00:41:03,720 --> 00:41:07,769
further out into the future, have some sort
of a decay function, and then say I'm going

465
00:41:07,769 --> 00:41:13,650
to stop after this interval and retry later.
Nine cases out of ten, whenever I have a performance

466
00:41:13,650 --> 00:41:17,640
or battery life program, I track it down to
exactly this. It's some application that's

467
00:41:17,640 --> 00:41:24,640
just sitting there in the loop while not connected,
keep trying, right? Not a good strategy.

468
00:41:27,119 --> 00:41:33,369
So with that, I think we've gone through kind
of the full cycle and we're back to application

469
00:41:33,369 --> 00:41:39,140
best practices. Of course, all of the radio
stuff is very important but optimizing TCP

470
00:41:39,140 --> 00:41:44,680
best practices, TLS, and http is very important.
The take-away here is, of course, measure

471
00:41:44,680 --> 00:41:48,499
first. Make sure that you are using a real
user measurement and measuring performance

472
00:41:48,499 --> 00:41:54,369
across real networks. Do that first, then
optimize later. And I'll just call out an

473
00:41:54,369 --> 00:42:01,369
couple of examples. Fastest request is a request
not made. This is an obvious one. But turns

474
00:42:02,470 --> 00:42:07,509
out when we analyze a lot of mobile applications,
they are not caching data. This is like number

475
00:42:07,509 --> 00:42:12,269
one problem for a lot of applications. So
make sure you do that. Bytes are literally

476
00:42:12,269 --> 00:42:17,599
expensive for a lot of users. You need to
compress resources and it's funny because

477
00:42:17,599 --> 00:42:21,900
we have been talking about compressing resources,
compressing images for years but we still

478
00:42:21,900 --> 00:42:26,119
find that a lot of applications don't do it.
And of course, leveraging performance like

479
00:42:26,119 --> 00:42:31,289
WebP as you heard in the keynote. We had a
session earlier today in WebP, I definitely

480
00:42:31,289 --> 00:42:38,289
encourage you to try it both on web and native.
And then finally, a shameless self-promotion.

481
00:42:39,599 --> 00:42:45,039
I have been writing a book on this stuff and
specifically on mobile radio performance and

482
00:42:45,039 --> 00:42:48,369
other things and it's available online for
free. If you guys are curious to learn more

483
00:42:48,369 --> 00:42:53,890
about this, and I can talk about it all day,
please check it out and please offer feedback.

484
00:42:53,890 --> 00:42:59,329
You can actually comment right on it.
And with that, I think we have some time for

485
00:42:59,329 --> 00:43:05,149
questions. If you can grab one of the mics,
I would be happy to answer them.

486
00:43:05,149 --> 00:43:12,149
[ Applause ]
>>> My name is Mauricio. I work for Verizon

487
00:43:24,289 --> 00:43:31,289
wireless. I have a question regarding APIs
or services that can be provided by Google

488
00:43:33,229 --> 00:43:38,589
-- the Android framework itself to help verticals
to make application more efficient. For example,

489
00:43:38,589 --> 00:43:45,589
the same way today does not allow you to put
network accessing your main thread. Is there

490
00:43:46,150 --> 00:43:53,019
anything planned to do in that manner?
>>Ilya Grigorik: So I can't -- -- I'm more

491
00:43:53,019 --> 00:43:56,960
-- I have more experience with the web part
of the stack so I can't necessarily comment

492
00:43:56,960 --> 00:44:02,599
on the Android part. I would actually direct
you to the Android guys sitting outside for

493
00:44:02,599 --> 00:44:09,599
that. But something like GCM, we continue
to enhance GCM, or the Google Cloud Messaging,

494
00:44:10,339 --> 00:44:13,390
and that's what you want to use for a lot
of your communication. Just recently we announced

495
00:44:13,390 --> 00:44:17,189
the ability to actually send data through
GCM as well.

496
00:44:17,189 --> 00:44:23,380
>>> Thank you.
>>> So my understanding of why LT is much

497
00:44:23,380 --> 00:44:30,380
better is partially because of the modulation
that it uses, since LT uses RFDM and Wi-Fi

498
00:44:31,140 --> 00:44:37,349
uses something different. Do you know if there's
any, like, industry trends to move the modulation

499
00:44:37,349 --> 00:44:43,140
scheme of the access points that you might
have at home to use that technology over,

500
00:44:43,140 --> 00:44:46,619
you know, what we have today since it's so
jittery.

501
00:44:46,619 --> 00:44:52,309
>>Ilya Grigorik: There's a couple of questions
in there. So LT has a host of different improvements.

502
00:44:52,309 --> 00:44:56,009
So they are basically redesigning the network
from the ground up. They are moving the scheduling

503
00:44:56,009 --> 00:45:00,759
stuff into the edges of the network. They
are using a new modulation scheme as you described.

504
00:45:00,759 --> 00:45:05,970
It's not just a modulation. Right? Because
that helps you with through-put but there's

505
00:45:05,970 --> 00:45:10,769
a number of other variables. Energy used,
latency of the assumption, connection, all

506
00:45:10,769 --> 00:45:16,729
the rest. For moving that same technology
into, let's say, your local access points,

507
00:45:16,729 --> 00:45:23,299
yes, to some degree. Wi-Fi standards and LTE
or 3GPP standards are completely separate.

508
00:45:23,299 --> 00:45:29,849
But just watching both of them, they do borrow
and steal from each other. So with the latest

509
00:45:29,849 --> 00:45:33,440
Wi-Fi standards, you will find that the way
they are -- the way they are achieving gigabyte

510
00:45:33,440 --> 00:45:37,229
data rates is by using the same tricks to
a large degree.

511
00:45:37,229 --> 00:45:41,400
>>> Do you know if that's in ADT2C or --
>>Ilya Grigorik: Yeah, that's in part how

512
00:45:41,400 --> 00:45:46,809
-- yeah, exactly. >>> Thank you.
>>> I'm fairly new to Android development.

513
00:45:46,809 --> 00:45:53,799
This may have been covered in the Cloud Messaging
feature. I was just wondering, is there any

514
00:45:53,799 --> 00:46:00,279
currently or plans to provide support for
aggregating requests from the OS level or

515
00:46:00,279 --> 00:46:05,789
framework to, you know, if you have multiple
apps running that have a stupid beacon request,

516
00:46:05,789 --> 00:46:11,019
is there any support for, like, ganging these
together so multiple apps kind of work with

517
00:46:11,019 --> 00:46:13,920
each other instead of against each other to
reduce radio usage?

518
00:46:13,920 --> 00:46:18,200
>>Ilya Grigorik: That's something definitely
we are looking at. That is only something

519
00:46:18,200 --> 00:46:22,460
the platform can provide. As an application
designer, you can't control what the other

520
00:46:22,460 --> 00:46:27,720
applications are doing. This is definitely
something we are thinking about both on the

521
00:46:27,720 --> 00:46:32,239
web, like, on Chrome for example, how can
Chrome leverage something like this, and also

522
00:46:32,239 --> 00:46:37,970
with the Android platform. A good example
of this is turning off the radio early. Like

523
00:46:37,970 --> 00:46:42,559
if we know that there's no other connections
being made, we can terminate the connections

524
00:46:42,559 --> 00:46:47,339
early. That can be done by the operating system
in conjunction with the radio resource controller.

525
00:46:47,339 --> 00:46:52,089
So, yes, there's definitely work in that direction.
>>> So that's nothing current but it's in

526
00:46:52,089 --> 00:46:55,440
the works?
>>Ilya Grigorik: Yep.

527
00:46:55,440 --> 00:46:59,880
>>> Do you have recommendations for tools
to just as a user to help figure out, like,

528
00:46:59,880 --> 00:47:05,089
what's killing your battery on iOS and Android?
>>Ilya Grigorik: So I hope we make that tooling

529
00:47:05,089 --> 00:47:10,160
much better. I guess a couple of tips that
I use. One is you actually have the battery

530
00:47:10,160 --> 00:47:15,150
panel within Android. If you go into your
settings and kind of navigate down, it actually

531
00:47:15,150 --> 00:47:19,380
gives you a really good breakdown of which
applications consume power. If you click on

532
00:47:19,380 --> 00:47:23,900
the graph, it will also show you a breakdown
of when the power is being consumed. So I

533
00:47:23,900 --> 00:47:29,369
find that is the most effective way to identify
specific applications. I think we need to

534
00:47:29,369 --> 00:47:34,390
do more to isolate, like, at a web page level,
there's nothing really like that. And I think

535
00:47:34,390 --> 00:47:40,170
we need something like that. So I hope we
will have a better answer in a year's time.

536
00:47:40,170 --> 00:47:46,960
>>> Hi, could you talk a little bit about
strategies you would use for games because

537
00:47:46,960 --> 00:47:52,519
they have a completely different data access
pattern and they typically [indiscernable]

538
00:47:52,519 --> 00:47:57,369
instead of TCP and require lower latency in
case you are playing with someone else.

539
00:47:57,369 --> 00:48:01,599
>>Ilya Grigorik: So all of the same optimization
strategies apply there. Intermittent, it doesn't

540
00:48:01,599 --> 00:48:06,079
matter if it CCP, TCP. You need to wake up
the radio. So to the extent possible, you

541
00:48:06,079 --> 00:48:10,559
want to aggregate data. You don't want to
be beaconing back every single achievement

542
00:48:10,559 --> 00:48:17,309
unlocked by the user if that can be kept on
the device. So once again, leveraging things

543
00:48:17,309 --> 00:48:22,719
like GCM and others to aggregate that data,
it's all the same. The protocol doesn't actually

544
00:48:22,719 --> 00:48:28,410
matter.
>>> Hi, as a JavaScript developer, the best

545
00:48:28,410 --> 00:48:33,529
practice as you said is to batch API requests
or other requests. And could you comment on

546
00:48:33,529 --> 00:48:38,509
the beacon API which would help us tap into
actually when the radio is active.

547
00:48:38,509 --> 00:48:43,220
>>Ilya Grigorik: The beacon API? Are you talking
about the new proposal?

548
00:48:43,220 --> 00:48:45,219
>>> Yeah, and then what the status of that
is.

549
00:48:45,219 --> 00:48:50,400
>>Ilya Grigorik: Yeah. So in the http performance
working group, we are working on a couple

550
00:48:50,400 --> 00:48:55,869
of proposals I guess. One is the beacon API
which is to say I want you to send this request

551
00:48:55,869 --> 00:49:00,420
but I don't actually care when you send it,
just send it when it's convenient for you.

552
00:49:00,420 --> 00:49:04,099
Good example of that is Analytics beacons.
Right? You don't want to wake up the radio

553
00:49:04,099 --> 00:49:10,609
right now. You are saying defer this. Dispatch
it at some later time. So there's no implementation

554
00:49:10,609 --> 00:49:15,869
of that yet. We have early drafts of the spec.
If you guys are interested, I definitely encourage

555
00:49:15,869 --> 00:49:21,059
you to check out the working group and comment
on it. But hopefully soon we will have something.

556
00:49:21,059 --> 00:49:25,190
>>> Okay, thanks.
>>> Can you talk about what tools you use

557
00:49:25,190 --> 00:49:31,420
to look at your Wi-Fi networks in those slides?
>>Ilya Grigorik: What is the tool that I used

558
00:49:31,420 --> 00:49:35,769
in -- I don't remember off the top of my head.
If you talk to me afterwards, I can find it

559
00:49:35,769 --> 00:49:41,380
on my laptop.
>>> I have a question about Analytics. What

560
00:49:41,380 --> 00:49:48,079
solutions are you currently [indiscernible]
not to lose the data value and to reduce the

561
00:49:48,079 --> 00:49:53,079
page rate consumption?
>>Ilya Grigorik: So for Analytics, what you

562
00:49:53,079 --> 00:49:55,969
generally want to do -- so this is actually
related to the previous question about the

563
00:49:55,969 --> 00:50:02,130
beacon API. Oftentimes you can report the
data later. One strategy is to literally stash

564
00:50:02,130 --> 00:50:06,969
the data into your local database and then
report it when the radio is active. This requires

565
00:50:06,969 --> 00:50:13,769
some modifications of your application itself.
But, for example, on the realtime Analytics,

566
00:50:13,769 --> 00:50:20,769
we don't actually ping back every so often
to just say that you are there. We actually

567
00:50:21,190 --> 00:50:26,450
do the realtime Analytics differently which
is to say, we track when you first visit the

568
00:50:26,450 --> 00:50:32,210
page, which is when you hit that beacon. And
then we say that you are active on the page

569
00:50:32,210 --> 00:50:37,849
for the next 30 seconds. Right? You have to
be -- if you navigate to another page, then

570
00:50:37,849 --> 00:50:43,950
you are still active. We are not forcing this
five-second interval. I think we need to talk

571
00:50:43,950 --> 00:50:48,019
to the other vendors and get them to move
in the same direction. They are literally

572
00:50:48,019 --> 00:50:52,549
costing a lot in terms of performance.
>>> And about Google Analytics, an additional

573
00:50:52,549 --> 00:50:56,609
question. Will it be a separate API extended
for request bulking?

574
00:50:56,609 --> 00:51:03,039
>>Ilya Grigorik: Can you say that again?
>>> So for example, we start an activity and

575
00:51:03,039 --> 00:51:08,069
we are reporting the user, when there is a
start of activity and when he left it. And

576
00:51:08,069 --> 00:51:15,069
there is a chain of that event. And will the
API Google Analytics extend it so we can bufferize

577
00:51:15,469 --> 00:51:21,859
this like to put a buffer and report later.
>>Ilya Grigorik: That's a great idea. There's

578
00:51:21,859 --> 00:51:26,680
ways to tackle that. Google Analytics can
provide a new API to basically say stash this

579
00:51:26,680 --> 00:51:30,930
and remember later. You can implement your
own wrap around it and basically say I am

580
00:51:30,930 --> 00:51:36,150
going to fire this later when I consider that
it is active. The best approach, I think,

581
00:51:36,150 --> 00:51:41,619
is a combination of two which is the beacon
API that we were just talking about which

582
00:51:41,619 --> 00:51:46,960
is basically a browser mechanism to say, we
will defer this to the browser to determine

583
00:51:46,960 --> 00:51:51,049
because it's actually in the best position.
So today the fastest way to get what you are

584
00:51:51,049 --> 00:51:55,059
talking about is to implement the new application.
I can certainly talk to the Google Analytics

585
00:51:55,059 --> 00:52:00,690
team and see if there is interest in implementing
something like this. I think that's a great

586
00:52:00,690 --> 00:52:04,010
idea. Maybe in a year's time we will have
something like the beacon Analytics.

587
00:52:04,010 --> 00:52:08,499
>>> We are way over. We are going to need
to wrap up.

588
00:52:08,499 --> 00:52:13,829
>>Ilya Grigorik: Okay, one more.
>>> My question is related to the Nexus 4.

589
00:52:13,829 --> 00:52:18,890
I have always used Verizon, I have never had
any signal reception issues until I switched

590
00:52:18,890 --> 00:52:25,890
to T-Mobile. At my house on the first floor,
I only get edge. On the second floor, I get

591
00:52:28,059 --> 00:52:35,059
edge but it's if-y. On the third floor, I
will get edge and HSPA+. This is the thing,

592
00:52:36,279 --> 00:52:41,219
with this phone, the decibel rating, from
what I'm reading, is like around a hundred.

593
00:52:41,219 --> 00:52:46,069
If I hold the phone in my hand, I lose signal.
>>Ilya Grigorik: Yep. You're holding it wrong.

594
00:52:46,069 --> 00:52:49,339
[ Laughter ]
>>> But this is the thing, if I'm on a phone

595
00:52:49,339 --> 00:52:55,469
call and then I hold it, it doesn't drop signal.
So my question is, is there a way that I,

596
00:52:55,469 --> 00:53:01,779
as an end user, can make the phone put more
power into the radio to hold the signal? Because

597
00:53:01,779 --> 00:53:06,130
I can't change T-Mobile.
>>Ilya Grigorik: So the short answer is no.

598
00:53:06,130 --> 00:53:10,319
The energy use is actually dictated by the
radio tower. It actually tells you, depending

599
00:53:10,319 --> 00:53:14,460
on where you are, like the distance between
you and the radio tower. The amount of other

600
00:53:14,460 --> 00:53:19,130
people talking. The exact signal power that
you should be transmitting. So, in fact, radio

601
00:53:19,130 --> 00:53:23,660
tower is trying to help you optimize your
battery use. Which sounds like, in this case,

602
00:53:23,660 --> 00:53:28,700
it may be working against you. But there's
no explicit control of that, unfortunately.

603
00:53:28,700 --> 00:53:31,270
>>> Thank you.
>>Ilya Grigorik: Thank, thanks guys.

604
00:53:31,270 --> 00:53:31,630
[ Applause ]

