1
00:00:00,000 --> 00:00:06,300

2
00:00:06,300 --> 00:00:07,820
SETH LADD: OK, we are live.

3
00:00:07,820 --> 00:00:11,080
Here we are, special episode
of "Dartisans," with Dart

4
00:00:11,080 --> 00:00:12,530
engineer Nicolas Geoffray.

5
00:00:12,530 --> 00:00:13,930
Hello, Nicolas.

6
00:00:13,930 --> 00:00:15,080
NICOLAS GEOFFRAY: Hello.

7
00:00:15,080 --> 00:00:16,850
SETH LADD: Now where
are you today?

8
00:00:16,850 --> 00:00:19,390
NICOLAS GEOFFRAY: I'm hanging
out in Zurich.

9
00:00:19,390 --> 00:00:20,040
SETH LADD: This is awesome.

10
00:00:20,040 --> 00:00:21,840
So you look like you're
in a little car.

11
00:00:21,840 --> 00:00:24,590
Where are you?

12
00:00:24,590 --> 00:00:27,990
NICOLAS GEOFFRAY: I could make
you a little tour, actually.

13
00:00:27,990 --> 00:00:29,440
I don't know how it's
called in English,

14
00:00:29,440 --> 00:00:30,950
but it's like a skillet.

15
00:00:30,950 --> 00:00:32,380
SETH LADD: I think it's
a little gondola.

16
00:00:32,380 --> 00:00:35,020
NICOLAS GEOFFRAY: Gondola.

17
00:00:35,020 --> 00:00:36,070
SETH LADD: I love the
Zurich office.

18
00:00:36,070 --> 00:00:39,190
It's a very, very cool office.

19
00:00:39,190 --> 00:00:41,330
NICOLAS GEOFFRAY: Yeah, it's
nice to hang out here.

20
00:00:41,330 --> 00:00:43,000
SETH LADD: Well thank you
for taking the time.

21
00:00:43,000 --> 00:00:45,670
So some really interesting
developments over the past

22
00:00:45,670 --> 00:00:47,390
couple weeks.

23
00:00:47,390 --> 00:00:50,400
So we should start off with
where do you normally work,

24
00:00:50,400 --> 00:00:53,330
and what project
do you work on?

25
00:00:53,330 --> 00:00:57,490
NICOLAS GEOFFRAY: I normally
work in Aarhus, Denmark.

26
00:00:57,490 --> 00:00:59,990
That's where lots of Dart
stuff is happening.

27
00:00:59,990 --> 00:01:02,250
And I'm working on dart2js.

28
00:01:02,250 --> 00:01:06,750
That's the compiler that
compiles Dart programs to

29
00:01:06,750 --> 00:01:08,880
JavaScript.

30
00:01:08,880 --> 00:01:11,430
SETH LADD: And the dart2js
compiler itself is written in

31
00:01:11,430 --> 00:01:12,710
Dart, correct?

32
00:01:12,710 --> 00:01:13,480
NICOLAS GEOFFRAY: It is.

33
00:01:13,480 --> 00:01:14,270
SETH LADD: So that's
pretty cool.

34
00:01:14,270 --> 00:01:17,640
So we're dog fooding our own
language and tools to make

35
00:01:17,640 --> 00:01:18,270
more tools.

36
00:01:18,270 --> 00:01:21,020
I like that.

37
00:01:21,020 --> 00:01:24,470
We had a very interesting
development last week.

38
00:01:24,470 --> 00:01:27,160
Why don't you go ahead and share
your screen, and we'll

39
00:01:27,160 --> 00:01:29,900
talk about what happened.

40
00:01:29,900 --> 00:01:31,150
NICOLAS GEOFFRAY: Sounds good.

41
00:01:31,150 --> 00:01:34,400

42
00:01:34,400 --> 00:01:35,650
Start screenshare.

43
00:01:35,650 --> 00:01:40,980

44
00:01:40,980 --> 00:01:42,580
So here you can see
what happened.

45
00:01:42,580 --> 00:01:45,220
SETH LADD: Ah, look at
those healthy bumps.

46
00:01:45,220 --> 00:01:48,360
So we're looking at the
performance charts you can

47
00:01:48,360 --> 00:01:53,030
find on dartlang.org, where we
track the performance of some

48
00:01:53,030 --> 00:01:56,890
well-known benchmarks across
the V8 world, which is our

49
00:01:56,890 --> 00:02:01,240
JavaScript engine; the Dart VM
world, which is the teal line

50
00:02:01,240 --> 00:02:05,690
on the top; and dart2js, which
is the purple line.

51
00:02:05,690 --> 00:02:10,419
And Nicolas, what happened
there last week?

52
00:02:10,419 --> 00:02:13,711
NICOLAS GEOFFRAY: You can see
the small bumps here.

53
00:02:13,711 --> 00:02:17,640
I don't know if you can follow
me with the mouse.

54
00:02:17,640 --> 00:02:22,970
But what actually happened is
that now we have better

55
00:02:22,970 --> 00:02:25,690
tracking of types of fields and

56
00:02:25,690 --> 00:02:29,035
parameters given to a method.

57
00:02:29,035 --> 00:02:33,350
That enables us to do better
optimizations inside methods.

58
00:02:33,350 --> 00:02:35,590
So we know what kind of fields,
what kind of types

59
00:02:35,590 --> 00:02:37,860
we're getting in the field, and
what kind of types we're

60
00:02:37,860 --> 00:02:40,580
getting when we're in a method
for a parameter.

61
00:02:40,580 --> 00:02:44,050

62
00:02:44,050 --> 00:02:46,330
So the small bumps that
come into little--

63
00:02:46,330 --> 00:02:51,770
I mean, like this was last week,
this was a few days ago.

64
00:02:51,770 --> 00:02:57,050
It's because we got better
improvements on that type

65
00:02:57,050 --> 00:02:59,780
inferencing, as we call it.

66
00:02:59,780 --> 00:03:01,080
SETH LADD: So it looks--

67
00:03:01,080 --> 00:03:03,240
and what's really interesting,
maybe you can explain this to

68
00:03:03,240 --> 00:03:06,920
me, is the code which is the
purple line here, that is

69
00:03:06,920 --> 00:03:08,770
output by dart2js--

70
00:03:08,770 --> 00:03:10,640
which is outputting
JavaScript--

71
00:03:10,640 --> 00:03:13,860
is actually running
faster than V8.

72
00:03:13,860 --> 00:03:18,300
Now of course when we run the
output JavaScript on V8--

73
00:03:18,300 --> 00:03:19,830
I mean, what are we
looking at here?

74
00:03:19,830 --> 00:03:23,752
How can V8 run faster than V8?

75
00:03:23,752 --> 00:03:26,100
NICOLAS GEOFFRAY: So this
is pretty funny.

76
00:03:26,100 --> 00:03:33,270
You would guess that we would
run at 100% of V8 ideally.

77
00:03:33,270 --> 00:03:36,190
That's our goal in
the dart2js team.

78
00:03:36,190 --> 00:03:41,470
What is happening is that we're
getting pretty lucky

79
00:03:41,470 --> 00:03:48,360
with the V8 compiler, because
we're reaching a nice path in

80
00:03:48,360 --> 00:03:51,460
the V8 compiler that
allocates--

81
00:03:51,460 --> 00:03:56,490
that does better register
allocation, things like that.

82
00:03:56,490 --> 00:03:57,840
So that's one explanation.

83
00:03:57,840 --> 00:04:00,900
A second explanation is that
we're doing pretty aggressive

84
00:04:00,900 --> 00:04:04,220
aligning because we have
better knowledge

85
00:04:04,220 --> 00:04:07,120
of the whole program.

86
00:04:07,120 --> 00:04:14,367
And that knowledge is kind of
hard to gather with V8 when it

87
00:04:14,367 --> 00:04:17,769
runs the JavaScript version.

88
00:04:17,769 --> 00:04:21,320
SETH LADD: OK, so the
purple line isn't V8

89
00:04:21,320 --> 00:04:22,280
running faster than V8.

90
00:04:22,280 --> 00:04:28,440
It's the outputted code from
dart2js is just more

91
00:04:28,440 --> 00:04:32,580
intelligent than the handwritten
benchmark code

92
00:04:32,580 --> 00:04:36,130
that V8 is running as the
benchmark by which all other

93
00:04:36,130 --> 00:04:37,110
benchmarks are measured.

94
00:04:37,110 --> 00:04:38,110
NICOLAS GEOFFRAY: Yeah.

95
00:04:38,110 --> 00:04:39,110
That's correct.

96
00:04:39,110 --> 00:04:42,230
SETH LADD: That's awesome
So this is really cool.

97
00:04:42,230 --> 00:04:45,770
And so everyone can check this
out, dartlang.org/performance.

98
00:04:45,770 --> 00:04:49,020
I would say expect more
benchmarks soon.

99
00:04:49,020 --> 00:04:52,170
There's only two operating now,
DeltaBlue and Richards.

100
00:04:52,170 --> 00:04:54,470
And from what I guess, your
team is just getting

101
00:04:54,470 --> 00:04:56,570
started with this.

102
00:04:56,570 --> 00:04:58,840
From what I'm hearing, you're
even being a little

103
00:04:58,840 --> 00:05:01,740
conservative about how you
apply these inferences.

104
00:05:01,740 --> 00:05:06,710
So what's your feeling for the
runway here in terms of just

105
00:05:06,710 --> 00:05:08,360
general dart2js performance?

106
00:05:08,360 --> 00:05:11,120
Do you have more work to do?

107
00:05:11,120 --> 00:05:13,410
NICOLAS GEOFFRAY: We have
a lot of work to do.

108
00:05:13,410 --> 00:05:18,810
If you look at the benchmarks
DeltaBlue and Richards, we

109
00:05:18,810 --> 00:05:23,140
cover a lot when it comes to
doing type inferencing.

110
00:05:23,140 --> 00:05:25,930
There are some other benchmarks
that we're still

111
00:05:25,930 --> 00:05:31,130
working on where the type
inferencing still needs some

112
00:05:31,130 --> 00:05:35,110
improvements, and
working on that.

113
00:05:35,110 --> 00:05:35,770
SETH LADD: Cool.

114
00:05:35,770 --> 00:05:39,850
Well I know you prepared a
couple slides here to walk us

115
00:05:39,850 --> 00:05:43,800
through exactly what global
type inferencing means.

116
00:05:43,800 --> 00:05:47,800
Do you mind giving us kind of
a tour behind the scenes on

117
00:05:47,800 --> 00:05:50,340
how you guys achieved
these speed bumps?

118
00:05:50,340 --> 00:05:53,510
NICOLAS GEOFFRAY: Sure, so
a small explanation.

119
00:05:53,510 --> 00:05:57,090
The global type inferencing
looks at you whole program an

120
00:05:57,090 --> 00:06:01,900
looks at assignments to fields,
assignments to local

121
00:06:01,900 --> 00:06:04,700
variables, parameters
of methods.

122
00:06:04,700 --> 00:06:08,340
So every time you call a
method, we look at what

123
00:06:08,340 --> 00:06:10,700
parameters you call it with.

124
00:06:10,700 --> 00:06:13,790
And when you gather all that
information, at the end, you

125
00:06:13,790 --> 00:06:20,470
actually calculate or compute
the types of the fields and

126
00:06:20,470 --> 00:06:23,240
the types given to parameters.

127
00:06:23,240 --> 00:06:27,440
And in order to be correct,
you actually need to have

128
00:06:27,440 --> 00:06:29,440
global knowledge.

129
00:06:29,440 --> 00:06:32,390
And that's what we have when
we compile the Dart

130
00:06:32,390 --> 00:06:35,860
application to JavaScript.

131
00:06:35,860 --> 00:06:36,970
SETH LADD: And it's
global now.

132
00:06:36,970 --> 00:06:38,500
What about the Dart--
and by the way, all

133
00:06:38,500 --> 00:06:39,540
we see is your slide.

134
00:06:39,540 --> 00:06:42,700
So if you want to stop
screensharing for a minute,

135
00:06:42,700 --> 00:06:43,950
I'll ask you a couple
questions.

136
00:06:43,950 --> 00:06:45,810
Then we'll jump back
to the slides.

137
00:06:45,810 --> 00:06:48,740
But what is it about
Dart that--

138
00:06:48,740 --> 00:06:51,410
there you go.

139
00:06:51,410 --> 00:06:52,280
Hey.

140
00:06:52,280 --> 00:06:53,780
What is it about Dart
that allows you

141
00:06:53,780 --> 00:06:55,710
to do global analysis?

142
00:06:55,710 --> 00:06:57,130
Why can't we do this--

143
00:06:57,130 --> 00:06:58,880
why can't V8 do this
in JavaScript?

144
00:06:58,880 --> 00:07:01,690

145
00:07:01,690 --> 00:07:05,530
NICOLAS GEOFFRAY: What happens
in JavaScript is that you can

146
00:07:05,530 --> 00:07:08,610
download JavaScript
code on demand.

147
00:07:08,610 --> 00:07:12,530

148
00:07:12,530 --> 00:07:18,480
You can dynamically extend
your application with new

149
00:07:18,480 --> 00:07:20,490
calls, new assignments
to fields.

150
00:07:20,490 --> 00:07:22,940
And suddenly what you thought
you knew about

151
00:07:22,940 --> 00:07:24,565
the world gets extended.

152
00:07:24,565 --> 00:07:27,480

153
00:07:27,480 --> 00:07:32,350
In V8 land, when it's a VM doing
optimization, it needs

154
00:07:32,350 --> 00:07:33,580
to de-optimize.

155
00:07:33,580 --> 00:07:38,000
Because now it sees, oh, this
field is an int and not just a

156
00:07:38,000 --> 00:07:40,850
string or something like that.

157
00:07:40,850 --> 00:07:42,410
So that's the difference.

158
00:07:42,410 --> 00:07:44,640
With Dart, we actually have
knowledge of the whole

159
00:07:44,640 --> 00:07:46,990
application.

160
00:07:46,990 --> 00:07:50,860
There's no dynamic loading, and
it's pretty structured.

161
00:07:50,860 --> 00:07:54,990
So we know when we analyze
the program what kind of

162
00:07:54,990 --> 00:07:57,900
[INAUDIBLE] the fields
will have.

163
00:07:57,900 --> 00:08:00,160
SETH LADD: For everyone who's
just joining us, we're here

164
00:08:00,160 --> 00:08:02,580
chatting with Nicolas Geoffray,
one of the engineers

165
00:08:02,580 --> 00:08:05,520
on the dart2js project, who
normally works in Aarhus,

166
00:08:05,520 --> 00:08:08,020
Denmark, but today is joining
us in a gondola

167
00:08:08,020 --> 00:08:09,920
in the Zurich office.

168
00:08:09,920 --> 00:08:12,880
And we were chatting about some
of the recent performance

169
00:08:12,880 --> 00:08:17,630
bumps that he and his team have
landed which have shown

170
00:08:17,630 --> 00:08:19,590
some pretty nice improvements
with the

171
00:08:19,590 --> 00:08:22,190
benchmarks that we're tracking.

172
00:08:22,190 --> 00:08:25,290
We're talking about global type
inferencing and what the

173
00:08:25,290 --> 00:08:28,860
Dart language allows us to do
above and beyond maybe what

174
00:08:28,860 --> 00:08:30,985
the JavaScript or V8 can
do to get some of

175
00:08:30,985 --> 00:08:32,450
these performance bumps.

176
00:08:32,450 --> 00:08:36,230
But one thing that I like to
explain to people about Dart

177
00:08:36,230 --> 00:08:38,990
is that it has a known
starting point.

178
00:08:38,990 --> 00:08:41,909
Every Dart program starts
with the main function.

179
00:08:41,909 --> 00:08:43,470
And from there, the program--

180
00:08:43,470 --> 00:08:46,160
the whole program analysis
can start by holistically

181
00:08:46,160 --> 00:08:48,670
understanding the complete
boundaries of that program.

182
00:08:48,670 --> 00:08:52,150
And it sounds like you're able
to take advantage of this by

183
00:08:52,150 --> 00:08:56,190
doing a global type inference
across the entire program.

184
00:08:56,190 --> 00:08:57,800
NICOLAS GEOFFRAY: One thing I
should probably also add is

185
00:08:57,800 --> 00:09:00,130
that in JavaScript,
it's so dynamic.

186
00:09:00,130 --> 00:09:06,070
There's lots of functionalities
like eval, and

187
00:09:06,070 --> 00:09:11,790
different ways of changing
the value of a field.

188
00:09:11,790 --> 00:09:13,960
And that makes it very difficult
for a static

189
00:09:13,960 --> 00:09:18,680
analysis to actually track
types of variables.

190
00:09:18,680 --> 00:09:20,270
SETH LADD: Right.

191
00:09:20,270 --> 00:09:22,810
And so one thing I should
probably ask though is, we

192
00:09:22,810 --> 00:09:26,050
keep mentioning this global
type inferencing.

193
00:09:26,050 --> 00:09:29,170
My understanding, of course,
is Dart has an

194
00:09:29,170 --> 00:09:30,390
optional type system.

195
00:09:30,390 --> 00:09:34,810
Now for everyone following along
at home, why don't you

196
00:09:34,810 --> 00:09:37,320
just respect those
type annotations?

197
00:09:37,320 --> 00:09:39,370
I put those in there.

198
00:09:39,370 --> 00:09:41,560
But why you have to go to a
global type inferencing?

199
00:09:41,560 --> 00:09:45,670

200
00:09:45,670 --> 00:09:47,710
NICOLAS GEOFFRAY: The type
system in Dart is optional.

201
00:09:47,710 --> 00:09:49,600
You don't have to use it.

202
00:09:49,600 --> 00:09:51,160
And we actually have--

203
00:09:51,160 --> 00:09:55,030
Dart actually has two modes
for running applications.

204
00:09:55,030 --> 00:09:58,530
One is called checked
mode, and one is

205
00:09:58,530 --> 00:09:59,890
called unchecked mode.

206
00:09:59,890 --> 00:10:02,630

207
00:10:02,630 --> 00:10:05,770
In checked mode, the type
annotations actually have

208
00:10:05,770 --> 00:10:11,430
meaning, that we will check that
the types match what you

209
00:10:11,430 --> 00:10:13,520
put in a variable.

210
00:10:13,520 --> 00:10:17,605
So if you string a equals 2,
we'll check that and produce a

211
00:10:17,605 --> 00:10:19,250
runtime error.

212
00:10:19,250 --> 00:10:22,860
In unchecked mode, we don't
look at that limitations.

213
00:10:22,860 --> 00:10:24,230
We just go through.

214
00:10:24,230 --> 00:10:25,470
So string a equals 2?

215
00:10:25,470 --> 00:10:27,360
Fine, we'll continue.

216
00:10:27,360 --> 00:10:30,465
And that's the main reason
we do not use those type

217
00:10:30,465 --> 00:10:33,470
annotations for optimizing.

218
00:10:33,470 --> 00:10:38,680
It's like, if you see
string a, well,

219
00:10:38,680 --> 00:10:41,200
nothing will make sure--

220
00:10:41,200 --> 00:10:44,560
in non-checked mode, nothing
will make sure that your

221
00:10:44,560 --> 00:10:46,380
variable a will hold a string.

222
00:10:46,380 --> 00:10:48,390
You can put anything in it.

223
00:10:48,390 --> 00:10:52,540
So you need to analyze every
assignment to that a variable

224
00:10:52,540 --> 00:10:57,500
to make sure it gets
that type.

225
00:10:57,500 --> 00:10:59,130
SETH LADD: Awesome.

226
00:10:59,130 --> 00:11:02,040
And as a developer, I actually
really like the way Dart does

227
00:11:02,040 --> 00:11:05,090
this, in that I don't feel
like I have to appease a

228
00:11:05,090 --> 00:11:07,730
ceremonial type checker just
to get my program to run.

229
00:11:07,730 --> 00:11:10,660
And now that I see that the
engineers, like the guys in

230
00:11:10,660 --> 00:11:14,280
the dart2js team, are able to
analyze my program for me and

231
00:11:14,280 --> 00:11:18,590
infer these types anyway, I
still feel like the tools and

232
00:11:18,590 --> 00:11:21,230
runtimes can take
advantage of--

233
00:11:21,230 --> 00:11:24,200
if I use int everywhere, then
you're going to start assuming

234
00:11:24,200 --> 00:11:26,210
that's an int and take advantage
of that optimization

235
00:11:26,210 --> 00:11:27,680
by assuming it's an int.

236
00:11:27,680 --> 00:11:31,780

237
00:11:31,780 --> 00:11:34,640
This a good time to jump over
to the slides that you have,

238
00:11:34,640 --> 00:11:37,430
because I'm really curious to
see actually how this works.

239
00:11:37,430 --> 00:11:39,710
So can you walk us through
a little bit?

240
00:11:39,710 --> 00:11:40,960
NICOLAS GEOFFRAY: Yeah.

241
00:11:40,960 --> 00:11:43,980

242
00:11:43,980 --> 00:11:47,790
I've taken a small
code snippet of

243
00:11:47,790 --> 00:11:49,040
the DeltaBlue benchmark.

244
00:11:49,040 --> 00:11:51,882

245
00:11:51,882 --> 00:11:54,820
Here you have the slides.

246
00:11:54,820 --> 00:11:56,070
SETH LADD: I see me.

247
00:11:56,070 --> 00:11:58,280

248
00:11:58,280 --> 00:12:00,052
NICOLAS GEOFFRAY: Oh,
you only see you.

249
00:12:00,052 --> 00:12:01,302
SETH LADD: Yep.

250
00:12:01,302 --> 00:12:03,390

251
00:12:03,390 --> 00:12:05,860
NICOLAS GEOFFRAY: Screenshare.

252
00:12:05,860 --> 00:12:08,250
Let's try again.

253
00:12:08,250 --> 00:12:09,500
Desktop.

254
00:12:09,500 --> 00:12:13,810

255
00:12:13,810 --> 00:12:15,040
There it is now.

256
00:12:15,040 --> 00:12:15,290
SETH LADD: OK.

257
00:12:15,290 --> 00:12:15,800
I see it.

258
00:12:15,800 --> 00:12:17,770
Fire it up.

259
00:12:17,770 --> 00:12:19,020
NICOLAS GEOFFRAY: Present.

260
00:12:19,020 --> 00:12:26,860

261
00:12:26,860 --> 00:12:28,580
SETH LADD: And so before you
jump into this though, let's

262
00:12:28,580 --> 00:12:30,990
talk a little bit about the
benchmark that everyone's

263
00:12:30,990 --> 00:12:32,700
talking about, DeltaBlue.

264
00:12:32,700 --> 00:12:33,860
Where did this thing
come from?

265
00:12:33,860 --> 00:12:35,900
What does it do?

266
00:12:35,900 --> 00:12:39,160
Do you know anything about
its lineage or history?

267
00:12:39,160 --> 00:12:40,410
NICOLAS GEOFFRAY: Not really.

268
00:12:40,410 --> 00:12:43,890

269
00:12:43,890 --> 00:12:46,970
So DeltaBlue is a pretty popular
benchmark that I think

270
00:12:46,970 --> 00:12:49,200
started with maybe Smalltalk--

271
00:12:49,200 --> 00:12:51,140
I'm actually not sure--

272
00:12:51,140 --> 00:12:55,200
and got ported to Java,
and ported to

273
00:12:55,200 --> 00:12:57,410
JavaScript by the V8 team.

274
00:12:57,410 --> 00:13:01,165
And now it's been ported to Dart
by the same-- well, the

275
00:13:01,165 --> 00:13:04,210
former V8 team, and
now the Dart team.

276
00:13:04,210 --> 00:13:05,370
It's a fairly--

277
00:13:05,370 --> 00:13:09,520
it's an object-oriented
benchmark, uses typical

278
00:13:09,520 --> 00:13:15,310
objects, and object dispatch.

279
00:13:15,310 --> 00:13:20,270
So it's the kind of benchmark
that should represent a real

280
00:13:20,270 --> 00:13:21,650
application.

281
00:13:21,650 --> 00:13:22,310
SETH LADD: OK, cool.

282
00:13:22,310 --> 00:13:26,210
So it has a long lineage that's
been ported many times.

283
00:13:26,210 --> 00:13:27,540
And it's really stressing an

284
00:13:27,540 --> 00:13:29,900
object-oriented type of system.

285
00:13:29,900 --> 00:13:31,840
NICOLAS GEOFFRAY: Yes.

286
00:13:31,840 --> 00:13:35,245
So if you write applications
really object-oriented, it

287
00:13:35,245 --> 00:13:37,530
should be pretty similar.

288
00:13:37,530 --> 00:13:40,830
SETH LADD: So what are
we looking at here?

289
00:13:40,830 --> 00:13:43,370
NICOLAS GEOFFRAY: This is a
method written in Dart of the

290
00:13:43,370 --> 00:13:46,500
DeltaBlue benchmark.

291
00:13:46,500 --> 00:13:50,450
It's one of the hottest methods
of the benchmark.

292
00:13:50,450 --> 00:13:52,960

293
00:13:52,960 --> 00:13:53,940
I've taken a snipped.

294
00:13:53,940 --> 00:13:57,885
And you can see it's
pretty simple.

295
00:13:57,885 --> 00:14:00,650
You've got a method with
two parameters.

296
00:14:00,650 --> 00:14:11,700
And walk over the elements of
the list and check if it

297
00:14:11,700 --> 00:14:16,600
satisfies some constraint, and
then add it to another list.

298
00:14:16,600 --> 00:14:18,290
SETH LADD: OK, pretty
straightforward code here.

299
00:14:18,290 --> 00:14:21,410

300
00:14:21,410 --> 00:14:24,670
NICOLAS GEOFFRAY: The next slide
shows what we used to

301
00:14:24,670 --> 00:14:26,760
generate back then.

302
00:14:26,760 --> 00:14:30,620
That means like two weeks ago.

303
00:14:30,620 --> 00:14:32,240
SETH LADD: We can
see your mouse.

304
00:14:32,240 --> 00:14:35,680
So if you want to move your
mouse to point to areas that

305
00:14:35,680 --> 00:14:36,810
you're talking about,
go for it.

306
00:14:36,810 --> 00:14:38,060
NICOLAS GEOFFRAY: Oh, sure.

307
00:14:38,060 --> 00:14:39,730

308
00:14:39,730 --> 00:14:46,010
That's revision 19850, back
when we didn't have global

309
00:14:46,010 --> 00:14:48,810
type inferencing.

310
00:14:48,810 --> 00:14:51,860
And you can see it's
not looking as

311
00:14:51,860 --> 00:14:56,010
good as the Dart version.

312
00:14:56,010 --> 00:15:01,770
There's a lot of checking, like
you were checking if a

313
00:15:01,770 --> 00:15:05,880
call to a length getter on some

314
00:15:05,880 --> 00:15:08,410
variable gives you a number.

315
00:15:08,410 --> 00:15:11,640
And if it doesn't, we actually
jump to a method

316
00:15:11,640 --> 00:15:15,270
that will handle it.

317
00:15:15,270 --> 00:15:18,460
You can see that before,
we used the Dart

318
00:15:18,460 --> 00:15:20,300
version as a for loop.

319
00:15:20,300 --> 00:15:24,590
Now we can just have a while
loop because we have all these

320
00:15:24,590 --> 00:15:29,130
statements that cannot be
expressed in a for loop.

321
00:15:29,130 --> 00:15:32,280
We need to break here
to break the loop.

322
00:15:32,280 --> 00:15:36,650
So it doesn't look as nice
as the Dart version.

323
00:15:36,650 --> 00:15:40,720
And today what we generate is
actually pretty close to the

324
00:15:40,720 --> 00:15:48,680
Dart version, with a for loop,
and just a check of the

325
00:15:48,680 --> 00:15:54,690
condition, and adding to a new
collection, very similar to

326
00:15:54,690 --> 00:15:58,940
that Dart version.

327
00:15:58,940 --> 00:16:02,180
SETH LADD: Now help me
understand for the second

328
00:16:02,180 --> 00:16:05,440
slide, the original
JavaScript.

329
00:16:05,440 --> 00:16:08,220
Why did you have to move
to a while loop and

330
00:16:08,220 --> 00:16:09,470
put all those bailouts?

331
00:16:09,470 --> 00:16:12,540

332
00:16:12,540 --> 00:16:14,910
NICOLAS GEOFFRAY: The reason we
have those bailouts is to

333
00:16:14,910 --> 00:16:20,120
actually have good performance
when running on top of

334
00:16:20,120 --> 00:16:21,700
JavaScript.

335
00:16:21,700 --> 00:16:26,040
If you were not to have all
these checks here, we couldn't

336
00:16:26,040 --> 00:16:28,620
omit this less than
directly, like

337
00:16:28,620 --> 00:16:31,710
JavaScript built-in operators.

338
00:16:31,710 --> 00:16:34,090
Dart has different semantics.

339
00:16:34,090 --> 00:16:40,850
And every object actually has
its own less than method.

340
00:16:40,850 --> 00:16:43,370
So it's not like we can use
the JavaScript built-in

341
00:16:43,370 --> 00:16:46,180
operator for that.

342
00:16:46,180 --> 00:16:48,580
SETH LADD: Right, because at
that point you don't know it's

343
00:16:48,580 --> 00:16:49,950
actually an int.

344
00:16:49,950 --> 00:16:53,120
So first you'd say, is this
thing really an int.

345
00:16:53,120 --> 00:16:53,800
If so, great.

346
00:16:53,800 --> 00:16:54,760
Go ahead and use less than.

347
00:16:54,760 --> 00:16:57,700
Because in Dart code, you have
operator overriding.

348
00:16:57,700 --> 00:16:58,880
You could have any object--

349
00:16:58,880 --> 00:17:01,810
or, sorry, any class implement
its own version of less than.

350
00:17:01,810 --> 00:17:02,440
NICOLAS GEOFFRAY:
That's correct.

351
00:17:02,440 --> 00:17:04,640
And you can see that I actually
have another check

352
00:17:04,640 --> 00:17:09,430
here, which is always
v.get$constraints, an array.

353
00:17:09,430 --> 00:17:14,099
And if it's not then I need to
go again in a bailout in the

354
00:17:14,099 --> 00:17:15,910
non-optimized version.

355
00:17:15,910 --> 00:17:16,960
And if it is, then great.

356
00:17:16,960 --> 00:17:20,220
I can do typical array indexing,
like transcript

357
00:17:20,220 --> 00:17:24,920
array indexing, and call--

358
00:17:24,920 --> 00:17:28,940
yeah, so typical array
indexing here.

359
00:17:28,940 --> 00:17:33,760
SETH LADD: OK, so the original
code has to accommodate a very

360
00:17:33,760 --> 00:17:36,090
dynamic world, because
he doesn't know

361
00:17:36,090 --> 00:17:37,594
these objects can be.

362
00:17:37,594 --> 00:17:38,370
NICOLAS GEOFFRAY: Yeah.

363
00:17:38,370 --> 00:17:38,870
He doesn't know.

364
00:17:38,870 --> 00:17:41,152
SETH LADD: But, the new world.

365
00:17:41,152 --> 00:17:45,260
NICOLAS GEOFFRAY: The new world,
which does a better

366
00:17:45,260 --> 00:17:51,190
inferencing on variables,
does know all of this.

367
00:17:51,190 --> 00:17:56,900
You can see it knows that t1
here is a JavaScript array.

368
00:17:56,900 --> 00:18:01,840
So v.constraints is a
JavaScript array.

369
00:18:01,840 --> 00:18:05,670
So it can just use the
built-in less than of

370
00:18:05,670 --> 00:18:06,920
JavaScript.

371
00:18:06,920 --> 00:18:10,080

372
00:18:10,080 --> 00:18:13,890
Again, it uses the built-in
indexing operator here.

373
00:18:13,890 --> 00:18:16,600

374
00:18:16,600 --> 00:18:17,850
SETH LADD: That is so cool.

375
00:18:17,850 --> 00:18:23,530

376
00:18:23,530 --> 00:18:26,440
OK, so the new world.

377
00:18:26,440 --> 00:18:29,310

378
00:18:29,310 --> 00:18:33,860
How do you actually go about
analyzing and say, OK, i is

379
00:18:33,860 --> 00:18:35,790
really an int now.

380
00:18:35,790 --> 00:18:37,690
It looks like that's the
major change, isn't it?

381
00:18:37,690 --> 00:18:41,260
Now you've been able to analyze
the program and say I

382
00:18:41,260 --> 00:18:45,410
know for a fact that some of
these variables point to

383
00:18:45,410 --> 00:18:49,440
objects of these types so I can
eliminate all bailouts.

384
00:18:49,440 --> 00:18:51,150
That's basically what's
happening, right?

385
00:18:51,150 --> 00:18:52,370
NICOLAS GEOFFRAY: That's
basically what's happening.

386
00:18:52,370 --> 00:18:57,600
We have better information of
the types of some fields.

387
00:18:57,600 --> 00:18:58,580
And we can do better.

388
00:18:58,580 --> 00:19:04,080
I'll actually go through some
of them, just to show the

389
00:19:04,080 --> 00:19:07,530
difference of some statements
of the [INAUDIBLE] code.

390
00:19:07,530 --> 00:19:12,010

391
00:19:12,010 --> 00:19:13,260
This is the old version.

392
00:19:13,260 --> 00:19:15,660

393
00:19:15,660 --> 00:19:20,690
And you can see that we're
actually calling a getter.

394
00:19:20,690 --> 00:19:23,630
This is calling a getter
method on v. And that's

395
00:19:23,630 --> 00:19:25,050
because we have no--

396
00:19:25,050 --> 00:19:28,720
we don't know what v is.

397
00:19:28,720 --> 00:19:33,250
So the Dart code that used to
do v.determinedBy will get

398
00:19:33,250 --> 00:19:35,590
translated to
v.get$determinedBy.

399
00:19:35,590 --> 00:19:41,250
Because we don't know if it's
a field or a getter.

400
00:19:41,250 --> 00:19:44,000
But with the new type
inferencing, we actually know

401
00:19:44,000 --> 00:19:47,910
that v is an object that has
a field and a getter called

402
00:19:47,910 --> 00:19:49,120
determinedBy.

403
00:19:49,120 --> 00:19:50,780
SETH LADD: Oh, that's so cool.

404
00:19:50,780 --> 00:19:52,790
NICOLAS GEOFFRAY: So we can just
inline the field access,

405
00:19:52,790 --> 00:19:54,050
like JavaScript field access.

406
00:19:54,050 --> 00:19:58,950
We know it won't
throw an error.

407
00:19:58,950 --> 00:20:01,160
And we know v has that field.

408
00:20:01,160 --> 00:20:03,670

409
00:20:03,670 --> 00:20:07,620
So that's one improvement.

410
00:20:07,620 --> 00:20:11,410
A second improvement
is the loop itself.

411
00:20:11,410 --> 00:20:14,870
So I told you that before we
couldn't generate a for loop

412
00:20:14,870 --> 00:20:16,120
because of all these checks.

413
00:20:16,120 --> 00:20:18,590

414
00:20:18,590 --> 00:20:22,800
These statements don't hold
in the for [INAUDIBLE]

415
00:20:22,800 --> 00:20:25,870
condition update typical loop.

416
00:20:25,870 --> 00:20:30,530
But with the new version, you
don't have these statements.

417
00:20:30,530 --> 00:20:32,550
You're not checking anymore.

418
00:20:32,550 --> 00:20:35,720
So you can actually just
generate something very

419
00:20:35,720 --> 00:20:39,530
similar to the Dart code, which
is, oh, I'm fetching

420
00:20:39,530 --> 00:20:42,690
constraints out of v. But
I know that the field

421
00:20:42,690 --> 00:20:47,190
constraints of v is a
JavaScript array.

422
00:20:47,190 --> 00:20:48,720
So I can just iterate
over the lengths.

423
00:20:48,720 --> 00:20:53,070

424
00:20:53,070 --> 00:20:57,120
And that makes it very easy
to generate a for loop.

425
00:20:57,120 --> 00:20:59,970
SETH LADD: And not only is this
faster code, but it's

426
00:20:59,970 --> 00:21:01,310
also much easier to read.

427
00:21:01,310 --> 00:21:03,930
So now the debugging of the
generated code, to me at

428
00:21:03,930 --> 00:21:05,300
least, gets a lot easier.

429
00:21:05,300 --> 00:21:05,560
NICOLAS GEOFFRAY: Yeah.

430
00:21:05,560 --> 00:21:08,635
If you look at the generated
code and the original code, it

431
00:21:08,635 --> 00:21:09,490
looks very similar.

432
00:21:09,490 --> 00:21:14,030
So you actually can make sense
of, oh, I got an error here.

433
00:21:14,030 --> 00:21:15,315
How does that map
to my Dart code?

434
00:21:15,315 --> 00:21:21,330

435
00:21:21,330 --> 00:21:25,080
Another improvement is all
this checking again.

436
00:21:25,080 --> 00:21:28,890
You're checking if t1 is
actually an array.

437
00:21:28,890 --> 00:21:30,870
And you're doing--

438
00:21:30,870 --> 00:21:33,400
so that's the check, right?

439
00:21:33,400 --> 00:21:39,630
And since you don't know if i is
in the range of the array,

440
00:21:39,630 --> 00:21:42,850
you do a range check here.

441
00:21:42,850 --> 00:21:44,620
And then you do the access,
because you know it's a

442
00:21:44,620 --> 00:21:46,442
JavaScript array.

443
00:21:46,442 --> 00:21:52,340
You know that it's in bounds,
so you don't throw an error.

444
00:21:52,340 --> 00:21:53,805
And you can just access
directly.

445
00:21:53,805 --> 00:21:56,840

446
00:21:56,840 --> 00:22:00,200
Because of the new type
inferencing, we now know that

447
00:22:00,200 --> 00:22:02,110
t1 is a JavaScript array.

448
00:22:02,110 --> 00:22:06,600
We know that i is in between
0 and t1.length.

449
00:22:06,600 --> 00:22:08,030
So we know it's not
out of bounds.

450
00:22:08,030 --> 00:22:11,150
So we don't need to emit
a bounds check.

451
00:22:11,150 --> 00:22:12,695
And we just generate the
[INAUDIBLE] access.

452
00:22:12,695 --> 00:22:15,710

453
00:22:15,710 --> 00:22:16,350
SETH LADD: That's huge.

454
00:22:16,350 --> 00:22:19,380
And one of the differences
there, thinking about the

455
00:22:19,380 --> 00:22:22,510
original code, is the difference
in behavior in a

456
00:22:22,510 --> 00:22:25,545
Dart list and a JavaScript array
when you access an index

457
00:22:25,545 --> 00:22:26,020
out of bounds.

458
00:22:26,020 --> 00:22:27,780
In Dart you'll get a--

459
00:22:27,780 --> 00:22:29,740
forgive if I don't get the
right name, but it's like

460
00:22:29,740 --> 00:22:31,880
index out of range error?

461
00:22:31,880 --> 00:22:32,940
NICOLAS GEOFFRAY: I think
that's changed

462
00:22:32,940 --> 00:22:33,990
to reg error now.

463
00:22:33,990 --> 00:22:35,630
SETH LADD: OK.

464
00:22:35,630 --> 00:22:36,290
You'll get a range error.

465
00:22:36,290 --> 00:22:39,480
But you'll get an actual
exception thrown when you try

466
00:22:39,480 --> 00:22:42,540
to access an index that's out
of the range of the list.

467
00:22:42,540 --> 00:22:45,880
But in JavaScript, I believe
you'll just get undefined.

468
00:22:45,880 --> 00:22:49,450
So the original Dart code had
to match that behavior.

469
00:22:49,450 --> 00:22:51,590
But it looks like now you're
able to be even smarter and

470
00:22:51,590 --> 00:22:55,440
say well, I know ahead of time
if these accesses are actually

471
00:22:55,440 --> 00:22:56,420
out of range.

472
00:22:56,420 --> 00:22:59,880
And if I know that, I don't
need to put that check in.

473
00:22:59,880 --> 00:23:01,340
That is great.

474
00:23:01,340 --> 00:23:02,190
NICOLAS GEOFFRAY:
That's correct.

475
00:23:02,190 --> 00:23:06,020
If JavaScript was to throw an
error when we got out of

476
00:23:06,020 --> 00:23:10,800
bounds, we wouldn't need
this code here.

477
00:23:10,800 --> 00:23:11,710
But it doesn't.

478
00:23:11,710 --> 00:23:14,830
And what happens is you just
get undefined out of it.

479
00:23:14,830 --> 00:23:18,750
And then you maybe get
an error later.

480
00:23:18,750 --> 00:23:23,410
But with Dart, you do get the
bounds check early, just

481
00:23:23,410 --> 00:23:25,560
before the access.

482
00:23:25,560 --> 00:23:27,830
But in that case, you actually
don't need it, because you

483
00:23:27,830 --> 00:23:30,000
know i is within the range.

484
00:23:30,000 --> 00:23:36,110

485
00:23:36,110 --> 00:23:39,100
SETH LADD: OK, I like that.

486
00:23:39,100 --> 00:23:40,740
NICOLAS GEOFFRAY: I'm sorry?

487
00:23:40,740 --> 00:23:41,780
SETH LADD: I like what
I see so far.

488
00:23:41,780 --> 00:23:44,492
This is great.

489
00:23:44,492 --> 00:23:46,590
NICOLAS GEOFFRAY: I
think that's not

490
00:23:46,590 --> 00:23:49,230
the last, but almost.

491
00:23:49,230 --> 00:23:50,130
That's another--

492
00:23:50,130 --> 00:23:55,200
that's the last optimization
that triggered the jump, the

493
00:23:55,200 --> 00:23:58,260
bump in the graph.

494
00:23:58,260 --> 00:24:04,100
It's knowing that when you're
doing an equals check--

495
00:24:04,100 --> 00:24:09,080
so the original code is c double
equal determining.

496
00:24:09,080 --> 00:24:15,150
And when dart2js knows that
you're actually just doing an

497
00:24:15,150 --> 00:24:19,900
identity check, because that
equals results in the object

498
00:24:19,900 --> 00:24:22,640
equals in Dart.

499
00:24:22,640 --> 00:24:29,240
So you could just emit the
definition of the identity

500
00:24:29,240 --> 00:24:32,650
check in Dart, which
is pretty complex.

501
00:24:32,650 --> 00:24:36,480
But the intent is that the
[INAUDIBLE] equals doesn't

502
00:24:36,480 --> 00:24:39,170
have to check for null.

503
00:24:39,170 --> 00:24:49,586
So if you pass a null, if
the receiver is null--

504
00:24:49,586 --> 00:24:49,960
I'm sorry.

505
00:24:49,960 --> 00:24:52,710
Let me revert.

506
00:24:52,710 --> 00:24:57,720
What I'm saying is that in
dart2js, we actually have two

507
00:24:57,720 --> 00:25:01,500
nulls, because of some
dumb problems with

508
00:25:01,500 --> 00:25:03,710
interaction with the DOM.

509
00:25:03,710 --> 00:25:06,815
One is undefined,
just undefined.

510
00:25:06,815 --> 00:25:09,460
And the other is JavaScript
null.

511
00:25:09,460 --> 00:25:16,460
So we cannot just use triple
equal for checking if two

512
00:25:16,460 --> 00:25:19,010
things are identical.

513
00:25:19,010 --> 00:25:20,600
We need to use double equal.

514
00:25:20,600 --> 00:25:22,030
That's what's happening here.

515
00:25:22,030 --> 00:25:24,030
c could be undefined of null.

516
00:25:24,030 --> 00:25:27,530
In that case, we need to
check if determining is

517
00:25:27,530 --> 00:25:28,270
undefined or null.

518
00:25:28,270 --> 00:25:30,480
And that's what's
happening here.

519
00:25:30,480 --> 00:25:35,260
The most interesting is that
here, it's the identity check.

520
00:25:35,260 --> 00:25:36,785
And we don't need to go
through a method.

521
00:25:36,785 --> 00:25:38,700
We just use the JavaScript
identity check.

522
00:25:38,700 --> 00:25:44,420

523
00:25:44,420 --> 00:25:47,770
SETH LADD: How does dart2js know
or infer that I'm doing

524
00:25:47,770 --> 00:25:52,960
basically an identity check?

525
00:25:52,960 --> 00:25:56,900
NICOLAS GEOFFRAY: It knows that
c, the [INAUDIBLE] equals

526
00:25:56,900 --> 00:25:59,940
on c is the wanted object.

527
00:25:59,940 --> 00:26:00,790
SETH LADD: OK.

528
00:26:00,790 --> 00:26:04,510
So this one, this particular
thing, wouldn't work if I

529
00:26:04,510 --> 00:26:07,510
implemented my own equals
equals, of course.

530
00:26:07,510 --> 00:26:11,550
NICOLAS GEOFFRAY: So if you
implemented your own, and the

531
00:26:11,550 --> 00:26:16,110
type inferencing would know what
kind of variable, what

532
00:26:16,110 --> 00:26:17,830
type that variable is.

533
00:26:17,830 --> 00:26:22,110
Then you would do actual direct
call of that method, of

534
00:26:22,110 --> 00:26:26,030
that operator equal of yours.

535
00:26:26,030 --> 00:26:28,570
In that case here-- before,
it actually didn't know

536
00:26:28,570 --> 00:26:29,820
what c could be.

537
00:26:29,820 --> 00:26:33,480

538
00:26:33,480 --> 00:26:36,410
Because of the way we generate
code, we cannot just call a

539
00:26:36,410 --> 00:26:37,890
method on c.

540
00:26:37,890 --> 00:26:42,270
If c was to be an integer, for
example, I mean, it's a

541
00:26:42,270 --> 00:26:46,230
JavaScript integer or number.

542
00:26:46,230 --> 00:26:48,170
It's not like you can call
something on it.

543
00:26:48,170 --> 00:26:51,720
So we need to code local
methods that will

544
00:26:51,720 --> 00:26:53,890
do all these checks.

545
00:26:53,890 --> 00:26:56,270
But now we actually know
what c could be.

546
00:26:56,270 --> 00:27:00,130
And we know that c, that you're
just doing an identity

547
00:27:00,130 --> 00:27:01,906
check on c.

548
00:27:01,906 --> 00:27:04,600
And you only need to emit
this code instead.

549
00:27:04,600 --> 00:27:07,130
SETH LADD: Great.

550
00:27:07,130 --> 00:27:11,990
NICOLAS GEOFFRAY: And the last
optimization I'll show you is

551
00:27:11,990 --> 00:27:12,620
this check.

552
00:27:12,620 --> 00:27:21,520
So the semantics in Dart of an
if check is that the condition

553
00:27:21,520 --> 00:27:24,000
must evaluate true.

554
00:27:24,000 --> 00:27:28,400
If it evaluates to anything
else, it's false.

555
00:27:28,400 --> 00:27:32,120
And that's very different than
JavaScript, where lots of

556
00:27:32,120 --> 00:27:33,670
things evaluate to true--

557
00:27:33,670 --> 00:27:38,830
1, non 0, non null,
non undefined.

558
00:27:38,830 --> 00:27:41,380
SETH LADD: Right, many
truthy values.

559
00:27:41,380 --> 00:27:42,630
NICOLAS GEOFFRAY: Exactly.

560
00:27:42,630 --> 00:27:44,320

561
00:27:44,320 --> 00:27:48,850
And Dart is very different, that
you have to be true to

562
00:27:48,850 --> 00:27:52,100
actually pass an if test.

563
00:27:52,100 --> 00:27:55,780
We generate a lot of triple
equals true when doing calls

564
00:27:55,780 --> 00:28:02,720
in if checks, because we
don't know what this

565
00:28:02,720 --> 00:28:06,780
method actually returns.

566
00:28:06,780 --> 00:28:10,170
With the new type inferencing,
we know that all the

567
00:28:10,170 --> 00:28:13,690
isSatisfied methods
in the benchmark

568
00:28:13,690 --> 00:28:17,180
always return the Boolean.

569
00:28:17,180 --> 00:28:20,680
It returns either false, the
JavaScript false, or the

570
00:28:20,680 --> 00:28:22,150
JavaScript true.

571
00:28:22,150 --> 00:28:24,490
So we don't need to compare.

572
00:28:24,490 --> 00:28:27,010
If that evaluates to false,
then the condition will be

573
00:28:27,010 --> 00:28:31,570
false and we won't go
in the if block.

574
00:28:31,570 --> 00:28:32,683
If it evaluates to
true, then fine.

575
00:28:32,683 --> 00:28:33,933
It will continue.

576
00:28:33,933 --> 00:28:36,540

577
00:28:36,540 --> 00:28:38,645
SETH LADD: Yeah, this code
is so much smarter.

578
00:28:38,645 --> 00:28:39,895
Good job.

579
00:28:39,895 --> 00:28:44,170

580
00:28:44,170 --> 00:28:49,330
NICOLAS GEOFFRAY: That's it,
comparing the old version of

581
00:28:49,330 --> 00:28:51,300
what we generated and the new
version of what we generated.

582
00:28:51,300 --> 00:28:57,160
I have a slide of what is the
actual implementation in the

583
00:28:57,160 --> 00:28:58,730
JavaScript benchmark.

584
00:28:58,730 --> 00:29:02,970
SETH LADD: OK, so this is what
V8 has been running as its

585
00:29:02,970 --> 00:29:06,110
version of DeltaBlue
for many years.

586
00:29:06,110 --> 00:29:07,960
This is the one we
measure against.

587
00:29:07,960 --> 00:29:10,110
NICOLAS GEOFFRAY: Yes, that's
the one idea of what is called

588
00:29:10,110 --> 00:29:11,670
now the Octane benchmark.

589
00:29:11,670 --> 00:29:15,800

590
00:29:15,800 --> 00:29:17,050
This is the Dart version.

591
00:29:17,050 --> 00:29:19,530

592
00:29:19,530 --> 00:29:20,340
No.

593
00:29:20,340 --> 00:29:21,410
This is not the Dart version.

594
00:29:21,410 --> 00:29:27,600
That's the dart2js version.

595
00:29:27,600 --> 00:29:30,670
Let me check if I have a Dart
version close to it.

596
00:29:30,670 --> 00:29:35,860

597
00:29:35,860 --> 00:29:37,920
No I don't.

598
00:29:37,920 --> 00:29:40,110
SETH LADD: I think we can flip
back and forth between the

599
00:29:40,110 --> 00:29:43,890
dart2js version and the
original V8 version.

600
00:29:43,890 --> 00:29:47,280
Because what's really
interesting to me is how did

601
00:29:47,280 --> 00:29:53,060
dart2js generate a version of
that method that's faster than

602
00:29:53,060 --> 00:29:53,950
the handwritten.

603
00:29:53,950 --> 00:29:55,940
Which, I guess most people
would assume that the

604
00:29:55,940 --> 00:29:58,440
handwritten benchmark is always

605
00:29:58,440 --> 00:29:59,210
going to be the fastest.

606
00:29:59,210 --> 00:30:01,150
So I think you you've got
a couple areas you're

607
00:30:01,150 --> 00:30:02,430
going to point out.

608
00:30:02,430 --> 00:30:04,960
NICOLAS GEOFFRAY: Yeah.

609
00:30:04,960 --> 00:30:09,410
So what's happening here,
actually I've highlighted what

610
00:30:09,410 --> 00:30:12,130
is happening.

611
00:30:12,130 --> 00:30:17,510
If you look at those statements
where you're doing

612
00:30:17,510 --> 00:30:22,400
something on cc and call,
the call variable--

613
00:30:22,400 --> 00:30:25,450

614
00:30:25,450 --> 00:30:26,700
how to start?

615
00:30:26,700 --> 00:30:29,875

616
00:30:29,875 --> 00:30:36,530
The JavaScript benchmark needs
to add some behavior to the

617
00:30:36,530 --> 00:30:37,780
JavaScript array.

618
00:30:37,780 --> 00:30:41,130

619
00:30:41,130 --> 00:30:44,157
There are multiple ways to
add new behaviors to

620
00:30:44,157 --> 00:30:45,220
a JavaScript array.

621
00:30:45,220 --> 00:30:51,360
You can drop it so you have your
own object that grabs a

622
00:30:51,360 --> 00:30:52,290
JavaScript array.

623
00:30:52,290 --> 00:30:55,840
And you do calls on
that object, and

624
00:30:55,840 --> 00:30:57,750
you get that behavior.

625
00:30:57,750 --> 00:31:00,040
Another way is to
monkey patch.

626
00:31:00,040 --> 00:31:04,190
That's adding new
methods to the

627
00:31:04,190 --> 00:31:06,050
JavaScript array prototype.

628
00:31:06,050 --> 00:31:11,730
But that latter solution
doesn't really scale.

629
00:31:11,730 --> 00:31:13,910
If you start to monkey patching
in one component of

630
00:31:13,910 --> 00:31:18,995
your application, then monkey
patching in another component

631
00:31:18,995 --> 00:31:23,250
could just not work, because
you're adding the same method

632
00:31:23,250 --> 00:31:26,610
name with different
parameters.

633
00:31:26,610 --> 00:31:28,510
SETH LADD: When you mix these
two worlds, you don't know

634
00:31:28,510 --> 00:31:30,000
what's going to happen.

635
00:31:30,000 --> 00:31:32,270
NICOLAS GEOFFRAY: Yes.

636
00:31:32,270 --> 00:31:37,330
So I guess that's the reason why
the JavaScript benchmark

637
00:31:37,330 --> 00:31:46,610
wraps the JavaScript array in
order to add new behavior, so

638
00:31:46,610 --> 00:31:50,090
the size, the add, and the add
under the new behavior.

639
00:31:50,090 --> 00:31:56,980
There's another method in the
benchmark that moves something

640
00:31:56,980 --> 00:32:01,520
from your array that matches
a pattern, or

641
00:32:01,520 --> 00:32:04,490
something like that.

642
00:32:04,490 --> 00:32:07,980
The benchmark actually wraps
a JavaScript array.

643
00:32:07,980 --> 00:32:14,270
And that's what Dart is also
doing with its list class.

644
00:32:14,270 --> 00:32:18,740
The list class in Dart has lots
of behavior, not just the

645
00:32:18,740 --> 00:32:21,230
JavaScript array behavior.

646
00:32:21,230 --> 00:32:27,240
And what dart2js does is it
compiles a list object to a

647
00:32:27,240 --> 00:32:28,650
JavaScript array.

648
00:32:28,650 --> 00:32:33,490
But in order to have that new
behavior in the JavaScript

649
00:32:33,490 --> 00:32:36,440
array, it uses that
functionality called

650
00:32:36,440 --> 00:32:44,510
interceptors that will hold
this new behavior.

651
00:32:44,510 --> 00:32:47,210
And that's the reason why
we could just generate a

652
00:32:47,210 --> 00:32:52,460
JavaScript array out of
a list, a Dart list.

653
00:32:52,460 --> 00:32:55,160
And when you call methods
that are on the list--

654
00:32:55,160 --> 00:32:58,480
like filter--

655
00:32:58,480 --> 00:33:00,100
well now it's called
RemoveWhere--

656
00:33:00,100 --> 00:33:04,080
all these methods are in list
in a simple class called

657
00:33:04,080 --> 00:33:05,380
[? iterable. ?]

658
00:33:05,380 --> 00:33:07,490
All these methods will actually
go through an

659
00:33:07,490 --> 00:33:16,415
interceptor that will implement
the behavior.

660
00:33:16,415 --> 00:33:17,990
SETH LADD: Let's see
the version that

661
00:33:17,990 --> 00:33:19,210
dart2js spits out again.

662
00:33:19,210 --> 00:33:22,100
I think that will make
it more clear.

663
00:33:22,100 --> 00:33:26,120

664
00:33:26,120 --> 00:33:27,640
NICOLAS GEOFFRAY: Since we
actually use a JavaScript

665
00:33:27,640 --> 00:33:34,140
array for a Dart list, the
dart2js knows that you can

666
00:33:34,140 --> 00:33:38,130
actually just do an
array access, a

667
00:33:38,130 --> 00:33:40,540
JavaScript array access.

668
00:33:40,540 --> 00:33:44,770
Like here, so you notice at t1
is a Dart list that will map

669
00:33:44,770 --> 00:33:46,190
to a JavaScript array.

670
00:33:46,190 --> 00:33:51,140
So you can just do a direct
JavaScript array axis.

671
00:33:51,140 --> 00:33:54,270
And the same for call here.

672
00:33:54,270 --> 00:33:56,750
It knows that it's
a Dart list.

673
00:33:56,750 --> 00:34:00,200
That means it knows it's a
JavaScript array at runtime.

674
00:34:00,200 --> 00:34:03,290
So you can just call the push
method, which is something

675
00:34:03,290 --> 00:34:05,850
that is on the JavaScript array
prototype by default.

676
00:34:05,850 --> 00:34:08,650

677
00:34:08,650 --> 00:34:10,600
SETH LADD: And you can do this
because you've globally

678
00:34:10,600 --> 00:34:13,889
analyzed the program and
you know what t1 is.

679
00:34:13,889 --> 00:34:15,000
NICOLAS GEOFFRAY: Exactly.

680
00:34:15,000 --> 00:34:16,120
SETH LADD: That is awesome.

681
00:34:16,120 --> 00:34:17,570
That is so cool.

682
00:34:17,570 --> 00:34:20,520
NICOLAS GEOFFRAY: And we also
know that all the [INAUDIBLE]

683
00:34:20,520 --> 00:34:24,580
of add constraints consuming
to pass an array

684
00:34:24,580 --> 00:34:26,909
here, or a Dart list.

685
00:34:26,909 --> 00:34:29,219
SETH LADD: So that's actually
really good key point.

686
00:34:29,219 --> 00:34:33,690
Again, when we say global type
inferencing, you mean not just

687
00:34:33,690 --> 00:34:37,620
obviously inside a function, but
also everyone, and we mean

688
00:34:37,620 --> 00:34:39,449
everybody who calls into
this function.

689
00:34:39,449 --> 00:34:41,679
You know what they're passing
in, so you make a whole bunch

690
00:34:41,679 --> 00:34:44,310
of assumptions then inside
the function.

691
00:34:44,310 --> 00:34:44,680
NICOLAS GEOFFRAY: Yeah.

692
00:34:44,680 --> 00:34:45,630
That's correct.

693
00:34:45,630 --> 00:34:47,460
SETH LADD: Yeah, cool.

694
00:34:47,460 --> 00:34:52,340
That to me sounds like one of
the major differences between

695
00:34:52,340 --> 00:34:55,920
how far V8's able to go and how
far dart2js or the VM is

696
00:34:55,920 --> 00:34:58,990
able to go, based on--

697
00:34:58,990 --> 00:35:01,560
we really have a closed world
assumption when we're thinking

698
00:35:01,560 --> 00:35:03,760
about Dart applications.

699
00:35:03,760 --> 00:35:04,530
NICOLAS GEOFFRAY: That's
basically it.

700
00:35:04,530 --> 00:35:06,280
And since it's very
structured, it's

701
00:35:06,280 --> 00:35:07,930
very easy to analyze.

702
00:35:07,930 --> 00:35:09,821
Well, it's relatively
easy to analyze.

703
00:35:09,821 --> 00:35:12,800
It's definitely easier
than JavaScript code.

704
00:35:12,800 --> 00:35:16,510
SETH LADD: So here's an
interesting point.

705
00:35:16,510 --> 00:35:20,080
Your global type inferencing
system does not respect type

706
00:35:20,080 --> 00:35:24,850
annotations at all, due to the
semantics of the types or the

707
00:35:24,850 --> 00:35:25,900
type annotations.

708
00:35:25,900 --> 00:35:28,280
So I means I could write a
program with zero type

709
00:35:28,280 --> 00:35:32,670
annotations and still get the
exact same benefits from

710
00:35:32,670 --> 00:35:34,596
dart2js today.

711
00:35:34,596 --> 00:35:35,080
NICOLAS GEOFFRAY: Yeah.

712
00:35:35,080 --> 00:35:38,016
Same benefits, and the same
applies to the VM.

713
00:35:38,016 --> 00:35:38,850
SETH LADD: Yeah.

714
00:35:38,850 --> 00:35:39,200
That's a great point.

715
00:35:39,200 --> 00:35:40,550
NICOLAS GEOFFRAY: The VM
doesn't look at type

716
00:35:40,550 --> 00:35:41,910
annotations either.

717
00:35:41,910 --> 00:35:46,320
So type annotations is really a
tool for the developer to do

718
00:35:46,320 --> 00:35:50,150
refactoring and share some code
with other developers.

719
00:35:50,150 --> 00:35:53,680
SETH LADD: So it sounds like
if I as a developer want to

720
00:35:53,680 --> 00:35:56,170
take advantage of some of these
nice new inferencing

721
00:35:56,170 --> 00:36:00,130
optimizations, just make sure
that I assign a variable the

722
00:36:00,130 --> 00:36:05,390
same type all the time, and
dart2js will respect that.

723
00:36:05,390 --> 00:36:05,710
NICOLAS GEOFFRAY: Yeah.

724
00:36:05,710 --> 00:36:08,040
There are some couple of things
that will make dart2js

725
00:36:08,040 --> 00:36:08,750
very happy.

726
00:36:08,750 --> 00:36:12,310
So if you start assigning the
same thing to a variable or a

727
00:36:12,310 --> 00:36:16,450
field, it will be able to apply

728
00:36:16,450 --> 00:36:18,340
optimization based on it.

729
00:36:18,340 --> 00:36:21,740
SETH LADD: So for everyone
following at home, use final

730
00:36:21,740 --> 00:36:26,740
and don't change field types,
and you'll be much happier.

731
00:36:26,740 --> 00:36:29,410
NICOLAS GEOFFRAY: And if you
have a field that is supposed

732
00:36:29,410 --> 00:36:32,790
to hold a number, make sure
it holds a number.

733
00:36:32,790 --> 00:36:34,380
And it can never be null.

734
00:36:34,380 --> 00:36:38,960

735
00:36:38,960 --> 00:36:40,670
So the Dart VM--

736
00:36:40,670 --> 00:36:43,060
it shouldn't affect
the Dart VM much.

737
00:36:43,060 --> 00:36:45,810
But for dart2js, it's very
important because of what's

738
00:36:45,810 --> 00:36:46,720
happening in JavaScript.

739
00:36:46,720 --> 00:36:49,710
In JavaScript, when you
do null plus 42, you

740
00:36:49,710 --> 00:36:50,500
actually get 42.

741
00:36:50,500 --> 00:36:54,700
To the null gets
converted to 0.

742
00:36:54,700 --> 00:36:55,880
SETH LADD: That's logical.

743
00:36:55,880 --> 00:37:00,430
NICOLAS GEOFFRAY: In Dart, null
plus should throw you a

744
00:37:00,430 --> 00:37:03,540
null pointer exception.

745
00:37:03,540 --> 00:37:09,840
So if dart2js knows that this
field is always a number, it

746
00:37:09,840 --> 00:37:13,310
won't have to do any checking.

747
00:37:13,310 --> 00:37:15,250
SETH LADD: So what I'm thinking
about now is when I

748
00:37:15,250 --> 00:37:19,480
have classes that have fields
that should be numbers, make

749
00:37:19,480 --> 00:37:25,540
sure I initialize them in
the initializer list.

750
00:37:25,540 --> 00:37:29,250
NICOLAS GEOFFRAY: In the
initializer list, or where the

751
00:37:29,250 --> 00:37:32,220
field is declared.

752
00:37:32,220 --> 00:37:35,320
It makes the type
inferencing--

753
00:37:35,320 --> 00:37:39,240
it makes the life of the type
inferencing a lot easier.

754
00:37:39,240 --> 00:37:40,430
SETH LADD: Wow, that
is a great tip.

755
00:37:40,430 --> 00:37:43,680
I was going to ask is there
anything else that I need to

756
00:37:43,680 --> 00:37:47,190
do as a developer to write code
in a special way to take

757
00:37:47,190 --> 00:37:47,960
advantage of this.

758
00:37:47,960 --> 00:37:50,020
And so the good tip is, if I'm
dealing with numbers, make

759
00:37:50,020 --> 00:37:51,520
sure they're always initialized
to a number, and

760
00:37:51,520 --> 00:37:54,284
don't change them from a number
to something else.

761
00:37:54,284 --> 00:37:56,350
NICOLAS GEOFFRAY: Yeah.

762
00:37:56,350 --> 00:37:59,640
Keep your fields sane.

763
00:37:59,640 --> 00:38:01,950
That's what you should say.

764
00:38:01,950 --> 00:38:04,020
SETH LADD: Well I really,
really appreciate this.

765
00:38:04,020 --> 00:38:05,700
This video is recorded.

766
00:38:05,700 --> 00:38:07,890
We're going to post it up
for everyone to watch.

767
00:38:07,890 --> 00:38:11,810
And so I am very encouraged
and happy to see the bumps

768
00:38:11,810 --> 00:38:14,820
that you and your team are able
to push out for dart2js,

769
00:38:14,820 --> 00:38:17,490
so excellent work there.

770
00:38:17,490 --> 00:38:19,970
Can we expect more benchmarks?

771
00:38:19,970 --> 00:38:26,100
And what we expect in terms of
how much you're rolling out

772
00:38:26,100 --> 00:38:28,320
this type inferencing?

773
00:38:28,320 --> 00:38:30,010
NICOLAS GEOFFRAY: So
it just started.

774
00:38:30,010 --> 00:38:33,620
It's been two weeks since we
started on type inferencing.

775
00:38:33,620 --> 00:38:36,550
And right now it's
pretty naive.

776
00:38:36,550 --> 00:38:41,970
There's a lot of improvements we
know we can do, except that

777
00:38:41,970 --> 00:38:44,235
it gets more and more complex
to implement.

778
00:38:44,235 --> 00:38:48,250

779
00:38:48,250 --> 00:38:50,330
We still have the same bar.

780
00:38:50,330 --> 00:38:53,180
We were generating JavaScript
code, and what we want is

781
00:38:53,180 --> 00:38:57,120
actually to be as fast as
handwritten JavaScript code.

782
00:38:57,120 --> 00:38:59,180
And we're getting
closer to that.

783
00:38:59,180 --> 00:39:03,000
If you look at DeltaBlue,
that's what's happening.

784
00:39:03,000 --> 00:39:07,850
We have some other benchmarks,
and we're getting close to the

785
00:39:07,850 --> 00:39:09,840
same performance.

786
00:39:09,840 --> 00:39:11,840
They need more work,
obviously.

787
00:39:11,840 --> 00:39:15,960
The reason why they're not
public yet, those benchmarks,

788
00:39:15,960 --> 00:39:19,766
is because publishing
a new benchmark is--

789
00:39:19,766 --> 00:39:22,130
I mean, we need to make
sure they're relevant.

790
00:39:22,130 --> 00:39:25,770
And we need to make sure that
they apply to JavaScript and

791
00:39:25,770 --> 00:39:31,202
Dart, and both versions have
equivalent functionalities and

792
00:39:31,202 --> 00:39:33,030
stuff like that.

793
00:39:33,030 --> 00:39:36,420
So it's not that [INAUDIBLE] to
publish those benchmarks.

794
00:39:36,420 --> 00:39:38,870
SETH LADD: Right, but I get the
sense we'll see more over

795
00:39:38,870 --> 00:39:43,220
time as we've tested them out
and making sure they're

796
00:39:43,220 --> 00:39:44,750
relevant and correct.

797
00:39:44,750 --> 00:39:45,430
NICOLAS GEOFFRAY: Yes.

798
00:39:45,430 --> 00:39:49,610
I mean, the V8 benchmark suite
that is now Octane benchmark

799
00:39:49,610 --> 00:39:53,715
suite, it took some time
to publish it.

800
00:39:53,715 --> 00:39:57,480
It's not super obvious that all
those benchmarks actually

801
00:39:57,480 --> 00:40:00,330
are relevant initially.

802
00:40:00,330 --> 00:40:04,040
SETH LADD: Well I like
what I see so far.

803
00:40:04,040 --> 00:40:06,360
Dart developers can take
advantage of this today.

804
00:40:06,360 --> 00:40:09,050
This is code that has
been checked in.

805
00:40:09,050 --> 00:40:14,130
When you get the dart SDK and
you compile the JavaScript,

806
00:40:14,130 --> 00:40:16,680
they're going to see these
improvements, or at least the

807
00:40:16,680 --> 00:40:17,620
beginnings of these
improvements.

808
00:40:17,620 --> 00:40:19,460
So this stuff is real
and available today.

809
00:40:19,460 --> 00:40:22,510

810
00:40:22,510 --> 00:40:24,890
Well, thank you on the behalf
of the Dartisans community.

811
00:40:24,890 --> 00:40:26,380
Nicolas, thanks for joining
us today and

812
00:40:26,380 --> 00:40:27,370
preparing these slides.

813
00:40:27,370 --> 00:40:29,910
It was a great walkthrough, and
I really appreciate it and

814
00:40:29,910 --> 00:40:32,120
learned a ton of stuff myself.

815
00:40:32,120 --> 00:40:36,270
So hopefully we'll have you back
again later when we've

816
00:40:36,270 --> 00:40:39,540
got other cool stuff to show
from the dart2js world.

817
00:40:39,540 --> 00:40:40,220
NICOLAS GEOFFRAY: My pleasure.

818
00:40:40,220 --> 00:40:43,030
Maybe tomorrow.

819
00:40:43,030 --> 00:40:45,910
SETH LADD: You guys are fast.

820
00:40:45,910 --> 00:40:48,040
Well thank you very much and
we'll see you next time.

821
00:40:48,040 --> 00:40:49,310
Bye, Nicolas.

822
00:40:49,310 --> 00:40:50,560
NICOLAS GEOFFRAY: See you.

823
00:40:50,560 --> 00:40:50,860

